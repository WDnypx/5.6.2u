"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _utils = require("../../ui/src/utils");
var _dom = require("../../ui/src/dom");
var _util = require("../../date-panel/src/util");
var _vn = require("../../ui/src/vn");
var _log = require("../../ui/src/log");
var _datePanel = _interopRequireDefault(require("../../date-panel/src/date-panel"));
var _button = _interopRequireDefault(require("../../button/src/button"));
var _buttonGroup = _interopRequireDefault(require("../../button/src/button-group"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeDateRangePicker',
  mixins: [_ui.globalMixins.sizeMixin],
  model: {
    prop: 'value',
    event: 'modelValue'
  },
  props: {
    value: [String, Number, Date, Array],
    startValue: [String, Number, Date],
    endValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.clearable;
      }
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: String,
    className: String,
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.size || (0, _ui.getConfig)().size;
      }
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    defaultDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.startDay;
      }
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.festivalMethod;
      }
    },
    disabledMethod: {
      type: Function,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.disabledMethod;
      }
    },
    separator: {
      type: [String, Number],
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.separator;
      }
    },
    // week
    selectDay: {
      type: [String, Number],
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.selectDay;
      }
    },
    showClearButton: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.showClearButton;
      }
    },
    showConfirmButton: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.showConfirmButton;
      }
    },
    autoClose: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().dateRangePicker.autoClose;
      }
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object
  },
  inject: {
    $xeModal: {
      default: null
    },
    $xeDrawer: {
      default: null
    },
    $xeTable: {
      default: null
    },
    $xeForm: {
      default: null
    },
    formItemInfo: {
      from: 'xeFormItemInfo',
      default: null
    }
  },
  provide: function provide() {
    var $xeDateRangePicker = this;
    return {
      $xeDateRangePicker: $xeDateRangePicker
    };
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      startValue: '',
      endValue: ''
    };
    var internalData = {
      // selectStatus: false
      // hpTimeout: undefined
    };
    return {
      xID: xID,
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeBtnTransfer: function computeBtnTransfer() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var $xeTable = $xeDateRangePicker.$xeTable;
      var $xeModal = $xeDateRangePicker.$xeModal;
      var $xeDrawer = $xeDateRangePicker.$xeDrawer;
      var $xeForm = $xeDateRangePicker.$xeForm;
      var transfer = props.transfer;
      if (transfer === null) {
        var globalTransfer = (0, _ui.getConfig)().dateRangePicker.transfer;
        if (_xeUtils.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    },
    computeFormReadonly: function computeFormReadonly() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var $xeForm = $xeDateRangePicker.$xeForm;
      var readonly = props.readonly;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.readonly;
        }
        return false;
      }
      return readonly;
    },
    computeIsDisabled: function computeIsDisabled() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var $xeForm = $xeDateRangePicker.$xeForm;
      var disabled = props.disabled;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.disabled;
        }
        return false;
      }
      return disabled;
    },
    computeMVal: function computeMVal() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var startValue = props.startValue,
        endValue = props.endValue;
      return "".concat(startValue || '').concat(endValue || '');
    },
    computeIsDateTimeType: function computeIsDateTimeType() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var type = props.type;
      return type === 'time' || type === 'datetime';
    },
    computeIsDatePickerType: function computeIsDatePickerType() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    },
    computeIsClearable: function computeIsClearable() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      return props.clearable;
    },
    computeInpPlaceholder: function computeInpPlaceholder() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var placeholder = props.placeholder;
      if (placeholder) {
        return (0, _utils.getFuncText)(placeholder);
      }
      var globalPlaceholder = (0, _ui.getConfig)().dateRangePicker.placeholder;
      if (globalPlaceholder) {
        return (0, _utils.getFuncText)(globalPlaceholder);
      }
      return (0, _ui.getI18n)('vxe.dateRangePicker.pleaseRange');
    },
    computeInpImmediate: function computeInpImmediate() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var immediate = props.immediate;
      return immediate;
    },
    computeShortcutOpts: function computeShortcutOpts() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      return Object.assign({}, (0, _ui.getConfig)().dateRangePicker.shortcutConfig, props.shortcutConfig);
    },
    computeShortcutList: function computeShortcutList() {
      var $xeDateRangePicker = this;
      var shortcutOpts = $xeDateRangePicker.computeShortcutOpts;
      var options = shortcutOpts.options;
      if (options) {
        return options.map(function (option, index) {
          return Object.assign({
            name: "".concat(option.name || option.code || index)
          }, option);
        });
      }
      return [];
    },
    computeDateLabelFormat: function computeDateLabelFormat() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var labelFormat = props.labelFormat;
      return labelFormat || (0, _ui.getI18n)("vxe.input.date.labelFormat.".concat(props.type));
    },
    computeDateValueFormat: function computeDateValueFormat() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var type = props.type,
        valueFormat = props.valueFormat;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === 'time') {
        return 'HH:mm:ss';
      }
      if (type === 'datetime') {
        return 'yyyy-MM-dd HH:mm:ss';
      }
      return 'yyyy-MM-dd';
    },
    computeFirstDayOfWeek: function computeFirstDayOfWeek() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var startDay = props.startDay;
      return _xeUtils.default.toNumber(startDay);
    },
    computePanelLabelObj: function computePanelLabelObj() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var startValue = reactData.startValue,
        endValue = reactData.endValue;
      var vals = startValue || endValue ? [startValue || '', endValue || ''] : [];
      return $xeDateRangePicker.formatRangeLabel(vals);
    },
    computeInputLabel: function computeInputLabel() {
      var $xeDateRangePicker = this;
      var panelLabelObj = $xeDateRangePicker.computePanelLabelObj;
      return panelLabelObj.label;
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.$emit(type, (0, _ui.createEvent)(evnt, {
        $drawer: $xeDateRangePicker
      }, params));
    },
    emitModel: function emitModel(value) {
      var $xeDateRangePicker = this;
      var _events = $xeDateRangePicker._events;
      if (_events && _events.modelValue) {
        $xeDateRangePicker.$emit('modelValue', value);
      } else {
        $xeDateRangePicker.$emit('model-value', value);
      }
    },
    formatRangeLabel: function formatRangeLabel(vals) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var type = props.type,
        separator = props.separator;
      var dateLabelFormat = $xeDateRangePicker.computeDateLabelFormat;
      var dateValueFormat = $xeDateRangePicker.computeDateValueFormat;
      var firstDayOfWeek = $xeDateRangePicker.computeFirstDayOfWeek;
      var startRest = vals[0] ? (0, _util.parseDateObj)(vals[0], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      var endRest = vals[1] ? (0, _util.parseDateObj)(vals[1], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      var startLabel = startRest ? startRest.label : '';
      var endLabel = endRest ? endRest.label : '';
      return {
        label: (startLabel || endLabel ? [startLabel, endLabel] : []).join("".concat(separator || ' ~ ')),
        startLabel: startLabel,
        endLabel: endLabel
      };
    },
    getRangeValue: function getRangeValue(sValue, eValue) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var modelValue = props.value;
      var isArr = _xeUtils.default.isArray(modelValue);
      if (sValue || eValue) {
        var rest = [sValue || '', eValue || ''];
        if (isArr) {
          return rest;
        }
        return rest.join(',');
      }
      return isArr ? [] : '';
    },
    paraeUpdateModel: function paraeUpdateModel() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var type = props.type,
        modelValue = props.value;
      var dateValueFormat = $xeDateRangePicker.computeDateValueFormat;
      var sValue = '';
      var eValue = '';
      if (_xeUtils.default.isArray(modelValue)) {
        var date1 = (0, _util.parseDateString)(modelValue[0], type, {
          valueFormat: dateValueFormat
        });
        var date2 = (0, _util.parseDateString)(modelValue[1], type, {
          valueFormat: dateValueFormat
        });
        if (date1 || date2) {
          sValue = date1 || '';
          eValue = date2 || '';
        }
      } else if (_xeUtils.default.isString(modelValue)) {
        var strArr = modelValue.split(',');
        if (strArr[0] || strArr[1]) {
          sValue = strArr[0] || '';
          eValue = strArr[1] || '';
        }
      }
      return {
        sValue: sValue,
        eValue: eValue
      };
    },
    parseUpdateData: function parseUpdateData() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var type = props.type,
        startValue = props.startValue,
        endValue = props.endValue;
      var dateValueFormat = $xeDateRangePicker.computeDateValueFormat;
      var sValue = '';
      var eValue = '';
      sValue = (0, _util.parseDateString)(startValue, type, {
        valueFormat: dateValueFormat
      });
      eValue = (0, _util.parseDateString)(endValue, type, {
        valueFormat: dateValueFormat
      });
      return {
        sValue: sValue,
        eValue: eValue
      };
    },
    updateModelValue: function updateModelValue(isModel) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var modelValue = props.value,
        startValue = props.startValue,
        endValue = props.endValue;
      var restObj = {
        sValue: '',
        eValue: ''
      };
      if (isModel) {
        if (modelValue) {
          restObj = $xeDateRangePicker.paraeUpdateModel();
        } else {
          restObj = $xeDateRangePicker.parseUpdateData();
        }
      } else {
        if (startValue || endValue) {
          restObj = $xeDateRangePicker.parseUpdateData();
        } else {
          restObj = $xeDateRangePicker.paraeUpdateModel();
        }
      }
      reactData.startValue = restObj.sValue;
      reactData.endValue = restObj.eValue;
    },
    triggerEvent: function triggerEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var startValue = reactData.startValue,
        endValue = reactData.endValue;
      var value = $xeDateRangePicker.getRangeValue(startValue, endValue);
      $xeDateRangePicker.dispatchEvent(evnt.type, {
        value: value,
        startValue: startValue,
        endValue: endValue
      }, evnt);
    },
    handleChange: function handleChange(sValue, eValue, evnt) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var $xeForm = $xeDateRangePicker.$xeForm;
      var formItemInfo = $xeDateRangePicker.formItemInfo;
      var modelValue = props.value;
      reactData.startValue = sValue;
      reactData.endValue = eValue;
      var value = $xeDateRangePicker.getRangeValue(sValue, eValue);
      $xeDateRangePicker.emitModel(value);
      $xeDateRangePicker.$emit('update:startValue', sValue || '');
      $xeDateRangePicker.$emit('update:endValue', eValue || '');
      if (_xeUtils.default.toValueString(modelValue) !== value) {
        $xeDateRangePicker.dispatchEvent('change', {
          value: value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    },
    changeEvent: function changeEvent(evnt) {
      var $xeDateRangePicker = this;
      var inpImmediate = $xeDateRangePicker.computeInpImmediate;
      if (!inpImmediate) {
        $xeDateRangePicker.triggerEvent(evnt);
      }
    },
    focusEvent: function focusEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      reactData.isActivated = true;
      $xeDateRangePicker.dateRangePickerOpenEvent(evnt);
      $xeDateRangePicker.triggerEvent(evnt);
    },
    clickPrefixEvent: function clickPrefixEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      if (!isDisabled) {
        var startValue = reactData.startValue,
          endValue = reactData.endValue;
        var value = $xeDateRangePicker.getRangeValue(startValue, endValue);
        $xeDateRangePicker.dispatchEvent('prefix-click', {
          value: value,
          startValue: startValue,
          endValue: endValue
        }, evnt);
      }
    },
    hidePanel: function hidePanel() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var internalData = $xeDateRangePicker.internalData;
      return new Promise(function (resolve) {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(function () {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    },
    clearValueEvent: function clearValueEvent(evnt, value) {
      var $xeDateRangePicker = this;
      var isDatePickerType = $xeDateRangePicker.computeIsDatePickerType;
      if (isDatePickerType) {
        $xeDateRangePicker.hidePanel();
      }
      $xeDateRangePicker.handleChange('', '', evnt);
      $xeDateRangePicker.dispatchEvent('clear', {
        value: value
      }, evnt);
    },
    checkValue: function checkValue() {
      var $xeDateRangePicker = this;
      var $startDatePanel = $xeDateRangePicker.$refs.refStartDatePanel;
      var $endDatePanel = $xeDateRangePicker.$refs.refEndDatePanel;
      if ($startDatePanel && $endDatePanel) {
        var startValue = $startDatePanel.getModelValue();
        var endValue = $endDatePanel.getModelValue();
        if (!startValue || !endValue) {
          $xeDateRangePicker.handleChange('', '', {
            type: 'check'
          });
        }
      }
    },
    handleSelectClose: function handleSelectClose() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var internalData = $xeDateRangePicker.internalData;
      var autoClose = props.autoClose;
      var startValue = reactData.startValue,
        endValue = reactData.endValue;
      var selectStatus = internalData.selectStatus;
      var isDatePickerType = $xeDateRangePicker.computeIsDatePickerType;
      if (autoClose) {
        if (selectStatus && isDatePickerType) {
          if (startValue && endValue) {
            $xeDateRangePicker.hidePanel();
          }
        }
      } else {
        if (startValue && endValue) {
          internalData.selectStatus = false;
        }
      }
    },
    clickSuffixEvent: function clickSuffixEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      if (!isDisabled) {
        var startValue = reactData.startValue,
          endValue = reactData.endValue;
        var value = $xeDateRangePicker.getRangeValue(startValue, endValue);
        $xeDateRangePicker.dispatchEvent('suffix-click', {
          value: value,
          startValue: startValue,
          endValue: endValue
        }, evnt);
      }
    },
    blurEvent: function blurEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var $xeForm = $xeDateRangePicker.$xeForm;
      var formItemInfo = $xeDateRangePicker.formItemInfo;
      var startValue = reactData.startValue,
        endValue = reactData.endValue;
      var inpImmediate = $xeDateRangePicker.computeInpImmediate;
      var value = '';
      if (!inpImmediate) {
        $xeDateRangePicker.handleChange(startValue, endValue, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      $xeDateRangePicker.dispatchEvent('blur', {
        value: value,
        startValue: startValue,
        endValue: endValue
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    },
    keydownEvent: function keydownEvent(evnt) {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.triggerEvent(evnt);
    },
    keyupEvent: function keyupEvent(evnt) {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.triggerEvent(evnt);
    },
    confirmEvent: function confirmEvent(evnt) {
      var $xeDateRangePicker = this;
      var $startDatePanel = $xeDateRangePicker.$refs.refStartDatePanel;
      var $endDatePanel = $xeDateRangePicker.$refs.refEndDatePanel;
      if ($startDatePanel && $endDatePanel) {
        var startValue = $startDatePanel.getModelValue();
        var endValue = $endDatePanel.getModelValue();
        if (startValue && !endValue || !startValue && endValue) {
          $xeDateRangePicker.handleChange('', '', evnt);
        } else {
          $startDatePanel.confirmByEvent(evnt);
          $endDatePanel.confirmByEvent(evnt);
        }
      }
      $xeDateRangePicker.hidePanel();
    },
    startPanelChangeEvent: function startPanelChangeEvent(params) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var internalData = $xeDateRangePicker.internalData;
      var selectStatus = internalData.selectStatus;
      var value = params.value,
        $event = params.$event;
      var endValue = selectStatus ? reactData.endValue : '';
      $xeDateRangePicker.handleChange(value, endValue, $event);
      $xeDateRangePicker.handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      $xeDateRangePicker.$nextTick(function () {
        var $startDatePanel = $xeDateRangePicker.$refs.refStartDatePanel;
        var $endDatePanel = $xeDateRangePicker.$refs.refEndDatePanel;
        if ($startDatePanel && $endDatePanel) {
          var startValue = $startDatePanel.getModelValue();
          if (!endValue && startValue) {
            $endDatePanel.setPanelDate(_xeUtils.default.toStringDate(startValue));
          }
        }
      });
    },
    endPanelChangeEvent: function endPanelChangeEvent(params) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var internalData = $xeDateRangePicker.internalData;
      var selectStatus = internalData.selectStatus;
      var value = params.value,
        $event = params.$event;
      var startValue = selectStatus ? reactData.startValue : '';
      $xeDateRangePicker.handleChange(startValue, value, $event);
      $xeDateRangePicker.handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      $xeDateRangePicker.$nextTick(function () {
        var $startDatePanel = $xeDateRangePicker.$refs.refStartDatePanel;
        var $endDatePanel = $xeDateRangePicker.$refs.refEndDatePanel;
        if ($startDatePanel && $endDatePanel) {
          var endValue = $endDatePanel.getModelValue();
          if (!startValue && endValue) {
            $startDatePanel.setPanelDate(_xeUtils.default.toStringDate(endValue));
          }
        }
      });
    },
    // 全局事件
    handleGlobalMousedownEvent: function handleGlobalMousedownEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var visiblePanel = reactData.visiblePanel,
        isActivated = reactData.isActivated;
      var el = $xeDateRangePicker.$refs.refElem;
      var panelWrapperElem = $xeDateRangePicker.$refs.refPanelWrapper;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      if (!isDisabled && isActivated) {
        reactData.isActivated = (0, _dom.getEventTargetNode)(evnt, el).flag || (0, _dom.getEventTargetNode)(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            $xeDateRangePicker.checkValue();
            $xeDateRangePicker.hidePanel();
          }
        }
      }
    },
    handleGlobalMousewheelEvent: function handleGlobalMousewheelEvent(evnt) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var visiblePanel = reactData.visiblePanel;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      if (!isDisabled) {
        if (visiblePanel) {
          var panelWrapperElem = $xeDateRangePicker.$refs.refPanelWrapper;
          if ((0, _dom.getEventTargetNode)(evnt, panelWrapperElem).flag) {
            $xeDateRangePicker.updatePlacement();
          } else {
            $xeDateRangePicker.hidePanel();
          }
        }
      }
    },
    handleGlobalBlurEvent: function handleGlobalBlurEvent() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var visiblePanel = reactData.visiblePanel;
      if (visiblePanel) {
        $xeDateRangePicker.hidePanel();
      }
    },
    // 弹出面板
    updateZindex: function updateZindex() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      if (reactData.panelIndex < (0, _utils.getLastZIndex)()) {
        reactData.panelIndex = (0, _utils.nextZIndex)();
      }
    },
    updatePlacement: function updatePlacement() {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var placement = props.placement;
      var panelIndex = reactData.panelIndex;
      var targetElem = $xeDateRangePicker.$refs.refInputTarget;
      var panelElem = $xeDateRangePicker.$refs.refInputPanel;
      var btnTransfer = $xeDateRangePicker.computeBtnTransfer;
      var handleStyle = function handleStyle() {
        var ppObj = (0, _dom.updatePanelPlacement)(targetElem, panelElem, {
          placement: placement,
          teleportTo: btnTransfer
        });
        var panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return $xeDateRangePicker.$nextTick().then(handleStyle);
    },
    showPanel: function showPanel() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var internalData = $xeDateRangePicker.internalData;
      var visiblePanel = reactData.visiblePanel;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      var btnTransfer = $xeDateRangePicker.computeBtnTransfer;
      var panelElem = $xeDateRangePicker.$refs.refInputPanel;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
          if (btnTransfer) {
            if (panelElem) {
              document.body.appendChild(panelElem);
            }
          }
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = undefined;
        }
        internalData.selectStatus = false;
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(function () {
          reactData.visiblePanel = true;
        }, 10);
        $xeDateRangePicker.updateZindex();
        return $xeDateRangePicker.updatePlacement();
      }
      return $xeDateRangePicker.$nextTick();
    },
    dateRangePickerOpenEvent: function dateRangePickerOpenEvent(evnt) {
      var $xeDateRangePicker = this;
      var formReadonly = $xeDateRangePicker.computeFormReadonly;
      if (!formReadonly) {
        evnt.preventDefault();
        $xeDateRangePicker.showPanel();
      }
    },
    clickEvent: function clickEvent(evnt) {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.triggerEvent(evnt);
    },
    handleShortcutEvent: function handleShortcutEvent(_ref) {
      var option = _ref.option,
        $event = _ref.$event;
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var type = props.type;
      var shortcutOpts = $xeDateRangePicker.computeShortcutOpts;
      var autoClose = shortcutOpts.autoClose;
      var code = option.code,
        clickMethod = option.clickMethod;
      var startValue = reactData.startValue;
      var endValue = reactData.endValue;
      var value = $xeDateRangePicker.getRangeValue(startValue, endValue);
      var shortcutParams = {
        $dateRangePicker: $xeDateRangePicker,
        option: option,
        value: value,
        startValue: startValue,
        endValue: endValue,
        code: code
      };
      if (!clickMethod && code) {
        var gCommandOpts = _ui.commands.get(code);
        var drpCommandMethod = gCommandOpts ? gCommandOpts.dateRangePickerCommandMethod : null;
        if (drpCommandMethod) {
          drpCommandMethod(shortcutParams);
        } else {
          var dateValueFormat = $xeDateRangePicker.computeDateValueFormat;
          var firstDayOfWeek = $xeDateRangePicker.computeFirstDayOfWeek;
          switch (code) {
            case 'last1':
            case 'last3':
            case 'last7':
            case 'last30':
            case 'last60':
            case 'last90':
            case 'last180':
              {
                var restObj = (0, _util.getRangeDateByCode)(code, value, type, {
                  valueFormat: dateValueFormat,
                  firstDay: firstDayOfWeek
                });
                startValue = restObj.startValue;
                endValue = restObj.endValue;
                value = $xeDateRangePicker.getRangeValue(startValue, endValue);
                shortcutParams.value = value;
                shortcutParams.startValue = startValue;
                shortcutParams.endValue = endValue;
                $xeDateRangePicker.handleChange(startValue, endValue, $event);
                break;
              }
            default:
              (0, _log.errLog)('vxe.error.notCommands', [code]);
              break;
          }
        }
      } else {
        var optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        $xeDateRangePicker.hidePanel();
      }
      $xeDateRangePicker.dispatchEvent('shortcut-click', shortcutParams, $event);
    },
    setModelValue: function setModelValue(startValue, endValue) {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      reactData.startValue = startValue || '';
      reactData.endValue = endValue || '';
      var value = $xeDateRangePicker.getRangeValue(startValue, endValue);
      $xeDateRangePicker.emitModel(value);
    },
    setModelValueByEvent: function setModelValueByEvent(evnt, startValue, endValue) {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.handleChange(startValue || '', endValue || '', evnt);
    },
    focus: function focus() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var inputElem = $xeDateRangePicker.$refs.refInputTarget;
      reactData.isActivated = true;
      inputElem.focus();
      return $xeDateRangePicker.$nextTick();
    },
    blur: function blur() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var inputElem = $xeDateRangePicker.$refs.refInputTarget;
      inputElem.blur();
      reactData.isActivated = false;
      return $xeDateRangePicker.$nextTick();
    },
    select: function select() {
      var $xeDateRangePicker = this;
      var reactData = $xeDateRangePicker.reactData;
      var inputElem = $xeDateRangePicker.$refs.refInputTarget;
      inputElem.select();
      reactData.isActivated = false;
      return $xeDateRangePicker.$nextTick();
    },
    //
    // Render
    //
    renderShortcutBtn: function renderShortcutBtn(h, pos, isVertical) {
      var $xeDateRangePicker = this;
      var shortcutOpts = $xeDateRangePicker.computeShortcutOpts;
      var position = shortcutOpts.position,
        align = shortcutOpts.align,
        mode = shortcutOpts.mode;
      var shortcutList = $xeDateRangePicker.computeShortcutList;
      if ((0, _utils.isEnableConf)(shortcutOpts) && shortcutList.length && (position || 'left') === pos) {
        return h('div', {
          class: "vxe-date-range-picker--layout-".concat(pos, "-wrapper")
        }, [h(_buttonGroup.default, {
          props: {
            options: shortcutList,
            mode: mode,
            align: align,
            vertical: isVertical
          },
          on: {
            click: $xeDateRangePicker.handleShortcutEvent
          }
        })]);
      }
      return (0, _ui.renderEmptyElement)($xeDateRangePicker);
    },
    renderPanel: function renderPanel(h) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var slots = $xeDateRangePicker.$scopedSlots;
      var reactData = $xeDateRangePicker.reactData;
      var type = props.type,
        separator = props.separator,
        autoClose = props.autoClose,
        showConfirmButton = props.showConfirmButton,
        showClearButton = props.showClearButton;
      var initialized = reactData.initialized,
        isAniVisible = reactData.isAniVisible,
        visiblePanel = reactData.visiblePanel,
        panelPlacement = reactData.panelPlacement,
        panelStyle = reactData.panelStyle,
        startValue = reactData.startValue,
        endValue = reactData.endValue;
      var vSize = $xeDateRangePicker.computeSize;
      var btnTransfer = $xeDateRangePicker.computeBtnTransfer;
      var shortcutOpts = $xeDateRangePicker.computeShortcutOpts;
      var isClearable = $xeDateRangePicker.computeIsClearable;
      var panelLabelObj = $xeDateRangePicker.computePanelLabelObj;
      var shortcutList = $xeDateRangePicker.computeShortcutList;
      var isDateTimeType = $xeDateRangePicker.computeIsDateTimeType;
      var startLabel = panelLabelObj.startLabel,
        endLabel = panelLabelObj.endLabel;
      var position = shortcutOpts.position;
      var headerSlot = slots.header;
      var footerSlot = slots.footer;
      var topSlot = slots.top;
      var bottomSlot = slots.bottom;
      var leftSlot = slots.left;
      var rightSlot = slots.right;
      var hasShortcutBtn = shortcutList.length > 0;
      var showConfirmBtn = showConfirmButton === null ? isDateTimeType || !autoClose : showConfirmButton;
      var showClearBtn = showClearButton === null ? isClearable : showClearButton;
      return h('div', {
        ref: 'refInputPanel',
        class: ['vxe-table--ignore-clear vxe-date-range-picker--panel', "type--".concat(type), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--transfer', btnTransfer), 'ani--leave', isAniVisible), 'ani--enter', visiblePanel), 'show--top', !!(topSlot || headerSlot || hasShortcutBtn && (position === 'top' || position === 'header'))), 'show--bottom', !!(bottomSlot || footerSlot || hasShortcutBtn && (position === 'bottom' || position === 'footer'))), 'show--left', !!(leftSlot || hasShortcutBtn && position === 'left')), 'show--right', !!(rightSlot || hasShortcutBtn && position === 'right'))],
        attrs: {
          placement: panelPlacement
        },
        style: panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [h('div', {
        ref: 'refPanelWrapper',
        class: ['vxe-date-range-picker--layout-all-wrapper', "type--".concat(type), _defineProperty({}, "size--".concat(vSize), vSize)]
      }, [topSlot ? h('div', {
        class: 'vxe-date-range-picker--layout-top-wrapper'
      }, topSlot({})) : $xeDateRangePicker.renderShortcutBtn(h, 'top'), h('div', {
        class: 'vxe-date-range-picker--layout-body-layout-wrapper'
      }, [leftSlot ? h('div', {
        class: 'vxe-date-range-picker--layout-left-wrapper'
      }, leftSlot({})) : $xeDateRangePicker.renderShortcutBtn(h, 'left', true), h('div', {
        class: 'vxe-date-range-picker--layout-body-content-wrapper'
      }, [headerSlot ? h('div', {
        class: 'vxe-date-range-picker--layout-header-wrapper'
      }, headerSlot({})) : $xeDateRangePicker.renderShortcutBtn(h, 'header'), h('div', {
        class: 'vxe-date-range-picker--layout-body-wrapper'
      }, [h(_datePanel.default, {
        ref: 'refStartDatePanel',
        props: {
          value: startValue,
          type: props.type,
          className: props.className,
          minDate: props.minDate,
          maxDate: props.maxDate,
          startDay: props.startDay,
          endDate: endValue,
          labelFormat: props.labelFormat,
          valueFormat: props.valueFormat,
          festivalMethod: props.festivalMethod,
          disabledMethod: props.disabledMethod,
          selectDay: props.selectDay
        },
        on: {
          change: $xeDateRangePicker.startPanelChangeEvent
        }
      }), h(_datePanel.default, {
        ref: 'refEndDatePanel',
        props: {
          value: endValue,
          type: props.type,
          className: props.className,
          minDate: props.minDate,
          maxDate: props.maxDate,
          startDay: props.startDay,
          startDate: startValue,
          labelFormat: props.labelFormat,
          valueFormat: props.valueFormat,
          festivalMethod: props.festivalMethod,
          disabledMethod: props.disabledMethod,
          selectDay: props.selectDay
        },
        on: {
          change: $xeDateRangePicker.endPanelChangeEvent
        }
      })]), h('div', {
        class: 'vxe-date-range-picker--layout-footer-wrapper'
      }, [h('div', {
        class: 'vxe-date-range-picker--layout-footer-label'
      }, startLabel || endLabel ? [h('span', startLabel), h('span', "".concat(separator || '')), h('span', endLabel)] : []), h('div', {
        class: 'vxe-date-range-picker--layout-footer-custom'
      }, footerSlot ? footerSlot({}) : [$xeDateRangePicker.renderShortcutBtn(h, 'footer')]), h('div', {
        class: 'vxe-date-range-picker--layout-footer-btns'
      }, [showClearBtn ? h(_button.default, {
        props: {
          size: 'mini',
          disabled: !(startValue || endValue),
          content: (0, _ui.getI18n)('vxe.button.clear')
        },
        on: {
          click: $xeDateRangePicker.clearValueEvent
        }
      }) : (0, _ui.renderEmptyElement)($xeDateRangePicker), showConfirmBtn ? h(_button.default, {
        props: {
          size: 'mini',
          status: 'primary',
          content: (0, _ui.getI18n)('vxe.button.confirm')
        },
        on: {
          click: $xeDateRangePicker.confirmEvent
        }
      }) : (0, _ui.renderEmptyElement)($xeDateRangePicker)])])]), rightSlot ? h('div', {
        class: 'vxe-date-range-picker--layout-right-wrapper'
      }, rightSlot({})) : $xeDateRangePicker.renderShortcutBtn(h, 'right', true)]), bottomSlot ? h('div', {
        class: 'vxe-date-range-picker--layout-bottom-wrapper'
      }, bottomSlot({})) : $xeDateRangePicker.renderShortcutBtn(h, 'bottom')])] : []);
    },
    renderPrefixIcon: function renderPrefixIcon(h) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var slots = $xeDateRangePicker.$scopedSlots;
      var prefixIcon = props.prefixIcon;
      var prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h('div', {
        class: 'vxe-date-range-picker--prefix',
        on: {
          click: $xeDateRangePicker.clickPrefixEvent
        }
      }, [h('div', {
        class: 'vxe-date-range-picker--prefix-icon'
      }, prefixSlot ? (0, _vn.getSlotVNs)(prefixSlot({})) : [h('i', {
        class: prefixIcon
      })])]) : null;
    },
    renderSuffixIcon: function renderSuffixIcon(h) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var slots = $xeDateRangePicker.$scopedSlots;
      var reactData = $xeDateRangePicker.reactData;
      var suffixIcon = props.suffixIcon;
      var startValue = reactData.startValue,
        endValue = reactData.endValue;
      var suffixSlot = slots.suffix;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      var isClearable = $xeDateRangePicker.computeIsClearable;
      return h('div', {
        class: ['vxe-date-range-picker--suffix', {
          'is--clear': isClearable && !isDisabled && (startValue || endValue)
        }]
      }, [isClearable ? h('div', {
        class: 'vxe-date-range-picker--clear-icon',
        on: {
          click: $xeDateRangePicker.clearValueEvent
        }
      }, [h('i', {
        class: (0, _ui.getIcon)().INPUT_CLEAR
      })]) : (0, _ui.renderEmptyElement)($xeDateRangePicker), $xeDateRangePicker.renderExtraSuffixIcon(h), suffixSlot || suffixIcon ? h('div', {
        class: 'vxe-date-range-picker--suffix-icon',
        on: {
          click: $xeDateRangePicker.clickSuffixEvent
        }
      }, suffixSlot ? (0, _vn.getSlotVNs)(suffixSlot({})) : [h('i', {
        class: suffixIcon
      })]) : (0, _ui.renderEmptyElement)($xeDateRangePicker)]);
    },
    renderExtraSuffixIcon: function renderExtraSuffixIcon(h) {
      var $xeDateRangePicker = this;
      return h('div', {
        class: 'vxe-date-range-picker--control-icon',
        on: {
          click: $xeDateRangePicker.dateRangePickerOpenEvent
        }
      }, [h('i', {
        class: ['vxe-date-range-picker--date-picker-icon', (0, _ui.getIcon)().DATE_PICKER_DATE]
      })]);
    },
    renderVN: function renderVN(h) {
      var $xeDateRangePicker = this;
      var props = $xeDateRangePicker;
      var reactData = $xeDateRangePicker.reactData;
      var className = props.className,
        type = props.type,
        name = props.name,
        autoComplete = props.autoComplete;
      var startValue = reactData.startValue,
        endValue = reactData.endValue,
        visiblePanel = reactData.visiblePanel,
        isActivated = reactData.isActivated;
      var vSize = $xeDateRangePicker.computeSize;
      var isDisabled = $xeDateRangePicker.computeIsDisabled;
      var formReadonly = $xeDateRangePicker.computeFormReadonly;
      var inputLabel = $xeDateRangePicker.computeInputLabel;
      if (formReadonly) {
        return h('div', {
          ref: 'refElem',
          class: ['vxe-date-range-picker--readonly', "type--".concat(type), className]
        }, inputLabel);
      }
      var inpPlaceholder = $xeDateRangePicker.computeInpPlaceholder;
      var isClearable = $xeDateRangePicker.computeIsClearable;
      var prefix = $xeDateRangePicker.renderPrefixIcon(h);
      var suffix = $xeDateRangePicker.renderSuffixIcon(h);
      return h('div', {
        ref: 'refElem',
        class: ['vxe-date-range-picker', "type--".concat(type), className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--prefix', !!prefix), 'is--suffix', !!suffix), 'is--visible', visiblePanel), 'is--disabled', isDisabled), 'is--active', isActivated), 'show--clear', isClearable && !isDisabled && (startValue || endValue))],
        attrs: {
          spellcheck: false
        }
      }, [prefix || (0, _ui.renderEmptyElement)($xeDateRangePicker), h('div', {
        class: 'vxe-date-range-picker--wrapper'
      }, [h('input', {
        ref: 'refInputTarget',
        class: 'vxe-date-range-picker--inner',
        domProps: {
          value: inputLabel
        },
        attrs: {
          name: name,
          type: 'text',
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          autocomplete: autoComplete
        },
        on: {
          keydown: $xeDateRangePicker.keydownEvent,
          keyup: $xeDateRangePicker.keyupEvent,
          click: $xeDateRangePicker.clickEvent,
          change: $xeDateRangePicker.changeEvent,
          focus: $xeDateRangePicker.focusEvent,
          blur: $xeDateRangePicker.blurEvent
        }
      })]), suffix || (0, _ui.renderEmptyElement)($xeDateRangePicker),
      // 下拉面板
      $xeDateRangePicker.renderPanel(h)]);
    }
  },
  watch: {
    value: function value() {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.updateModelValue(true);
    },
    computeMVal: function computeMVal() {
      var $xeDateRangePicker = this;
      $xeDateRangePicker.updateModelValue(false);
    }
  },
  created: function created() {
    var $xeDateRangePicker = this;
    $xeDateRangePicker.updateModelValue(true);
    _ui.globalEvents.on($xeDateRangePicker, 'mousewheel', $xeDateRangePicker.handleGlobalMousewheelEvent);
    _ui.globalEvents.on($xeDateRangePicker, 'mousedown', $xeDateRangePicker.handleGlobalMousedownEvent);
    _ui.globalEvents.on($xeDateRangePicker, 'blur', $xeDateRangePicker.handleGlobalBlurEvent);
  },
  deactivated: function deactivated() {
    var $xeDateRangePicker = this;
    $xeDateRangePicker.checkValue();
  },
  beforeDestroy: function beforeDestroy() {
    var $xeDateRangePicker = this;
    var panelElem = $xeDateRangePicker.$refs.refInputPanel;
    if (panelElem && panelElem.parentNode) {
      panelElem.parentNode.removeChild(panelElem);
    }
    $xeDateRangePicker.checkValue();
    _ui.globalEvents.off($xeDateRangePicker, 'mousewheel');
    _ui.globalEvents.off($xeDateRangePicker, 'mousedown');
    _ui.globalEvents.off($xeDateRangePicker, 'blur');
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */