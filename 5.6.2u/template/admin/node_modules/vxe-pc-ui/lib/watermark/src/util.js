"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContentUrl = getContentUrl;
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _dom = require("../../ui/src/dom");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var canvasEl = null;
var fontEl = null;
var fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement('canvas');
    canvasEl.style.position = 'absolute';
    canvasEl.style.top = '0';
    canvasEl.style.left = '0';
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    var parentEl = elem.parentNode;
    if (parentEl) {
      parentEl.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  var fKey = "".concat(fontSize, "_").concat(text);
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement('span');
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = (0, _dom.toCssUnit)(fontSize);
    var width = fontEl.offsetWidth;
    var height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width: width,
      height: height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  var contentWidth = 0;
  var contentHeight = 0;
  contList.forEach(function (item) {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth: contentWidth,
    contentHeight: contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  var gap = opts.gap;
  var _ref = gap ? _xeUtils.default.isArray(gap) ? gap : [gap, gap] : [],
    _ref2 = _slicedToArray(_ref, 2),
    _ref2$ = _ref2[0],
    gapX = _ref2$ === void 0 ? 0 : _ref2$,
    _ref2$2 = _ref2[1],
    gapY = _ref2$2 === void 0 ? 0 : _ref2$2;
  var canvasWidth = contentWidth + _xeUtils.default.toNumber(gapX);
  var canvasHeight = contentWidth + _xeUtils.default.toNumber(gapY);
  return {
    canvasWidth: canvasWidth,
    canvasHeight: canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : '') || (opts.font ? opts.font[key] : '');
}
function createMarkFont(contConf, defaultFontSize, opts) {
  var offset = opts.offset;
  var text = _xeUtils.default.toValueString(contConf.textContent);
  var fontSize = _xeUtils.default.toNumber(getFontConf(contConf, 'fontSize', opts) || defaultFontSize) || 14;
  var _ref3 = offset ? _xeUtils.default.isArray(offset) ? offset : [offset, offset] : [],
    _ref4 = _slicedToArray(_ref3, 2),
    _ref4$ = _ref4[0],
    offsetX = _ref4$ === void 0 ? 0 : _ref4$,
    _ref4$2 = _ref4[1],
    offsetY = _ref4$2 === void 0 ? 0 : _ref4$2;
  var _calcFontWH = calcFontWH(text, fontSize),
    width = _calcFontWH.width,
    height = _calcFontWH.height;
  return {
    text: text,
    fontSize: fontSize,
    font: contConf.font,
    width: width + _xeUtils.default.toNumber(offsetX),
    height: height + _xeUtils.default.toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  var fontWeight = getFontConf(item, 'fontWeight', opts);
  ctx.fillStyle = "".concat(getFontConf(item, 'color', opts) || 'rgba(0, 0, 0, 0.15)');
  ctx.font = [getFontConf(item, 'fontStyle', opts) || 'normal', fontWeight === 'bold' || fontWeight === 'bolder' ? 'bold' : '', (0, _dom.toCssUnit)(item.fontSize), getFontConf(item, 'fontFamily', opts) || 'sans-serif'].join(' ');
}
function getContentUrl(content, defaultFontSize, options) {
  var opts = Object.assign({}, options);
  var rotate = opts.rotate;
  var deg = _xeUtils.default.toNumber(rotate);
  var contList = (_xeUtils.default.isArray(content) ? content : [content]).map(function (item) {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: "".concat(item)
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ''
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise(function (resolve) {
    var canvasEl = getMarkCanvas();
    if (!canvasEl.parentNode) {
      document.body.append(canvasEl);
    }
    var ctx = canvasEl.getContext('2d');
    if (ctx && contList.length) {
      var _calcContentWH = calcContentWH(contList),
        contentWidth = _calcContentWH.contentWidth,
        contentHeight = _calcContentWH.contentHeight;
      var _calcCanvasWH = calcCanvasWH(contentWidth, opts),
        canvasWidth = _calcCanvasWH.canvasWidth,
        canvasHeight = _calcCanvasWH.canvasHeight;
      canvasEl.width = canvasWidth;
      canvasEl.height = canvasHeight;
      var x = (canvasWidth - contentWidth) / 2;
      var y = (canvasHeight - contentHeight) / 2;
      var drayX = x + contentWidth / 2;
      var drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      var offsetHeight = 0;
      contList.forEach(function (item) {
        var align = getFontConf(item, 'align', opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === 'center' ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl.toDataURL());
      removeMarkElement(canvasEl);
    } else {
      resolve('');
      removeMarkElement(canvasEl);
    }
  });
}