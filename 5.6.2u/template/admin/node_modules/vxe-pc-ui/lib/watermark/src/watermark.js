"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _dom = require("../../ui/src/dom");
var _util = require("./util");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeWatermark',
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: function _default() {
        return (0, _ui.getConfig)().watermark.rotate;
      }
    },
    gap: {
      type: [Array, Number, String],
      default: function _default() {
        return _xeUtils.default.clone((0, _ui.getConfig)().watermark.gap, true);
      }
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      markUrl: ''
    };
    return {
      xID: xID,
      reactData: reactData
    };
  },
  computed: {
    computeFontOpts: function computeFontOpts() {
      var $xeWatermark = this;
      var props = $xeWatermark;
      return _xeUtils.default.assign({}, _xeUtils.default.clone((0, _ui.getConfig)().watermark.font, true), props.font);
    },
    computeWrapperStyle: function computeWrapperStyle() {
      var $xeWatermark = this;
      var props = $xeWatermark;
      var reactData = $xeWatermark.reactData;
      var width = props.width,
        height = props.height,
        zIndex = props.zIndex;
      var markUrl = reactData.markUrl;
      var stys = {};
      if (width) {
        stys.width = (0, _dom.toCssUnit)(width);
      }
      if (height) {
        stys.height = (0, _dom.toCssUnit)(height);
      }
      if (markUrl) {
        stys.backgroundImage = "url(".concat(markUrl, ")");
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    }
  },
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeWatermark = this;
      $xeWatermark.$emit(type, (0, _ui.createEvent)(evnt, {
        $watermark: $xeWatermark
      }, params));
    },
    updateMarkStyle: function updateMarkStyle() {
      var $xeWatermark = this;
      var props = $xeWatermark;
      var reactData = $xeWatermark.reactData;
      var content = props.content,
        gap = props.gap,
        rotate = props.rotate,
        offset = props.offset;
      var el = $xeWatermark.$refs.refElem;
      var fontOpts = $xeWatermark.computeFontOpts;
      if (el) {
        if (content) {
          (0, _util.getContentUrl)(content, getComputedStyle(el).fontSize, {
            font: fontOpts,
            rotate: rotate,
            gap: gap,
            offset: offset
          }).then(function (url) {
            reactData.markUrl = url;
          });
        }
      }
    },
    //
    // Render
    //
    renderVN: function renderVN(h) {
      var $xeWatermark = this;
      var wrapperStyle = $xeWatermark.computeWrapperStyle;
      return h('div', {
        ref: 'refElem',
        class: 'vxe-watermark',
        style: wrapperStyle
      });
    }
  },
  watch: {
    imageUrl: function imageUrl() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    content: function content() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    gap: function gap() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    rotate: function rotate() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    width: function width() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    height: function height() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    },
    font: function font() {
      var $xeWatermark = this;
      $xeWatermark.updateMarkStyle();
    }
  },
  mounted: function mounted() {
    var $xeWatermark = this;
    $xeWatermark.updateMarkStyle();
    _ui.globalEvents.on($xeWatermark, 'resize', _xeUtils.default.throttle(function () {
      $xeWatermark.updateMarkStyle();
    }, 300, {
      trailing: true,
      leading: true
    }));
  },
  beforeDestroy: function beforeDestroy() {
    var $xeWatermark = this;
    _ui.globalEvents.off($xeWatermark, 'resize');
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */