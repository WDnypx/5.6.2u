"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _vn = require("../../ui/src/vn");
var _text = _interopRequireDefault(require("../../text/src/text"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeCountdown',
  mixins: [_ui.globalMixins.sizeMixin],
  props: {
    value: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().countdown.size || (0, _ui.getConfig)().size;
      }
    }
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      currNum: 0,
      secondNum: 0
    };
    var internalData = {
      dnTimeout: undefined
    };
    return {
      xID: xID,
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeTimeFormats: function computeTimeFormats() {
      var $xeCountdown = this;
      var reactData = $xeCountdown.reactData;
      var secondNum = reactData.secondNum;
      if (secondNum >= 31622400000) {
        return ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 2678400000) {
        return ['MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 86400000) {
        return ['dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 3600000) {
        return ['HH', 'mm', 'ss'];
      }
      if (secondNum >= 60000) {
        return ['mm', 'ss'];
      }
      return ['ss'];
    },
    computeDiffConf: function computeDiffConf() {
      var $xeCountdown = this;
      var reactData = $xeCountdown.reactData;
      var currNum = reactData.currNum;
      return _xeUtils.default.getDateDiff(Date.now(), Date.now() + currNum);
    },
    computeFormatLabel: function computeFormatLabel() {
      var $xeCountdown = this;
      var props = $xeCountdown;
      var format = props.format;
      var diffConf = $xeCountdown.computeDiffConf;
      var rest = '';
      if (format) {
        rest = "".concat(format);
        _xeUtils.default.each(diffConf, function (val, key) {
          rest = rest.replace(new RegExp(key, 'g'), _xeUtils.default.padStart(val, key.length, '0'));
        });
        return rest;
      }
      return rest;
    },
    computePrefixOpts: function computePrefixOpts() {
      var $xeCountdown = this;
      var props = $xeCountdown;
      return Object.assign({}, props.prefixConfig, (0, _ui.getConfig)().countdown.prefixConfig);
    },
    computeSuffixOpts: function computeSuffixOpts() {
      var $xeCountdown = this;
      var props = $xeCountdown;
      return Object.assign({}, props.suffixConfig, (0, _ui.getConfig)().countdown.suffixConfig);
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeCountdown = this;
      $xeCountdown.$emit(type, (0, _ui.createEvent)(evnt, {
        $carousel: $xeCountdown
      }, params));
    },
    updateCount: function updateCount() {
      var $xeCountdown = this;
      var props = $xeCountdown;
      var reactData = $xeCountdown.reactData;
      var secondNum = _xeUtils.default.toNumber(props.value || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    },
    handleTime: function handleTime() {
      var $xeCountdown = this;
      var reactData = $xeCountdown.reactData;
      var internalData = $xeCountdown.internalData;
      var currNum = reactData.currNum;
      if (currNum > 1000) {
        reactData.currNum -= 1000;
        internalData.dnTimeout = setTimeout(function () {
          $xeCountdown.handleTime();
        }, 1000);
      } else {
        reactData.currNum = 0;
        $xeCountdown.handleStop();
      }
    },
    handleStart: function handleStart() {
      var $xeCountdown = this;
      $xeCountdown.dispatchEvent('start', {}, null);
      $xeCountdown.handleTime();
    },
    handleStop: function handleStop() {
      var $xeCountdown = this;
      var internalData = $xeCountdown.internalData;
      var dnTimeout = internalData.dnTimeout;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
        $xeCountdown.dispatchEvent('end', {}, null);
      }
    },
    //
    // Render
    //
    renderDefaultContentVNs: function renderDefaultContentVNs(h) {
      var $xeCountdown = this;
      var props = $xeCountdown;
      var format = props.format;
      var timeFormats = $xeCountdown.computeTimeFormats;
      var diffConf = $xeCountdown.computeDiffConf;
      var formatLabel = $xeCountdown.computeFormatLabel;
      if (format) {
        return [h('div', {
          key: 'format',
          class: 'vxe-countdown--content-format'
        }, formatLabel)];
      }
      return timeFormats.map(function (key, index) {
        return h('div', {
          key: index,
          class: 'vxe-countdown--content-item'
        }, [h('div', {
          class: 'vxe-countdown--content-num'
        }, "".concat(diffConf[key] || 0)), h('div', {
          class: 'vxe-countdown--content-unit'
        }, (0, _ui.getI18n)("vxe.countdown.formats.".concat(key)))]);
      });
    },
    renderVN: function renderVN(h) {
      var $xeCountdown = this;
      var props = $xeCountdown;
      var slots = $xeCountdown.$scopedSlots;
      var reactData = $xeCountdown.reactData;
      var prefixConfig = props.prefixConfig,
        suffixConfig = props.suffixConfig;
      var currNum = reactData.currNum;
      var vSize = $xeCountdown.computeSize;
      var diffConf = $xeCountdown.computeDiffConf;
      var prefixOpts = $xeCountdown.computePrefixOpts;
      var suffixOpts = $xeCountdown.computeSuffixOpts;
      var prefixSlot = slots.prefix;
      var suffixSlot = slots.suffix;
      var defaultSlot = slots.default;
      return h('div', {
        ref: 'refElem',
        class: ['vxe-countdown', diffConf.done ? 'is--progress' : 'is-end', _defineProperty({}, "size--".concat(vSize), vSize)]
      }, [prefixSlot || prefixConfig ? h('div', {
        class: 'vxe-countdown--prefix'
      }, prefixSlot ? (0, _vn.getSlotVNs)(prefixSlot({
        currentValue: currNum,
        diffConf: diffConf
      })) : [h(_text.default, {
        props: {
          content: prefixOpts.content,
          icon: prefixOpts.icon,
          status: prefixOpts.status
        }
      })]) : (0, _ui.renderEmptyElement)($xeCountdown), h('div', {
        class: 'vxe-countdown--content'
      }, defaultSlot ? (0, _vn.getSlotVNs)(defaultSlot({
        currentValue: currNum,
        diffConf: diffConf
      })) : $xeCountdown.renderDefaultContentVNs(h)), suffixSlot || suffixConfig ? h('div', {
        class: 'vxe-countdown--suffix'
      }, suffixSlot ? (0, _vn.getSlotVNs)(suffixSlot({
        currentValue: currNum,
        diffConf: diffConf
      })) : [h(_text.default, {
        props: {
          content: suffixOpts.content,
          icon: suffixOpts.icon,
          status: suffixOpts.status
        }
      })]) : (0, _ui.renderEmptyElement)($xeCountdown)]);
    }
  },
  watch: {
    value: function value() {
      var $xeCountdown = this;
      $xeCountdown.updateCount();
      $xeCountdown.handleStop();
      $xeCountdown.handleStart();
    }
  },
  created: function created() {
    var $xeCountdown = this;
    $xeCountdown.updateCount();
  },
  mounted: function mounted() {
    var $xeCountdown = this;
    $xeCountdown.handleStart();
  },
  beforeDestroy: function beforeDestroy() {
    var $xeCountdown = this;
    $xeCountdown.handleStop();
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */