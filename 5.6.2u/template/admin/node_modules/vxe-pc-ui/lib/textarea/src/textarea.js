"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _utils = require("../../ui/src/utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var autoTxtElem;
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeTextarea',
  model: {
    prop: 'value',
    event: 'modelValue'
  },
  mixins: [_ui.globalMixins.sizeMixin],
  props: {
    value: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().textarea.resize;
      }
    },
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().textarea.size || (0, _ui.getConfig)().size;
      }
    },
    // 已废弃
    maxlength: [String, Number]
  },
  inject: {
    $xeForm: {
      default: null
    },
    formItemInfo: {
      from: 'xeFormItemInfo',
      default: null
    }
  },
  data: function data() {
    var reactData = {
      inputValue: ''
    };
    return {
      xID: _xeUtils.default.uniqueId(),
      reactData: reactData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeFormReadonly: function computeFormReadonly() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var $xeForm = $xeTextarea.$xeForm;
      var readonly = props.readonly;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.readonly;
        }
        return false;
      }
      return readonly;
    },
    computeIsDisabled: function computeIsDisabled() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var $xeForm = $xeTextarea.$xeForm;
      var disabled = props.disabled;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.disabled;
        }
        return false;
      }
      return disabled;
    },
    computeInputReadonly: function computeInputReadonly() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var editable = props.editable;
      var formReadonly = $xeTextarea.computeFormReadonly;
      return formReadonly || !editable;
    },
    computeInpPlaceholder: function computeInpPlaceholder() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var placeholder = props.placeholder;
      if (placeholder) {
        return (0, _utils.getFuncText)(placeholder);
      }
      var globalPlaceholder = (0, _ui.getConfig)().textarea.placeholder;
      if (globalPlaceholder) {
        return (0, _utils.getFuncText)(globalPlaceholder);
      }
      return (0, _ui.getI18n)('vxe.base.pleaseInput');
    },
    computeInpMaxLength: function computeInpMaxLength() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var maxLength = props.maxLength,
        maxlength = props.maxlength;
      return maxLength || maxlength;
    },
    computeInputCount: function computeInputCount() {
      var $xeTextarea = this;
      var reactData = $xeTextarea.reactData;
      return _xeUtils.default.getSize(reactData.inputValue);
    },
    computeIsCountError: function computeIsCountError() {
      var $xeTextarea = this;
      var inputCount = $xeTextarea.computeInputCount;
      var inpMaxLength = $xeTextarea.computeInpMaxLength;
      return inpMaxLength && inputCount > _xeUtils.default.toNumber(inpMaxLength);
    },
    computeSizeOpts: function computeSizeOpts() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      return Object.assign({
        minRows: 1,
        maxRows: 10
      }, (0, _ui.getConfig)().textarea.autosize, props.autosize);
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeTextarea = this;
      $xeTextarea.$emit(type, (0, _ui.createEvent)(evnt, {
        $textarea: $xeTextarea
      }, params));
    },
    emitModel: function emitModel(value) {
      var $xeTextarea = this;
      var _events = $xeTextarea._events;
      if (_events && _events.modelValue) {
        $xeTextarea.$emit('modelValue', value);
      } else {
        $xeTextarea.$emit('model-value', value);
      }
    },
    focus: function focus() {
      var $xeTextarea = this;
      var textElem = $xeTextarea.$refs.refTextarea;
      textElem.focus();
      return $xeTextarea.$nextTick();
    },
    blur: function blur() {
      var $xeTextarea = this;
      var textElem = $xeTextarea.$refs.refTextarea;
      textElem.blur();
      return $xeTextarea.$nextTick();
    },
    updateAutoTxt: function updateAutoTxt() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var size = props.size,
        autosize = props.autosize;
      var inputValue = reactData.inputValue;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement('div');
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        var textElem = $xeTextarea.$refs.refTextarea;
        if (!textElem) {
          return;
        }
        var textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ['vxe-textarea--autosize', size ? "size--".concat(size) : ''].join(' ');
        autoTxtElem.style.width = "".concat(textElem.clientWidth, "px");
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ('' + (inputValue || '　')).replace(/\n$/, '\n　');
      }
    },
    handleResize: function handleResize() {
      var $xeTextarea = this;
      var props = $xeTextarea;
      if (props.autosize) {
        $xeTextarea.$nextTick(function () {
          var sizeOpts = $xeTextarea.computeSizeOpts;
          var minRows = sizeOpts.minRows,
            maxRows = sizeOpts.maxRows;
          var textElem = $xeTextarea.$refs.refTextarea;
          if (!textElem) {
            return;
          }
          var sizeHeight = autoTxtElem.clientHeight;
          var textStyle = getComputedStyle(textElem);
          var lineHeight = _xeUtils.default.toNumber(textStyle.lineHeight);
          var paddingTop = _xeUtils.default.toNumber(textStyle.paddingTop);
          var paddingBottom = _xeUtils.default.toNumber(textStyle.paddingBottom);
          var borderTopWidth = _xeUtils.default.toNumber(textStyle.borderTopWidth);
          var borderBottomWidth = _xeUtils.default.toNumber(textStyle.borderBottomWidth);
          var intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          var rowNum = (sizeHeight - intervalHeight) / lineHeight;
          var textRows = rowNum && /[0-9]/.test('' + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          var vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = "".concat(vaildRows * lineHeight + intervalHeight, "px");
        });
      }
    },
    triggerEvent: function triggerEvent(evnt) {
      var $xeTextarea = this;
      var reactData = $xeTextarea.reactData;
      var value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, {
        value: value
      }, evnt);
    },
    handleChange: function handleChange(value, evnt) {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var $xeForm = $xeTextarea.$xeForm;
      var formItemInfo = $xeTextarea.formItemInfo;
      reactData.inputValue = value;
      $xeTextarea.emitModel(value);
      if (_xeUtils.default.toValueString(props.value) !== value) {
        $xeTextarea.dispatchEvent('change', {
          value: value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    },
    inputEvent: function inputEvent(evnt) {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var immediate = props.immediate;
      var textElem = evnt.target;
      var value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        $xeTextarea.handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent('input', {
        value: value
      }, evnt);
      $xeTextarea.handleResize();
    },
    changeEvent: function changeEvent(evnt) {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var immediate = props.immediate;
      if (immediate) {
        $xeTextarea.triggerEvent(evnt);
      } else {
        $xeTextarea.handleChange(reactData.inputValue, evnt);
      }
    },
    blurEvent: function blurEvent(evnt) {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var immediate = props.immediate;
      var inputValue = reactData.inputValue;
      if (!immediate) {
        $xeTextarea.handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    },
    //
    // Render
    //
    renderVN: function renderVN(h) {
      var $xeTextarea = this;
      var props = $xeTextarea;
      var reactData = $xeTextarea.reactData;
      var className = props.className,
        resize = props.resize,
        autosize = props.autosize,
        showWordCount = props.showWordCount,
        countMethod = props.countMethod,
        rows = props.rows,
        cols = props.cols;
      var inputValue = reactData.inputValue;
      var vSize = $xeTextarea.computeSize;
      var isDisabled = $xeTextarea.computeIsDisabled;
      var isCountError = $xeTextarea.computeIsCountError;
      var inputCount = $xeTextarea.computeInputCount;
      var inputReadonly = $xeTextarea.computeInputReadonly;
      var formReadonly = $xeTextarea.computeFormReadonly;
      var inpPlaceholder = $xeTextarea.computeInpPlaceholder;
      var inpMaxLength = $xeTextarea.computeInpMaxLength;
      if (formReadonly) {
        return h('div', {
          ref: 'refElem',
          class: ['vxe-textarea--readonly', className]
        }, inputValue);
      }
      return h('div', {
        ref: 'refElem',
        class: ['vxe-textarea', className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--autosize', autosize), 'is--count', showWordCount), 'is--disabled', isDisabled), 'is--rows', !_xeUtils.default.eqNull(rows)), 'is--cols', !_xeUtils.default.eqNull(cols))],
        attrs: {
          spellcheck: false
        }
      }, [h('textarea', {
        ref: 'refTextarea',
        class: 'vxe-textarea--inner',
        domProps: {
          value: inputValue
        },
        attrs: {
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows: rows,
          cols: cols
        },
        style: resize ? {
          resize: resize
        } : {},
        on: {
          input: $xeTextarea.inputEvent,
          change: $xeTextarea.changeEvent,
          keydown: $xeTextarea.triggerEvent,
          keyup: $xeTextarea.triggerEvent,
          click: $xeTextarea.triggerEvent,
          focus: $xeTextarea.triggerEvent,
          blur: $xeTextarea.blurEvent
        }
      }), showWordCount ? h('span', {
        class: ['vxe-textarea--count', {
          'is--error': isCountError
        }]
      }, countMethod ? "".concat(countMethod({
        value: inputValue
      })) : "".concat(inputCount).concat(inpMaxLength ? "/".concat(inpMaxLength) : '')) : null]);
    }
  },
  watch: {
    value: function value(val) {
      var $xeTextarea = this;
      var reactData = $xeTextarea.reactData;
      reactData.inputValue = val;
      $xeTextarea.updateAutoTxt();
    },
    computeSizeOpts: function computeSizeOpts() {
      var $xeTextarea = this;
      $xeTextarea.updateAutoTxt();
      $xeTextarea.handleResize();
    }
  },
  created: function created() {
    var $xeTextarea = this;
    var props = $xeTextarea;
    var reactData = $xeTextarea.reactData;
    reactData.inputValue = props.value;
    $xeTextarea.$nextTick(function () {
      var autosize = props.autosize;
      if (autosize) {
        $xeTextarea.updateAutoTxt();
        $xeTextarea.handleResize();
      }
    });
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */