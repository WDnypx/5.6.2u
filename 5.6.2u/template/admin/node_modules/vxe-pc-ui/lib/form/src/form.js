"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _utils = require("../../ui/src/utils");
var _dom = require("../../ui/src/dom");
var _util = require("./util");
var _tooltip = _interopRequireDefault(require("../../tooltip/src/tooltip"));
var _formConfigItem = _interopRequireDefault(require("./form-config-item"));
var _loading = _interopRequireDefault(require("../../loading/src/loading"));
var _vn = require("../../ui/src/vn");
var _log = require("../../ui/src/log");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Rule = /*#__PURE__*/function () {
  function Rule(rule) {
    _classCallCheck(this, Rule);
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  return _createClass(Rule, [{
    key: "content",
    get: function get() {
      return (0, _utils.getFuncText)(this.$options.content || this.$options.message);
    }
  }, {
    key: "message",
    get: function get() {
      return this.content;
    }
  }]);
}(); // 如果存在 pattern，判断正则
function validREValue(pattern, val) {
  if (pattern && !(_xeUtils.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
// 如果存在 max，判断最大值
function validMaxValue(max, num) {
  if (!_xeUtils.default.eqNull(max) && num > _xeUtils.default.toNumber(max)) {
    return false;
  }
  return true;
}
// 如果存在 min，判断最小值
function validMinValue(min, num) {
  if (!_xeUtils.default.eqNull(min) && num < _xeUtils.default.toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  var type = rule.type,
    min = rule.min,
    max = rule.max,
    pattern = rule.pattern;
  var isArrType = type === 'array';
  var isNumType = type === 'number';
  var isStrType = type === 'string';
  var strVal = "".concat(val);
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!_xeUtils.default.isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    var numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!_xeUtils.default.isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  var required = rule.required;
  var isEmptyVal = _xeUtils.default.isArray(val) ? !val.length : (0, _utils.eqEmptyValue)(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeForm',
  mixins: [_ui.globalMixins.sizeMixin],
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().form.size || (0, _ui.getConfig)().size;
      }
    },
    span: {
      type: [String, Number],
      default: function _default() {
        return (0, _ui.getConfig)().form.span;
      }
    },
    align: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().form.align;
      }
    },
    verticalAlign: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().form.verticalAlign;
      }
    },
    border: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.border;
      }
    },
    titleBackground: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.titleBackground;
      }
    },
    titleBold: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.titleBold;
      }
    },
    titleAlign: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().form.titleAlign;
      }
    },
    titleWidth: {
      type: [String, Number],
      default: function _default() {
        return (0, _ui.getConfig)().form.titleWidth;
      }
    },
    titleColon: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.titleColon;
      }
    },
    titleAsterisk: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.titleAsterisk;
      }
    },
    titleOverflow: {
      type: [Boolean, String],
      default: function _default() {
        return (0, _ui.getConfig)().form.titleOverflow;
      }
    },
    vertical: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.vertical;
      }
    },
    padding: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.padding;
      }
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.preventSubmit;
      }
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().form.customLayout;
      }
    }
  },
  inject: {
    $xeGrid: {
      default: null
    }
  },
  provide: function provide() {
    var $xeForm = this;
    return {
      $xeForm: $xeForm,
      xeFormItemInfo: null,
      $xeFormGroup: null,
      $xeFormItem: null
    };
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      collapseAll: false,
      staticItems: [],
      formItems: []
    };
    var internalData = {
      meTimeout: undefined,
      stTimeout: undefined,
      tooltipStore: {
        item: null,
        visible: false
      },
      itemFormatCache: {}
    };
    return {
      xID: xID,
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeValidOpts: function computeValidOpts() {
      var $xeForm = this;
      var props = $xeForm;
      return Object.assign({}, (0, _ui.getConfig)().form.validConfig, props.validConfig);
    },
    computeTooltipOpts: function computeTooltipOpts() {
      var $xeForm = this;
      var props = $xeForm;
      return Object.assign({}, (0, _ui.getConfig)().tooltip, (0, _ui.getConfig)().form.tooltipConfig, props.tooltipConfig);
    },
    computeCollapseOpts: function computeCollapseOpts() {
      var $xeForm = this;
      var props = $xeForm;
      return Object.assign({}, (0, _ui.getConfig)().form.collapseConfig, props.collapseConfig);
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeForm = this;
      $xeForm.$emit(type, (0, _ui.createEvent)(evnt, {
        $form: $xeForm
      }, params));
    },
    callSlot: function callSlot(slotFunc, params, h) {
      var $xeForm = this;
      var slots = $xeForm.$scopedSlots;
      if (slotFunc) {
        if (_xeUtils.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (_xeUtils.default.isFunction(slotFunc)) {
          return (0, _vn.getSlotVNs)(slotFunc.call($xeForm, params, h));
        }
      }
      return [];
    },
    loadItem: function loadItem(list) {
      var $xeForm = this;
      var slots = $xeForm.$scopedSlots;
      var reactData = $xeForm.reactData;
      var internalData = $xeForm.internalData;
      if (list.length) {
        list.forEach(function (item) {
          if (item.slots) {
            _xeUtils.default.each(item.slots, function (func) {
              if (!_xeUtils.default.isFunction(func)) {
                if (!slots[func]) {
                  (0, _log.errLog)('vxe.error.notSlot', [func]);
                }
              }
            });
          }
        });
      }
      reactData.staticItems = _xeUtils.default.mapTree(list, function (item) {
        return (0, _util.createItem)($xeForm, item);
      }, {
        children: 'children'
      });
      internalData.itemFormatCache = {};
      return $xeForm.$nextTick();
    },
    getItems: function getItems() {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      var itemList = [];
      _xeUtils.default.eachTree(reactData.formItems, function (item) {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return itemList;
    },
    getItemByField: function getItemByField(field) {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      var rest = _xeUtils.default.findTree(reactData.formItems, function (item) {
        return item.field === field;
      }, {
        children: 'children'
      });
      return rest ? rest.item : null;
    },
    getCollapseStatus: function getCollapseStatus() {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      return reactData.collapseAll;
    },
    toggleCollapse: function toggleCollapse() {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      var status = !$xeForm.getCollapseStatus();
      reactData.collapseAll = status;
      $xeForm.$emit('update:collapseStatus', status);
      return $xeForm.$nextTick();
    },
    toggleCollapseEvent: function toggleCollapseEvent(evnt) {
      var $xeForm = this;
      var props = $xeForm;
      var $xeGrid = $xeForm.$xeGrid;
      $xeForm.toggleCollapse();
      var status = $xeForm.getCollapseStatus();
      $xeForm.dispatchEvent('toggle-collapse', {
        status: status,
        collapse: status,
        data: props.data
      }, evnt);
      $xeForm.dispatchEvent('collapse', {
        status: status,
        collapse: status,
        data: props.data
      }, evnt);
      $xeForm.$nextTick(function () {
        if ($xeGrid) {
          $xeGrid.recalculate();
        }
      });
    },
    clearValidate: function clearValidate(fieldOrItem) {
      var $xeForm = this;
      if (fieldOrItem) {
        var fields = fieldOrItem;
        if (!_xeUtils.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach(function (field) {
          if (field) {
            var item = (0, _util.handleFieldOrItem)($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        $xeForm.getItems().forEach(function (item) {
          item.showError = false;
        });
      }
      return $xeForm.$nextTick();
    },
    getResetValue: function getResetValue(item, data, itemValue) {
      var $xeForm = this;
      var $xeGrid = $xeForm.$xeGrid;
      var field = item.field,
        resetValue = item.resetValue;
      if (_xeUtils.default.isFunction(resetValue)) {
        return resetValue({
          field: field,
          item: item,
          data: data,
          $form: $xeForm,
          $grid: $xeGrid
        });
      } else if (resetValue === null) {
        // 默认
        if (_xeUtils.default.isArray(itemValue)) {
          return [];
        }
      }
      return resetValue;
    },
    reset: function reset() {
      var $xeForm = this;
      var props = $xeForm;
      var $xeGrid = $xeForm.$xeGrid;
      var internalData = $xeForm.internalData;
      var data = props.data;
      var itemList = $xeForm.getItems();
      if (data) {
        itemList.forEach(function (item) {
          var field = item.field,
            itemRender = item.itemRender;
          if ((0, _utils.isEnableConf)(itemRender)) {
            var name = itemRender.name,
              startField = itemRender.startField,
              endField = itemRender.endField;
            var compConf = _ui.renderer.get(name);
            var fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({
                data: data,
                field: field,
                property: field,
                item: item,
                $form: $xeForm,
                $grid: $xeGrid
              });
            } else if (field) {
              var itemValue = _xeUtils.default.get(data, field);
              _xeUtils.default.set(data, field, $xeForm.getResetValue(item, data, itemValue));
            }
            if (startField && endField) {
              _xeUtils.default.set(data, startField, $xeForm.getResetValue(item, data, _xeUtils.default.get(data, startField)));
              _xeUtils.default.set(data, endField, $xeForm.getResetValue(item, data, _xeUtils.default.get(data, endField)));
            }
          }
        });
      }
      internalData.itemFormatCache = {};
      return $xeForm.clearValidate();
    },
    resetEvent: function resetEvent(evnt) {
      var $xeForm = this;
      var props = $xeForm;
      evnt.preventDefault();
      $xeForm.reset();
      $xeForm.dispatchEvent('reset', {
        data: props.data
      }, evnt);
    },
    handleFocus: function handleFocus(fields) {
      var $xeForm = this;
      var props = $xeForm;
      var $xeGrid = $xeForm.$xeGrid;
      var el = $xeForm.$refs.refElem;
      if (el) {
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var item = $xeForm.getItemByField(field);
          if (item && (0, _utils.isEnableConf)(item.itemRender)) {
            var itemRender = item.itemRender;
            var compConf = _ui.renderer.get(itemRender.name);
            // 定位到第一个
            if (!i) {
              (0, _dom.scrollToView)(el.querySelector(".".concat(item.id)));
            }
            var inputElem = null;
            var autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            // 如果指定了聚焦 class
            if (_xeUtils.default.isFunction(autoFocus)) {
              inputElem = autoFocus({
                $form: $xeForm,
                $grid: $xeGrid,
                item: item,
                data: props.data,
                field: field
              });
            } else {
              if (autoFocus === true) {
                // 自动匹配模式，会自动匹配第一个可输入元素
                inputElem = el.querySelector(".".concat(item.id, " input,textarea"));
              } else if (autoFocus) {
                inputElem = el.querySelector(".".concat(item.id, " ").concat(autoFocus));
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    },
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>
     * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise
     *  trigger=change 触发方式
     */
    validItemRules: function validItemRules(validType, fields, val) {
      var $xeForm = this;
      var props = $xeForm;
      var data = props.data,
        formRules = props.rules;
      var errorMaps = {};
      if (!_xeUtils.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map(function (property) {
        var errorRules = [];
        var syncVailds = [];
        if (property && formRules) {
          var rules = _xeUtils.default.get(formRules, property);
          if (rules) {
            var itemValue = _xeUtils.default.isUndefined(val) ? _xeUtils.default.get(data, property) : val;
            rules.forEach(function (rule) {
              var trigger = rule.trigger,
                validator = rule.validator;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  var validParams = {
                    itemValue: itemValue,
                    rule: rule,
                    rules: rules,
                    data: data,
                    field: property,
                    property: property,
                    $form: $xeForm
                  };
                  var customValid;
                  if (_xeUtils.default.isString(validator)) {
                    var gvItem = _ui.validators.get(validator);
                    if (gvItem) {
                      var validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        (0, _log.warnLog)('vxe.error.notValidators', [validator]);
                      }
                    } else {
                      (0, _log.errLog)('vxe.error.notValidators', [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (_xeUtils.default.isError(customValid)) {
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger: trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncVailds.push(customValid.catch(function (e) {
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger: trigger,
                          content: e ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(function () {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map(function (rule) {
              return {
                $form: $xeForm,
                rule: rule,
                data: data,
                field: property,
                property: property
              };
            });
          }
        });
      })).then(function () {
        if (!_xeUtils.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    },
    beginValidate: function beginValidate(itemList, type, callback) {
      var $xeForm = this;
      var props = $xeForm;
      var internalData = $xeForm.internalData;
      var data = props.data,
        formRules = props.rules;
      var validOpts = $xeForm.computeValidOpts;
      var validRest = {};
      var validFields = [];
      var itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach(function (item) {
          var field = item.field;
          if (field && !(0, _util.isHiddenItem)($xeForm, item) && (0, _util.isActiveItem)($xeForm, item)) {
            itemValids.push($xeForm.validItemRules(type || 'all', field).then(function () {
              item.errRule = null;
            }).catch(function (errorMaps) {
              var rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(function () {
          if (callback) {
            callback();
          }
        }).catch(function () {
          return new Promise(function (resolve) {
            internalData.meTimeout = setTimeout(function () {
              itemList.forEach(function (item) {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              $xeForm.$nextTick(function () {
                $xeForm.handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    },
    validate: function validate(callback) {
      var $xeForm = this;
      var props = $xeForm;
      var readonly = props.readonly;
      $xeForm.clearValidate();
      if (readonly) {
        return $xeForm.$nextTick();
      }
      return $xeForm.beginValidate($xeForm.getItems(), '', callback);
    },
    validateField: function validateField(fieldOrItem, callback) {
      var $xeForm = this;
      var props = $xeForm;
      var readonly = props.readonly;
      if (readonly) {
        return $xeForm.$nextTick();
      }
      var fields = [];
      if (fieldOrItem) {
        if (_xeUtils.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return $xeForm.beginValidate(fields.map(function (field) {
        return (0, _util.handleFieldOrItem)($xeForm, field);
      }), '', callback);
    },
    submitEvent: function submitEvent(evnt) {
      var $xeForm = this;
      var props = $xeForm;
      var readonly = props.readonly;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        $xeForm.clearValidate();
        if (readonly) {
          $xeForm.dispatchEvent('submit', {
            data: props.data
          }, evnt);
          return;
        }
        $xeForm.beginValidate($xeForm.getItems()).then(function (errMap) {
          if (errMap) {
            $xeForm.dispatchEvent('submit-invalid', {
              data: props.data,
              errMap: errMap
            }, evnt);
          } else {
            $xeForm.dispatchEvent('submit', {
              data: props.data
            }, evnt);
          }
        });
      }
    },
    closeTooltip: function closeTooltip() {
      var $xeForm = this;
      var internalData = $xeForm.internalData;
      var tooltipStore = internalData.tooltipStore;
      var $tooltip = $xeForm.$refs.refTooltip;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return $xeForm.$nextTick();
    },
    triggerTitleTipEvent: function triggerTitleTipEvent(evnt, params) {
      var $xeForm = this;
      var internalData = $xeForm.internalData;
      var item = params.item;
      var tooltipStore = internalData.tooltipStore;
      var $tooltip = $xeForm.$refs.refTooltip;
      var overflowElem = evnt.currentTarget.children[0];
      var content = (overflowElem.textContent || '').trim();
      var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        $xeForm.closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item: item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    },
    handleTitleTipLeaveEvent: function handleTitleTipLeaveEvent() {
      var $xeForm = this;
      var internalData = $xeForm.internalData;
      var tooltipOpts = $xeForm.computeTooltipOpts;
      var $tooltip = $xeForm.$refs.refTooltip;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(function () {
          $tooltip = $xeForm.$refs.refTooltip;
          if ($tooltip && !$tooltip.isActived()) {
            $xeForm.closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        $xeForm.closeTooltip();
      }
    },
    triggerItemEvent: function triggerItemEvent(evnt, field, itemValue) {
      var $xeForm = this;
      if (field) {
        return $xeForm.validItemRules(evnt ? ['blur'].includes(evnt.type) ? 'blur' : 'change' : 'all', field, itemValue).then(function () {
          $xeForm.clearValidate(field);
        }).catch(function (errorMaps) {
          var rest = errorMaps[field];
          var item = $xeForm.getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return $xeForm.$nextTick();
    },
    /**
     * 更新项状态
     * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态
     * 如果单元格配置了校验规则，则会进行校验
     */
    updateStatus: function updateStatus(scope, itemValue) {
      var $xeForm = this;
      var field = scope.field;
      return $xeForm.triggerItemEvent(new Event('change'), field, itemValue);
    },
    //
    // Render
    //
    renderVN: function renderVN(h) {
      var $xeForm = this;
      var props = $xeForm;
      var slots = $xeForm.$scopedSlots;
      var reactData = $xeForm.reactData;
      var loading = props.loading,
        border = props.border,
        className = props.className,
        data = props.data,
        customLayout = props.customLayout;
      var formItems = reactData.formItems;
      // const formItems: any[] = []
      var vSize = $xeForm.computeSize;
      var tooltipOpts = $xeForm.computeTooltipOpts;
      var defaultSlot = slots.default;
      return h('form', {
        ref: 'refElem',
        class: ['vxe-form', className ? _xeUtils.default.isFunction(className) ? className({
          items: formItems,
          data: data,
          $form: $xeForm
        }) : className : '', _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--border', border), 'custom--layout', customLayout), 'is--loading', loading)],
        on: {
          submit: $xeForm.submitEvent,
          reset: $xeForm.resetEvent
        }
      }, [h('div', {
        class: 'vxe-form--wrapper vxe-form--item-row'
      }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map(function (item, index) {
        return h(_formConfigItem.default, {
          key: index,
          props: {
            itemConfig: item
          }
        });
      })), h('div', {
        class: 'vxe-form-slots',
        ref: 'hideItem'
      }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      h(_loading.default, {
        class: 'vxe-form--loading',
        props: {
          value: loading
        }
      }),
      /**
       * 工具提示
       */
      h(_tooltip.default, Object.assign({
        ref: 'refTooltip'
      }, tooltipOpts))]);
    }
  },
  watch: {
    'reactData.staticItems': function reactDataStaticItems() {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      reactData.formItems = reactData.staticItems;
    },
    items: function items() {
      var $xeForm = this;
      var props = $xeForm;
      $xeForm.loadItem(props.items || []);
    },
    collapseStatus: function collapseStatus(val) {
      var $xeForm = this;
      var reactData = $xeForm.reactData;
      reactData.collapseAll = !!val;
    },
    readonly: function readonly() {
      var $xeForm = this;
      $xeForm.clearValidate();
    },
    disabled: function disabled() {
      var $xeForm = this;
      $xeForm.clearValidate();
    }
  },
  created: function created() {
    var $xeForm = this;
    var props = $xeForm;
    var reactData = $xeForm.reactData;
    reactData.collapseAll = !!props.collapseStatus;
  },
  mounted: function mounted() {
    var $xeForm = this;
    var props = $xeForm;
    if (props.items) {
      $xeForm.loadItem(props.items);
    }
    $xeForm.$nextTick(function () {
      if (props.customLayout && props.items) {
        (0, _log.errLog)('vxe.error.errConflicts', ['custom-layout', 'items']);
      }
    });
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */