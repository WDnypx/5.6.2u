"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _utils = require("../../ui/src/utils");
var _dom = require("../../ui/src/dom");
var _vn = require("../../ui/src/vn");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeTooltip',
  mixins: [_ui.globalMixins.sizeMixin],
  props: {
    value: Boolean,
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.size || (0, _ui.getConfig)().size;
      }
    },
    selector: String,
    trigger: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.trigger || 'hover';
      }
    },
    theme: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.theme || 'dark';
      }
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.isArrow;
      }
    },
    enterable: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.enterable;
      }
    },
    enterDelay: {
      type: Number,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.enterDelay;
      }
    },
    leaveDelay: {
      type: Number,
      default: function _default() {
        return (0, _ui.getConfig)().tooltip.leaveDelay;
      }
    }
  },
  data: function data() {
    var reactData = {
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: '',
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: '',
        arrowStyle: {}
      }
    };
    var internalData = {};
    return {
      xID: _xeUtils.default.uniqueId(),
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign({}, {}),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeTooltip = this;
      $xeTooltip.$emit(type, (0, _ui.createEvent)(evnt, {
        $tooltip: $xeTooltip
      }, params));
    },
    emitModel: function emitModel(value) {
      var $xeTooltip = this;
      var _events = $xeTooltip._events;
      $xeTooltip.$emit('input', value);
      if (_events && _events.modelValue) {
        $xeTooltip.$emit('modelValue', value);
      } else {
        $xeTooltip.$emit('model-value', value);
      }
    },
    getSelectorEl: function getSelectorEl() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var selector = props.selector;
      if (selector) {
        if (_xeUtils.default.isElement(selector)) {
          return selector;
        }
        if (_xeUtils.default.isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    },
    open: function open(target, content) {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      return $xeTooltip.handleVisible(target || reactData.target || $xeTooltip.getSelectorEl(), content);
    },
    close: function close() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      reactData.tipTarget = null;
      reactData.tipActive = false;
      Object.assign(reactData.tipStore, {
        style: {},
        placement: '',
        arrowStyle: null
      });
      $xeTooltip.updateValue(false);
      return $xeTooltip.$nextTick();
    },
    toVisible: function toVisible(target, content) {
      var $xeTooltip = this;
      return $xeTooltip.handleVisible(target, content);
    },
    updatePlacement: function updatePlacement() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      return $xeTooltip.$nextTick().then(function () {
        var tipTarget = reactData.tipTarget;
        var el = $xeTooltip.$refs.refElem;
        if (tipTarget && el) {
          $xeTooltip.updateTipStyle();
          return $xeTooltip.$nextTick().then(function () {
            $xeTooltip.updateTipStyle();
          });
        }
      });
    },
    isActived: function isActived() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      return reactData.tipActive;
    },
    setActived: function setActived(active) {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      reactData.tipActive = !!active;
    },
    updateTipStyle: function updateTipStyle() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      var tipTarget = reactData.tipTarget,
        tipStore = reactData.tipStore;
      if (tipTarget) {
        var _getDomNode = (0, _dom.getDomNode)(),
          scrollTop = _getDomNode.scrollTop,
          scrollLeft = _getDomNode.scrollLeft,
          visibleWidth = _getDomNode.visibleWidth;
        var _getAbsolutePos = (0, _dom.getAbsolutePos)(tipTarget),
          top = _getAbsolutePos.top,
          left = _getAbsolutePos.left;
        var el = $xeTooltip.$refs.refElem;
        var marginSize = 6;
        var offsetHeight = el.offsetHeight;
        var offsetWidth = el.offsetWidth;
        var tipLeft = left;
        var tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = 'bottom';
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = "".concat(tipTop, "px");
        tipStore.style.left = "".concat(tipLeft, "px");
        tipStore.arrowStyle.left = "".concat(left - tipLeft + tipTarget.offsetWidth / 2, "px");
      }
    },
    updateValue: function updateValue(value) {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        $xeTooltip.emitModel(value);
      }
    },
    updateZindex: function updateZindex() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      if (reactData.tipZindex < (0, _utils.getLastZIndex)()) {
        reactData.tipZindex = (0, _utils.nextZIndex)();
      }
    },
    clickEvent: function clickEvent() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      if (reactData.visible) {
        $xeTooltip.close();
      } else {
        $xeTooltip.handleVisible(reactData.target || $xeTooltip.getSelectorEl(), props.content);
      }
    },
    targetMouseenterEvent: function targetMouseenterEvent() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      $xeTooltip.handleVisible(reactData.target || $xeTooltip.getSelectorEl(), props.content);
    },
    targetMouseleaveEvent: function targetMouseleaveEvent() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      var trigger = props.trigger,
        enterable = props.enterable,
        leaveDelay = props.leaveDelay;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(function () {
          if (!reactData.tipActive) {
            $xeTooltip.close();
          }
        }, leaveDelay);
      } else {
        $xeTooltip.close();
      }
    },
    wrapperMouseenterEvent: function wrapperMouseenterEvent() {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      reactData.tipActive = true;
    },
    wrapperMouseleaveEvent: function wrapperMouseleaveEvent() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      var trigger = props.trigger,
        enterable = props.enterable,
        leaveDelay = props.leaveDelay;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(function () {
          if (!reactData.tipActive) {
            $xeTooltip.close();
          }
        }, leaveDelay);
      }
    },
    showTip: function showTip() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      var tipStore = reactData.tipStore;
      var el = $xeTooltip.$refs.refElem;
      if (el) {
        var parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      $xeTooltip.updateValue(true);
      $xeTooltip.updateZindex();
      tipStore.placement = 'top';
      tipStore.style = {
        width: 'auto',
        left: 0,
        top: 0,
        zIndex: props.zIndex || reactData.tipZindex
      };
      tipStore.arrowStyle = {
        left: '50%'
      };
      return $xeTooltip.updatePlacement();
    },
    handleDelayFn: function handleDelayFn() {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      var internalData = $xeTooltip.internalData;
      internalData.showDelayTip = _xeUtils.default.debounce(function () {
        if (reactData.tipActive) {
          $xeTooltip.showTip();
        }
      }, props.enterDelay, {
        leading: false,
        trailing: true
      });
    },
    handleVisible: function handleVisible(target, content) {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var slots = $xeTooltip.$scopedSlots;
      var reactData = $xeTooltip.reactData;
      var internalData = $xeTooltip.internalData;
      var contentSlot = slots.content;
      if (!contentSlot && (content === '' || _xeUtils.default.eqNull(content))) {
        return $xeTooltip.$nextTick();
      }
      if (target) {
        var showDelayTip = internalData.showDelayTip;
        var trigger = props.trigger,
          enterDelay = props.enterDelay;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === 'hover') {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return $xeTooltip.showTip();
        }
      }
      return $xeTooltip.$nextTick();
    },
    //
    // Render
    //
    renderContent: function renderContent(h) {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var slots = $xeTooltip.$scopedSlots;
      var reactData = $xeTooltip.reactData;
      var useHTML = props.useHTML;
      var tipContent = reactData.tipContent;
      var contentSlot = slots.content;
      if (contentSlot) {
        return h('div', {
          key: 1,
          class: 'vxe-tooltip--content'
        }, (0, _vn.getSlotVNs)(contentSlot({})));
      }
      if (useHTML) {
        return h('div', {
          key: 2,
          class: 'vxe-tooltip--content',
          domProps: {
            innerHTML: tipContent
          }
        });
      }
      return h('div', {
        key: 3,
        class: 'vxe-tooltip--content'
      }, "".concat(tipContent));
    },
    renderVN: function renderVN(h) {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var slots = $xeTooltip.$scopedSlots;
      var reactData = $xeTooltip.reactData;
      var popupClassName = props.popupClassName,
        theme = props.theme,
        isArrow = props.isArrow,
        enterable = props.enterable;
      var tipActive = reactData.tipActive,
        visible = reactData.visible,
        tipStore = reactData.tipStore;
      var defaultSlot = slots.default;
      var vSize = $xeTooltip.computeSize;
      var ons;
      if (enterable) {
        ons = {
          mouseenter: $xeTooltip.wrapperMouseenterEvent,
          mouseleave: $xeTooltip.wrapperMouseleaveEvent
        };
      }
      return h('div', {
        ref: 'refElem',
        class: ['vxe-tooltip--wrapper', "theme--".concat(theme), popupClassName ? _xeUtils.default.isFunction(popupClassName) ? popupClassName({
          $tooltip: $xeTooltip
        }) : popupClassName : '', _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), "placement--".concat(tipStore.placement), tipStore.placement), 'is--enterable', enterable), 'is--visible', visible), 'is--arrow', isArrow), 'is--active', tipActive)],
        style: tipStore.style,
        on: ons
      }, [$xeTooltip.renderContent(h), h('div', {
        class: 'vxe-tooltip--arrow',
        style: tipStore.arrowStyle
      })].concat(_toConsumableArray(defaultSlot ? (0, _vn.getSlotVNs)(defaultSlot({})) : [])));
    }
  },
  watch: {
    content: function content(val) {
      var $xeTooltip = this;
      var reactData = $xeTooltip.reactData;
      reactData.tipContent = val;
    },
    value: function value(val) {
      var $xeTooltip = this;
      var props = $xeTooltip;
      var reactData = $xeTooltip.reactData;
      if (!reactData.isUpdate) {
        if (val) {
          $xeTooltip.handleVisible(reactData.target || $xeTooltip.getSelectorEl(), props.content);
        } else {
          $xeTooltip.close();
        }
      }
      reactData.isUpdate = false;
    },
    enterDelay: function enterDelay() {
      var $xeTooltip = this;
      $xeTooltip.handleDelayFn();
    }
  },
  created: function created() {
    var $xeTooltip = this;
    $xeTooltip.handleDelayFn();
  },
  mounted: function mounted() {
    var $xeTooltip = this;
    var props = $xeTooltip;
    var reactData = $xeTooltip.reactData;
    $xeTooltip.$nextTick(function () {
      var trigger = props.trigger,
        content = props.content;
      var wrapperElem = $xeTooltip.$refs.refElem;
      if (wrapperElem) {
        var parentNode = wrapperElem.parentNode;
        if (parentNode) {
          reactData.tipContent = content;
          reactData.tipZindex = (0, _utils.nextZIndex)();
          _xeUtils.default.arrayEach(wrapperElem.children, function (elem, index) {
            if (index > 1) {
              parentNode.insertBefore(elem, wrapperElem);
              if (!reactData.target) {
                reactData.target = elem;
              }
            }
          });
          parentNode.removeChild(wrapperElem);
          var target = reactData.target;
          if (target) {
            if (trigger === 'hover') {
              target.onmouseenter = $xeTooltip.targetMouseenterEvent;
              target.onmouseleave = $xeTooltip.targetMouseleaveEvent;
            } else if (trigger === 'click') {
              target.onclick = $xeTooltip.clickEvent;
            }
          }
          if (props.value) {
            $xeTooltip.handleVisible(target || $xeTooltip.getSelectorEl(), content);
          }
        }
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    var $xeTooltip = this;
    var reactData = $xeTooltip.reactData;
    var target = reactData.target;
    var wrapperElem = $xeTooltip.$refs.refElem;
    if (target) {
      target.onmouseenter = null;
      target.onmouseleave = null;
      target.onclick = null;
    }
    if (wrapperElem) {
      var parentNode = wrapperElem.parentNode;
      if (parentNode) {
        parentNode.removeChild(wrapperElem);
      }
    }
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */