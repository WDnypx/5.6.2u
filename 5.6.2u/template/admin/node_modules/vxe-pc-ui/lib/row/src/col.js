"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _dom = require("../../ui/src/dom");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeCol',
  mixins: [_ui.globalMixins.sizeMixin],
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().col.size || (0, _ui.getConfig)().size;
      }
    }
  },
  inject: {
    $xeRow: {
      default: null
    }
  },
  data: function data() {
    var reactData = {};
    return {
      xID: _xeUtils.default.uniqueId(),
      reactData: reactData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeRowGutter: function computeRowGutter() {
      var $xeCol = this;
      var $xeRow = $xeCol.$xeRow;
      if ($xeRow) {
        return $xeRow.gutter;
      }
      return null;
    },
    computeRowVertical: function computeRowVertical() {
      var $xeCol = this;
      var $xeRow = $xeCol.$xeRow;
      if ($xeRow) {
        return $xeRow.vertical;
      }
      return null;
    },
    computeColStyle: function computeColStyle() {
      var $xeCol = this;
      var props = $xeCol;
      var width = props.width;
      var rowGutter = $xeCol.computeRowGutter;
      var rowVertical = $xeCol.computeRowVertical;
      var style = {};
      if (rowGutter) {
        var _ref = _xeUtils.default.isArray(rowGutter) ? rowGutter : [rowGutter],
          _ref2 = _slicedToArray(_ref, 2),
          lrGutter = _ref2[0],
          tbGutter = _ref2[1];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          var padding = _xeUtils.default.isNumber(lrGutter) ? (0, _dom.toCssUnit)(lrGutter / 2) : "calc(".concat((0, _dom.toCssUnit)(lrGutter), " / 2)");
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          var _padding = _xeUtils.default.isNumber(tbGutter) ? (0, _dom.toCssUnit)(tbGutter / 2) : "calc(".concat((0, _dom.toCssUnit)(tbGutter), " / 2)");
          style.paddingTop = _padding;
          style.paddingBottom = _padding;
        }
      }
      if (width) {
        style.width = (0, _dom.toCssUnit)(width);
      }
      return style;
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeCol = this;
      $xeCol.$emit(type, (0, _ui.createEvent)(evnt, {
        $col: $xeCol
      }, params));
    },
    //
    // Render
    //
    renderVN: function renderVN(h) {
      var $xeCol = this;
      var props = $xeCol;
      var slots = $xeCol.$scopedSlots;
      var span = props.span,
        fill = props.fill,
        align = props.align,
        width = props.width,
        ellipsis = props.ellipsis;
      var colStyle = $xeCol.computeColStyle;
      var defaultSlot = slots.default;
      return h('div', {
        ref: 'refElem',
        class: ['vxe-col', span ? "span".concat(span) : '', align ? "align--".concat(align) : '', {
          'is--span': !!span,
          'is--width': !!width,
          'is--fill': fill,
          'is--ellipsis': ellipsis
        }],
        style: colStyle
      }, [h('div', {
        class: 'vxe-col--inner'
      }, defaultSlot ? defaultSlot({}) : [])]);
    }
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */