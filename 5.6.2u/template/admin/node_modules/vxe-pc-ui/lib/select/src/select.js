"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _dom = require("../../ui/src/dom");
var _utils = require("../../ui/src/utils");
var _input = _interopRequireDefault(require("../../input/src/input"));
var _vn = require("../../ui/src/vn");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return _xeUtils.default.uniqueId('opt_');
}
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeSelect',
  mixins: [_ui.globalMixins.sizeMixin],
  model: {
    prop: 'value',
    event: 'modelValue'
  },
  props: {
    value: [String, Number, Boolean, Array],
    defaultConfig: Object,
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: function _default() {
        return (0, _ui.getConfig)().select.multiCharOverflow;
      }
    },
    prefixIcon: String,
    allowCreate: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().select.allowCreate;
      }
    },
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().select.size || (0, _ui.getConfig)().size;
      }
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    // 已废弃，被 remote-config.queryMethod 替换
    remoteMethod: Function,
    remoteConfig: Object,
    emptyText: String,
    transfer: {
      type: Boolean,
      default: null
    },
    virtualYConfig: Object,
    scrollY: Object,
    // 已废弃，被 option-config.keyField 替换
    optionId: {
      type: String,
      default: function _default() {
        return (0, _ui.getConfig)().select.optionId;
      }
    },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean
  },
  inject: {
    $xeModal: {
      default: null
    },
    $xeDrawer: {
      default: null
    },
    $xeTable: {
      default: null
    },
    $xeForm: {
      default: null
    },
    formItemInfo: {
      from: 'xeFormItemInfo',
      default: null
    }
  },
  provide: function provide() {
    var $xeSelect = this;
    return {
      $xeSelect: $xeSelect
    };
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      afterVisibleList: [],
      staticOptions: [],
      reactFlag: 1,
      currentOption: null,
      searchValue: '',
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    };
    var internalData = {
      synchData: [],
      fullData: [],
      optAddMaps: {},
      optGroupKeyMaps: {},
      optFullValMaps: {},
      remoteValMaps: {},
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      },
      lastScrollTime: 0,
      hpTimeout: undefined
    };
    return {
      xID: xID,
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeFormReadonly: function computeFormReadonly() {
      var $xeSelect = this;
      var props = $xeSelect;
      var $xeForm = $xeSelect.$xeForm;
      var readonly = props.readonly;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.readonly;
        }
        return false;
      }
      return readonly;
    },
    computeIsDisabled: function computeIsDisabled() {
      var $xeSelect = this;
      var props = $xeSelect;
      var $xeForm = $xeSelect.$xeForm;
      var disabled = props.disabled;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.disabled;
        }
        return false;
      }
      return disabled;
    },
    computeBtnTransfer: function computeBtnTransfer() {
      var $xeSelect = this;
      var props = $xeSelect;
      var $xeTable = $xeSelect.$xeTable;
      var $xeModal = $xeSelect.$xeModal;
      var $xeDrawer = $xeSelect.$xeDrawer;
      var $xeForm = $xeSelect.$xeForm;
      var transfer = props.transfer;
      if (transfer === null) {
        var globalTransfer = (0, _ui.getConfig)().select.transfer;
        if (_xeUtils.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    },
    computeInpPlaceholder: function computeInpPlaceholder() {
      var $xeSelect = this;
      var props = $xeSelect;
      var placeholder = props.placeholder;
      if (placeholder) {
        return (0, _utils.getFuncText)(placeholder);
      }
      var globalPlaceholder = (0, _ui.getConfig)().select.placeholder;
      if (globalPlaceholder) {
        return (0, _utils.getFuncText)(globalPlaceholder);
      }
      return (0, _ui.getI18n)('vxe.base.pleaseSelect');
    },
    computeDefaultOpts: function computeDefaultOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, props.defaultConfig);
    },
    computePropsOpts: function computePropsOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, props.optionProps);
    },
    computeGroupPropsOpts: function computeGroupPropsOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, props.optionGroupProps);
    },
    computeLabelField: function computeLabelField() {
      var $xeSelect = this;
      var propsOpts = $xeSelect.computePropsOpts;
      return propsOpts.label || 'label';
    },
    computeValueField: function computeValueField() {
      var $xeSelect = this;
      var propsOpts = $xeSelect.computePropsOpts;
      return propsOpts.value || 'value';
    },
    computeGroupLabelField: function computeGroupLabelField() {
      var $xeSelect = this;
      var groupPropsOpts = $xeSelect.computeGroupPropsOpts;
      return groupPropsOpts.label || 'label';
    },
    computeGroupOptionsField: function computeGroupOptionsField() {
      var $xeSelect = this;
      var groupPropsOpts = $xeSelect.computeGroupPropsOpts;
      return groupPropsOpts.options || 'options';
    },
    computeIsMaximize: function computeIsMaximize() {
      var $xeSelect = this;
      var props = $xeSelect;
      var value = props.value,
        multiple = props.multiple,
        max = props.max;
      if (multiple && max) {
        return (_xeUtils.default.isArray(value) ? value.length : _xeUtils.default.eqNull(value) ? 0 : 1) >= _xeUtils.default.toNumber(max);
      }
      return false;
    },
    computeSYOpts: function computeSYOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, (0, _ui.getConfig)().select.virtualYConfig || (0, _ui.getConfig)().select.scrollY, props.virtualYConfig || props.scrollY);
    },
    computeRemoteOpts: function computeRemoteOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, (0, _ui.getConfig)().select.remoteConfig, props.remoteConfig);
    },
    computeOptionOpts: function computeOptionOpts() {
      var $xeSelect = this;
      var props = $xeSelect;
      return Object.assign({}, (0, _ui.getConfig)().select.optionConfig, props.optionConfig);
    },
    computeIsGroup: function computeIsGroup() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      return reactData.fullGroupList.some(function (item) {
        return item.options && item.options.length;
      });
    },
    computeMultiMaxCharNum: function computeMultiMaxCharNum() {
      var $xeSelect = this;
      var props = $xeSelect;
      return _xeUtils.default.toNumber(props.multiCharOverflow);
    },
    computeSelectLabel: function computeSelectLabel() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var value = props.value,
        remote = props.remote,
        multiple = props.multiple;
      var reactFlag = reactData.reactFlag;
      var multiMaxCharNum = $xeSelect.computeMultiMaxCharNum;
      if (_xeUtils.default.eqNull(value)) {
        return '';
      }
      var vals = _xeUtils.default.isArray(value) ? value : [value];
      if (remote && reactFlag) {
        return vals.map(function (val) {
          return $xeSelect.getRemoteSelectLabel(val);
        }).join(', ');
      }
      return vals.map(function (val) {
        var label = $xeSelect.getSelectLabel(val);
        if (multiple && multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
          return "".concat(label.substring(0, multiMaxCharNum), "...");
        }
        return label;
      }).join(', ');
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeSelect = this;
      $xeSelect.$emit(type, (0, _ui.createEvent)(evnt, {
        $select: $xeSelect
      }, params));
    },
    emitModel: function emitModel(value) {
      var $xeSelect = this;
      var _events = $xeSelect._events;
      if (_events && _events.modelValue) {
        $xeSelect.$emit('modelValue', value);
      } else {
        $xeSelect.$emit('model-value', value);
      }
    },
    isPanelVisible: function isPanelVisible() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      return reactData.visiblePanel;
    },
    togglePanel: function togglePanel() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (reactData.visiblePanel) {
        $xeSelect.hideOptionPanel();
      } else {
        $xeSelect.showOptionPanel();
      }
      return $xeSelect.$nextTick();
    },
    hidePanel: function hidePanel() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (reactData.visiblePanel) {
        $xeSelect.hideOptionPanel();
      }
      return $xeSelect.$nextTick();
    },
    showPanel: function showPanel() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (!reactData.visiblePanel) {
        $xeSelect.showOptionPanel();
      }
      return $xeSelect.$nextTick();
    },
    focus: function focus() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var $input = $xeSelect.$refs.refInput;
      reactData.isActivated = true;
      $input.blur();
      return $xeSelect.$nextTick();
    },
    blur: function blur() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var $input = $xeSelect.$refs.refInput;
      $input.blur();
      reactData.isActivated = false;
      return $xeSelect.$nextTick();
    },
    callSlot: function callSlot(slotFunc, params, h) {
      var $xeSelect = this;
      var slots = $xeSelect.$scopedSlots;
      if (slotFunc) {
        if (_xeUtils.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (_xeUtils.default.isFunction(slotFunc)) {
          return (0, _vn.getSlotVNs)(slotFunc.call($xeSelect, params, h));
        }
      }
      return [];
    },
    getOptKey: function getOptKey() {
      var $xeSelect = this;
      var props = $xeSelect;
      var optionOpts = $xeSelect.computeOptionOpts;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    },
    getOptId: function getOptId(option) {
      var $xeSelect = this;
      var optid = option[$xeSelect.getOptKey()];
      return optid ? encodeURIComponent(optid) : '';
    },
    getRemoteSelectLabel: function getRemoteSelectLabel(value) {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var remoteValMaps = internalData.remoteValMaps,
        optFullValMaps = internalData.optFullValMaps;
      var labelField = $xeSelect.computeLabelField;
      var remoteItem = remoteValMaps[value] || optFullValMaps[value];
      var item = remoteItem ? remoteItem.item : null;
      return _xeUtils.default.toValueString(item ? item[labelField] : value);
    },
    getSelectLabel: function getSelectLabel(value) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var optFullValMaps = internalData.optFullValMaps;
      var labelField = $xeSelect.computeLabelField;
      var cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      return cacheItem ? cacheItem.item[labelField] : _xeUtils.default.toValueString(value);
    },
    getOptkey: function getOptkey() {
      var $xeSelect = this;
      var props = $xeSelect;
      var optionOpts = $xeSelect.computeOptionOpts;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    },
    getOptid: function getOptid(option) {
      var $xeSelect = this;
      var optid = option[$xeSelect.getOptkey()];
      return optid ? encodeURIComponent(optid) : '';
    },
    /**
     * 处理选项，当选项被动态显示/隐藏时可能会用到
     */
    handleOption: function handleOption() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var value = props.value,
        filterable = props.filterable,
        filterMethod = props.filterMethod;
      var searchValue = reactData.searchValue;
      var fullData = internalData.fullData,
        optFullValMaps = internalData.optFullValMaps;
      var labelField = $xeSelect.computeLabelField;
      var valueField = $xeSelect.computeValueField;
      var searchStr = "".concat(searchValue || '').toLowerCase();
      var avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter(function (option) {
          return isOptionVisible(option) && filterMethod({
            $select: $xeSelect,
            group: null,
            option: option,
            searchValue: searchValue,
            value: value
          });
        });
      } else if (filterable) {
        avList = fullData.filter(function (option) {
          return isOptionVisible(option) && (!searchStr || "".concat(option[labelField]).toLowerCase().indexOf(searchStr) > -1);
        });
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach(function (item, index) {
        var cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index;
        }
      });
      reactData.afterVisibleList = avList;
      return $xeSelect.$nextTick();
    },
    refreshOption: function refreshOption() {
      var $xeSelect = this;
      $xeSelect.handleOption();
      $xeSelect.updateYData();
      return $xeSelect.$nextTick();
    },
    cacheItemMap: function cacheItemMap(datas) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var groupOptionsField = $xeSelect.computeGroupOptionsField;
      var valueField = $xeSelect.computeValueField;
      var key = $xeSelect.getOptKey();
      var groupKeyMaps = {};
      var fullKeyMaps = {};
      var list = [];
      var handleOptItem = function handleOptItem(item) {
        list.push(item);
        var optid = $xeSelect.getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item: item,
          _index: -1
        };
      };
      datas.forEach(function (group) {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      $xeSelect.handleOption();
    },
    setCurrentOption: function setCurrentOption(option) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (option) {
        reactData.currentOption = option;
      }
    },
    scrollToOption: function scrollToOption(option, isAlignBottom) {
      var $xeSelect = this;
      return $xeSelect.$nextTick().then(function () {
        if (option) {
          var optWrapperElem = $xeSelect.$refs.refOptionWrapper;
          var panelElem = $xeSelect.$refs.refOptionPanel;
          var optElem = panelElem.querySelector("[optid='".concat($xeSelect.getOptid(option), "']"));
          if (optWrapperElem && optElem) {
            var wrapperHeight = optWrapperElem.offsetHeight;
            var offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    },
    updateZindex: function updateZindex() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (reactData.panelIndex < (0, _utils.getLastZIndex)()) {
        reactData.panelIndex = (0, _utils.nextZIndex)();
      }
    },
    updateZIndex: function updateZIndex() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      if (reactData.panelIndex < (0, _utils.getLastZIndex)()) {
        reactData.panelIndex = (0, _utils.nextZIndex)();
      }
    },
    updatePlacement: function updatePlacement() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var placement = props.placement;
      var panelIndex = reactData.panelIndex;
      var targetElem = $xeSelect.$refs.refElem;
      var panelElem = $xeSelect.$refs.refOptionPanel;
      var btnTransfer = $xeSelect.computeBtnTransfer;
      var handleStyle = function handleStyle() {
        var ppObj = (0, _dom.updatePanelPlacement)(targetElem, panelElem, {
          placement: placement,
          teleportTo: btnTransfer
        });
        var panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return $xeSelect.$nextTick().then(handleStyle);
    },
    showOptionPanel: function showOptionPanel() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var loading = props.loading,
        filterable = props.filterable,
        remote = props.remote;
      var fullData = internalData.fullData,
        hpTimeout = internalData.hpTimeout;
      var isDisabled = $xeSelect.computeIsDisabled;
      var remoteOpts = $xeSelect.computeRemoteOpts;
      if (!loading && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
          var btnTransfer = $xeSelect.computeBtnTransfer;
          var panelElem = $xeSelect.$refs.refOptionPanel;
          if (btnTransfer) {
            if (panelElem) {
              document.body.appendChild(panelElem);
            }
          }
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullData.length) {
            $xeSelect.triggerSearchEvent();
          } else {
            $xeSelect.handleOption();
            $xeSelect.updateYData();
          }
        }
        setTimeout(function () {
          reactData.visiblePanel = true;
          $xeSelect.handleFocusSearch();
          $xeSelect.recalculate().then(function () {
            return $xeSelect.refreshScroll();
          });
        }, 10);
        setTimeout(function () {
          $xeSelect.recalculate().then(function () {
            return $xeSelect.refreshScroll();
          });
        }, 100);
        $xeSelect.updateZIndex();
        $xeSelect.updatePlacement();
        $xeSelect.dispatchEvent('visible-change', {
          visible: true
        }, null);
      }
    },
    hideOptionPanel: function hideOptionPanel() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      reactData.searchValue = '';
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(function () {
        reactData.isAniVisible = false;
      }, 350);
      $xeSelect.dispatchEvent('visible-change', {
        visible: false
      }, null);
    },
    changeEvent: function changeEvent(evnt, selectValue) {
      var $xeSelect = this;
      var props = $xeSelect;
      var $xeForm = $xeSelect.$xeForm;
      var formItemInfo = $xeSelect.formItemInfo;
      $xeSelect.emitModel(selectValue);
      if (selectValue !== props.value) {
        $xeSelect.dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    },
    clearValueEvent: function clearValueEvent(evnt, selectValue) {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      internalData.remoteValMaps = {};
      $xeSelect.changeEvent(evnt, selectValue);
      $xeSelect.dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    },
    clearEvent: function clearEvent(params) {
      var $xeSelect = this;
      var $event = params.$event;
      $xeSelect.clearValueEvent($event, null);
      $xeSelect.hideOptionPanel();
    },
    changeOptionEvent: function changeOptionEvent(evnt, option) {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var value = props.value,
        multiple = props.multiple;
      var remoteValMaps = internalData.remoteValMaps;
      var valueField = $xeSelect.computeValueField;
      var selectValue = option[valueField];
      var remoteItem = remoteValMaps[selectValue];
      if (!reactData.visiblePanel) {
        return;
      }
      if (remoteItem) {
        remoteItem.item = option;
      } else {
        remoteValMaps[selectValue] = {
          key: $xeSelect.getOptId(option),
          item: option,
          _index: -1
        };
      }
      if (multiple) {
        var multipleValue = [];
        var selectVals = _xeUtils.default.eqNull(value) ? [] : _xeUtils.default.isArray(value) ? value : [value];
        var index = _xeUtils.default.findIndexOf(selectVals, function (val) {
          return val === selectValue;
        });
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter(function (val) {
            return val !== selectValue;
          });
        }
        $xeSelect.changeEvent(evnt, multipleValue);
      } else {
        $xeSelect.changeEvent(evnt, selectValue);
        $xeSelect.hideOptionPanel();
      }
      reactData.reactFlag++;
    },
    handleGlobalMousewheelEvent: function handleGlobalMousewheelEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var visiblePanel = reactData.visiblePanel;
      var isDisabled = $xeSelect.computeIsDisabled;
      if (!isDisabled) {
        if (visiblePanel) {
          var panelElem = $xeSelect.$refs.refOptionPanel;
          if ((0, _dom.getEventTargetNode)(evnt, panelElem).flag) {
            $xeSelect.updatePlacement();
          } else {
            $xeSelect.hideOptionPanel();
          }
        }
      }
    },
    handleGlobalMousedownEvent: function handleGlobalMousedownEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var visiblePanel = reactData.visiblePanel;
      var isDisabled = $xeSelect.computeIsDisabled;
      if (!isDisabled) {
        var el = $xeSelect.$refs.refElem;
        var panelElem = $xeSelect.$refs.refOptionPanel;
        reactData.isActivated = (0, _dom.getEventTargetNode)(evnt, el).flag || (0, _dom.getEventTargetNode)(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          $xeSelect.hideOptionPanel();
        }
      }
    },
    validOffsetOption: function validOffsetOption(option) {
      var $xeSelect = this;
      var isDisabled = option.disabled;
      var optid = $xeSelect.getOptId(option);
      if (!isDisabled && !$xeSelect.hasOptGroupById(optid)) {
        return true;
      }
      return false;
    },
    findOffsetOption: function findOffsetOption(option, isDwArrow) {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var allowCreate = props.allowCreate;
      var afterVisibleList = reactData.afterVisibleList,
        optList = reactData.optList;
      var optFullValMaps = internalData.optFullValMaps,
        optAddMaps = internalData.optAddMaps;
      var valueField = $xeSelect.computeValueField;
      var fullList = afterVisibleList;
      var offsetAddIndex = 0;
      if (allowCreate && optList.length) {
        var firstItem = optList[0];
        var optid = $xeSelect.getOptId(firstItem);
        if (optAddMaps[optid]) {
          offsetAddIndex = 1;
          fullList = [optAddMaps[optid]].concat(fullList);
        }
      }
      if (!option) {
        if (isDwArrow) {
          for (var i = 0; i < fullList.length; i++) {
            var item = fullList[i];
            if ($xeSelect.validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          for (var len = fullList.length - 1; len >= 0; len--) {
            var _item = fullList[len];
            if ($xeSelect.validOffsetOption(_item)) {
              return _item;
            }
          }
        }
      }
      var avIndex = 0;
      var cacheItem = option ? optFullValMaps[option[valueField]] : null;
      if (cacheItem) {
        avIndex = cacheItem._index + offsetAddIndex;
      }
      if (avIndex > -1) {
        if (isDwArrow) {
          for (var _i = avIndex + 1; _i <= fullList.length - 1; _i++) {
            var _item2 = fullList[_i];
            if ($xeSelect.validOffsetOption(_item2)) {
              return _item2;
            }
          }
        } else {
          if (avIndex > 0) {
            for (var _len = avIndex - 1; _len >= 0; _len--) {
              var _item3 = fullList[_len];
              if ($xeSelect.validOffsetOption(_item3)) {
                return _item3;
              }
            }
          }
        }
      }
      return null;
    },
    handleGlobalKeydownEvent: function handleGlobalKeydownEvent(evnt) {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var clearable = props.clearable;
      var visiblePanel = reactData.visiblePanel,
        currentOption = reactData.currentOption;
      var isDisabled = $xeSelect.computeIsDisabled;
      if (!isDisabled) {
        var isTab = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.TAB);
        var isEnter = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.ENTER);
        var isEsc = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.ESCAPE);
        var isUpArrow = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.ARROW_UP);
        var isDwArrow = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.ARROW_DOWN);
        var isDel = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.DELETE);
        var isSpacebar = _ui.globalEvents.hasKey(evnt, _ui.GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            $xeSelect.hideOptionPanel();
          } else if (isEnter) {
            if (currentOption) {
              evnt.preventDefault();
              evnt.stopPropagation();
              $xeSelect.changeOptionEvent(evnt, currentOption);
            }
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            var offsetOption = $xeSelect.findOffsetOption(currentOption, isDwArrow);
            // 如果不匹配，默认最接近一个
            if (!offsetOption) {
              offsetOption = $xeSelect.findOffsetOption(null, isDwArrow);
            }
            if (offsetOption) {
              $xeSelect.setCurrentOption(offsetOption);
              $xeSelect.handleScrollToOption(offsetOption, isDwArrow);
            }
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          $xeSelect.showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            $xeSelect.clearValueEvent(evnt, null);
          }
        }
      }
    },
    handleGlobalBlurEvent: function handleGlobalBlurEvent() {
      var $xeSelect = this;
      $xeSelect.hideOptionPanel();
    },
    handleFocusSearch: function handleFocusSearch() {
      var $xeSelect = this;
      var props = $xeSelect;
      if (props.filterable) {
        $xeSelect.$nextTick(function () {
          var inpSearch = $xeSelect.$refs.refInpSearch;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    },
    focusEvent: function focusEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var isDisabled = $xeSelect.computeIsDisabled;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          $xeSelect.showOptionPanel();
          setTimeout(function () {
            reactData.triggerFocusPanel = false;
          }, 500);
        }
      }
      $xeSelect.dispatchEvent('focus', {}, evnt);
    },
    clickEvent: function clickEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      $xeSelect.togglePanelEvent(evnt);
      $xeSelect.dispatchEvent('click', {
        triggerButton: false,
        visible: reactData.visiblePanel
      }, evnt);
    },
    blurEvent: function blurEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      reactData.isActivated = false;
      $xeSelect.dispatchEvent('blur', {}, evnt);
    },
    suffixClickEvent: function suffixClickEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      $xeSelect.togglePanelEvent(evnt);
      $xeSelect.dispatchEvent('click', {
        triggerButton: true,
        visible: reactData.visiblePanel
      }, evnt);
    },
    modelSearchEvent: function modelSearchEvent(value) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      reactData.searchValue = value;
    },
    focusSearchEvent: function focusSearchEvent() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      reactData.isActivated = true;
    },
    handleSearchEvent: function handleSearchEvent() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var value = props.value,
        remote = props.remote,
        remoteMethod = props.remoteMethod;
      var searchValue = reactData.searchValue;
      var remoteOpts = $xeSelect.computeRemoteOpts;
      var queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({
          $select: $xeSelect,
          searchValue: searchValue,
          value: value
        })).then(function () {
          return $xeSelect.$nextTick();
        }).catch(function () {
          return $xeSelect.$nextTick();
        }).finally(function () {
          reactData.searchLoading = false;
          $xeSelect.handleOption();
          $xeSelect.updateYData();
        });
      } else {
        $xeSelect.handleOption();
        $xeSelect.updateYData();
      }
    },
    triggerSearchEvent: _xeUtils.default.debounce(function () {
      var $xeSelect = this;
      $xeSelect.handleSearchEvent();
    }, 350, {
      trailing: true
    }),
    togglePanelEvent: function togglePanelEvent(params) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var $event = params.$event;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          $xeSelect.hideOptionPanel();
        } else {
          $xeSelect.showOptionPanel();
        }
      }
    },
    checkOptionDisabled: function checkOptionDisabled(isSelected, option, group) {
      var $xeSelect = this;
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      var isMaximize = $xeSelect.computeIsMaximize;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    },
    updateYSpace: function updateYSpace() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var scrollYLoad = reactData.scrollYLoad,
        afterVisibleList = reactData.afterVisibleList;
      var scrollYStore = internalData.scrollYStore;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    },
    handleData: function handleData() {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var filterable = props.filterable,
        allowCreate = props.allowCreate;
      var scrollYLoad = reactData.scrollYLoad,
        afterVisibleList = reactData.afterVisibleList,
        searchValue = reactData.searchValue;
      var optAddMaps = internalData.optAddMaps,
        scrollYStore = internalData.scrollYStore;
      var labelField = $xeSelect.computeLabelField;
      var valueField = $xeSelect.computeValueField;
      var restList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      if (filterable && allowCreate && searchValue) {
        if (!restList.some(function (option) {
          return option[labelField] === searchValue;
        })) {
          var addItem = optAddMaps[searchValue] || _defineProperty(_defineProperty(_defineProperty({}, $xeSelect.getOptKey(), searchValue), labelField, searchValue), valueField, searchValue);
          optAddMaps[searchValue] = addItem;
          restList.unshift(addItem);
        }
      }
      reactData.optList = restList;
      return $xeSelect.$nextTick();
    },
    updateYData: function updateYData() {
      var $xeSelect = this;
      $xeSelect.handleData();
      $xeSelect.updateYSpace();
    },
    computeScrollLoad: function computeScrollLoad() {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      return $xeSelect.$nextTick().then(function () {
        var scrollYLoad = reactData.scrollYLoad;
        var scrollYStore = internalData.scrollYStore;
        var virtualBodyElem = $xeSelect.$refs.refVirtualBody;
        var sYOpts = $xeSelect.computeSYOpts;
        var rowHeight = 0;
        var firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          var scrollBodyElem = $xeSelect.$refs.refVirtualWrapper;
          var visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          var offsetYSize = Math.max(0, Math.min(2, _xeUtils.default.toNumber(sYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          $xeSelect.updateYData();
        } else {
          $xeSelect.updateYSpace();
        }
      });
    },
    handleScrollToOption: function handleScrollToOption(option, isDwArrow) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var scrollYLoad = reactData.scrollYLoad;
      var optFullValMaps = internalData.optFullValMaps,
        scrollYStore = internalData.scrollYStore;
      var valueField = $xeSelect.computeValueField;
      var cacheItem = optFullValMaps[option[valueField]];
      if (cacheItem) {
        var optid = cacheItem.key;
        var avIndex = cacheItem._index;
        if (avIndex > -1) {
          var optWrapperElem = $xeSelect.$refs.refVirtualWrapper;
          var panelElem = $xeSelect.$refs.refOptionPanel;
          var optElem = panelElem.querySelector("[optid='".concat(optid, "']"));
          if (optWrapperElem) {
            if (optElem) {
              var wrapperHeight = optWrapperElem.offsetHeight;
              var offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                } else if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                } else if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    },
    /**
     * 如果有滚动条，则滚动到对应的位置
     * @param {Number} scrollLeft 左距离
     * @param {Number} scrollTop 上距离
     */
    scrollTo: function scrollTo(scrollLeft, scrollTop) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var scrollBodyElem = $xeSelect.$refs.refVirtualWrapper;
      if (scrollBodyElem) {
        if (_xeUtils.default.isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (_xeUtils.default.isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise(function (resolve) {
          setTimeout(function () {
            $xeSelect.$nextTick(function () {
              resolve();
            });
          }, 50);
        });
      }
      return $xeSelect.$nextTick();
    },
    /**
     * 刷新滚动条
     */
    refreshScroll: function refreshScroll() {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var lastScrollLeft = internalData.lastScrollLeft,
        lastScrollTop = internalData.lastScrollTop;
      return $xeSelect.clearScroll().then(function () {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return $xeSelect.scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    },
    /**
     * 重新计算列表
     */
    recalculate: function recalculate() {
      var $xeSelect = this;
      var el = $xeSelect.$refs.refElem;
      if (el && el.clientWidth && el.clientHeight) {
        return $xeSelect.computeScrollLoad();
      }
      return Promise.resolve();
    },
    loadYData: function loadYData(evnt) {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var scrollYStore = internalData.scrollYStore;
      var startIndex = scrollYStore.startIndex,
        endIndex = scrollYStore.endIndex,
        visibleSize = scrollYStore.visibleSize,
        offsetSize = scrollYStore.offsetSize,
        rowHeight = scrollYStore.rowHeight;
      var scrollBodyElem = evnt.target;
      var scrollTop = scrollBodyElem.scrollTop;
      var toVisibleIndex = Math.floor(scrollTop / rowHeight);
      var offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      var offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          $xeSelect.updateYData();
        }
      }
    },
    // 滚动、拖动过程中不需要触发
    isVMScrollProcess: function isVMScrollProcess() {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var delayHover = 250;
      var lastScrollTime = internalData.lastScrollTime;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    },
    scrollEvent: function scrollEvent(evnt) {
      var $xeSelect = this;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var scrollBodyElem = evnt.target;
      var scrollTop = scrollBodyElem.scrollTop;
      var scrollLeft = scrollBodyElem.scrollLeft;
      var isX = scrollLeft !== internalData.lastScrollLeft;
      var isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        $xeSelect.loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      $xeSelect.dispatchEvent('scroll', {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        isX: isX,
        isY: isY
      }, evnt);
    },
    /**
     * 加载数据
     * @param {Array} datas 数据
     */
    loadData: function loadData(datas) {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      $xeSelect.cacheItemMap(datas || []);
      var isLoaded = internalData.isLoaded,
        fullData = internalData.fullData,
        scrollYStore = internalData.scrollYStore;
      var defaultOpts = $xeSelect.computeDefaultOpts;
      var sYOpts = $xeSelect.computeSYOpts;
      var valueField = $xeSelect.computeValueField;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      // 如果gt为0，则总是启用
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      $xeSelect.handleData();
      if (!isLoaded) {
        var selectMode = defaultOpts.selectMode;
        if (datas.length > 0 && _xeUtils.default.eqNull(props.value)) {
          if (selectMode === 'first' || selectMode === 'last') {
            var selectItem = _xeUtils.default[selectMode](datas);
            if (selectItem) {
              $xeSelect.$nextTick(function () {
                if (_xeUtils.default.eqNull(props.value)) {
                  $xeSelect.emitModel(selectItem[valueField]);
                }
              });
            }
          }
          internalData.isLoaded = true;
        }
      }
      return $xeSelect.computeScrollLoad().then(function () {
        $xeSelect.refreshScroll();
      });
    },
    reloadData: function reloadData(datas) {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      internalData.isLoaded = false;
      $xeSelect.clearScroll();
      return $xeSelect.loadData(datas);
    },
    clearScroll: function clearScroll() {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var scrollBodyElem = $xeSelect.$refs.refVirtualWrapper;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return $xeSelect.$nextTick();
    },
    hasOptGroupById: function hasOptGroupById(optid) {
      var $xeSelect = this;
      var internalData = $xeSelect.internalData;
      var optGroupKeyMaps = internalData.optGroupKeyMaps;
      return !!optGroupKeyMaps[optid];
    },
    //
    // Render
    //
    renderOption: function renderOption(h, list, group) {
      var $xeSelect = this;
      var props = $xeSelect;
      var slots = $xeSelect.$scopedSlots;
      var reactData = $xeSelect.reactData;
      var internalData = $xeSelect.internalData;
      var allowCreate = props.allowCreate,
        optionKey = props.optionKey,
        value = props.value;
      var currentOption = reactData.currentOption;
      var optAddMaps = internalData.optAddMaps;
      var optionOpts = $xeSelect.computeOptionOpts;
      var labelField = $xeSelect.computeLabelField;
      var valueField = $xeSelect.computeValueField;
      var groupLabelField = $xeSelect.computeGroupLabelField;
      var useKey = optionOpts.useKey;
      var optionSlot = slots.option;
      return list.map(function (option, cIndex) {
        var slots = option.slots,
          className = option.className;
        var optid = $xeSelect.getOptId(option);
        var optionValue = option[valueField];
        var isOptGroup = $xeSelect.hasOptGroupById(optid);
        var isAdd = !!(allowCreate && optAddMaps[optid]);
        var isSelected = !isAdd && (_xeUtils.default.isArray(value) ? value.indexOf(optionValue) > -1 : value === optionValue);
        var isVisible = isAdd || !isOptGroup || isOptionVisible(option);
        var isDisabled = !isAdd && $xeSelect.checkOptionDisabled(isSelected, option, group);
        var defaultSlot = slots ? slots.default : null;
        var optParams = {
          option: option,
          group: null,
          $select: $xeSelect
        };
        var optVNs = optionSlot ? $xeSelect.callSlot(optionSlot, optParams, h) : defaultSlot ? $xeSelect.callSlot(defaultSlot, optParams, h) : (0, _utils.getFuncText)(option[isOptGroup ? groupLabelField : labelField]);
        return isVisible ? h('div', {
          key: useKey || optionKey ? optid : cIndex,
          class: ['vxe-select-option', className ? _xeUtils.default.isFunction(className) ? className(optParams) : className : '', {
            'vxe-select-optgroup': isOptGroup,
            'is--disabled': isDisabled,
            'is--selected': isSelected,
            'is--add': isAdd,
            'is--hover': currentOption && $xeSelect.getOptId(currentOption) === optid
          }],
          attrs: {
            optid: optid
          },
          on: {
            mousedown: function mousedown(evnt) {
              var isLeftBtn = evnt.button === 0;
              if (isLeftBtn) {
                evnt.stopPropagation();
              }
            },
            click: function click(evnt) {
              if (!isDisabled && !isOptGroup) {
                $xeSelect.changeOptionEvent(evnt, option);
              }
            },
            mouseenter: function mouseenter() {
              if (!isDisabled && !isOptGroup && !$xeSelect.isVMScrollProcess()) {
                $xeSelect.setCurrentOption(option);
              }
            }
          }
        }, allowCreate ? [h('span', {
          key: 1,
          class: 'vxe-select-option--label'
        }, optVNs), isAdd ? h('span', {
          key: 2,
          class: 'vxe-select-option--add-icon'
        }, [h('i', {
          class: (0, _ui.getIcon)().ADD_OPTION
        })]) : (0, _ui.renderEmptyElement)($xeSelect)] : optVNs) : (0, _ui.renderEmptyElement)($xeSelect);
      });
    },
    renderOpts: function renderOpts(h) {
      var $xeSelect = this;
      var props = $xeSelect;
      var reactData = $xeSelect.reactData;
      var optList = reactData.optList,
        searchLoading = reactData.searchLoading;
      if (searchLoading) {
        return [h('div', {
          class: 'vxe-select--search-loading'
        }, [h('i', {
          class: ['vxe-select--search-icon', (0, _ui.getIcon)().SELECT_LOADED]
        }), h('span', {
          class: 'vxe-select--search-text'
        }, (0, _ui.getI18n)('vxe.select.loadingText'))])];
      }
      if (optList.length) {
        return $xeSelect.renderOption(h, optList);
      }
      return [h('div', {
        class: 'vxe-select--empty-placeholder'
      }, props.emptyText || (0, _ui.getI18n)('vxe.select.emptyText'))];
    },
    renderVN: function renderVN(h) {
      var $xeSelect = this;
      var props = $xeSelect;
      var slots = $xeSelect.$scopedSlots;
      var reactData = $xeSelect.reactData;
      var className = props.className,
        popupClassName = props.popupClassName,
        loading = props.loading,
        filterable = props.filterable;
      var initialized = reactData.initialized,
        isActivated = reactData.isActivated,
        isAniVisible = reactData.isAniVisible,
        visiblePanel = reactData.visiblePanel,
        bodyHeight = reactData.bodyHeight,
        topSpaceHeight = reactData.topSpaceHeight;
      var vSize = $xeSelect.computeSize;
      var isDisabled = $xeSelect.computeIsDisabled;
      var selectLabel = $xeSelect.computeSelectLabel;
      var btnTransfer = $xeSelect.computeBtnTransfer;
      var formReadonly = $xeSelect.computeFormReadonly;
      var inpPlaceholder = $xeSelect.computeInpPlaceholder;
      var defaultSlot = slots.default;
      var headerSlot = slots.header;
      var footerSlot = slots.footer;
      var prefixSlot = slots.prefix;
      if (formReadonly) {
        return h('div', {
          ref: 'refElem',
          class: ['vxe-select--readonly', className]
        }, [h('div', {
          class: 'vxe-select-slots',
          ref: 'hideOption'
        }, defaultSlot ? $xeSelect.callSlot(defaultSlot, {}, h) : []), h('span', {
          class: 'vxe-select-label'
        }, selectLabel)]);
      }
      return h('div', {
        ref: 'refElem',
        class: ['vxe-select', className ? _xeUtils.default.isFunction(className) ? className({
          $select: $xeSelect
        }) : className : '', _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--visible', visiblePanel), 'is--disabled', isDisabled), 'is--filter', filterable), 'is--loading', loading), 'is--active', isActivated)]
      }, [h('div', {
        class: 'vxe-select-slots',
        ref: 'hideOption'
      }, defaultSlot ? defaultSlot.call($xeSelect, {}) : []), h(_input.default, {
        ref: 'refInput',
        props: {
          clearable: props.clearable,
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          type: 'text',
          prefixIcon: props.prefixIcon,
          suffixIcon: loading ? (0, _ui.getIcon)().SELECT_LOADED : visiblePanel ? (0, _ui.getIcon)().SELECT_OPEN : (0, _ui.getIcon)().SELECT_CLOSE,
          autoFocus: false,
          value: selectLabel
        },
        on: {
          clear: $xeSelect.clearEvent,
          click: $xeSelect.clickEvent,
          focus: $xeSelect.focusEvent,
          blur: $xeSelect.blurEvent,
          'suffix-click': $xeSelect.suffixClickEvent
        },
        scopedSlots: prefixSlot ? {
          prefix: function prefix() {
            return prefixSlot({});
          }
        } : {}
      }), h('div', {
        ref: 'refOptionPanel',
        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? _xeUtils.default.isFunction(popupClassName) ? popupClassName({
          $select: $xeSelect
        }) : popupClassName : '', _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "size--".concat(vSize), vSize), 'is--transfer', btnTransfer), 'ani--leave', !loading && isAniVisible), 'ani--enter', !loading && visiblePanel)],
        attrs: {
          placement: reactData.panelPlacement
        },
        style: reactData.panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [h('div', {
        class: 'vxe-select--panel-wrapper'
      }, [filterable ? h('div', {
        class: 'vxe-select--panel-search'
      }, [h(_input.default, {
        ref: 'refInpSearch',
        class: 'vxe-select-search--input',
        props: {
          value: reactData.searchValue,
          clearable: true,
          disabled: false,
          readonly: false,
          placeholder: (0, _ui.getI18n)('vxe.select.search'),
          prefixIcon: (0, _ui.getIcon)().INPUT_SEARCH
        },
        on: {
          'model-value': $xeSelect.modelSearchEvent,
          focus: $xeSelect.focusSearchEvent,
          change: $xeSelect.triggerSearchEvent,
          search: $xeSelect.triggerSearchEvent
        }
      })]) : (0, _ui.renderEmptyElement)($xeSelect), headerSlot ? h('div', {
        class: 'vxe-select--panel-header'
      }, $xeSelect.callSlot(headerSlot, {}, h)) : (0, _ui.renderEmptyElement)($xeSelect), h('div', {
        class: 'vxe-select--panel-body'
      }, [h('div', {
        ref: 'refVirtualWrapper',
        class: 'vxe-select-option--wrapper',
        on: {
          scroll: $xeSelect.scrollEvent
        }
      }, [h('div', {
        class: 'vxe-select--y-space',
        style: {
          height: bodyHeight ? "".concat(bodyHeight, "px") : ''
        }
      }), h('div', {
        ref: 'refVirtualBody',
        class: 'vxe-select--body',
        style: {
          marginTop: topSpaceHeight ? "".concat(topSpaceHeight, "px") : ''
        }
      }, $xeSelect.renderOpts(h))])]), footerSlot ? h('div', {
        class: 'vxe-select--panel-footer'
      }, $xeSelect.callSlot(footerSlot, {}, h)) : (0, _ui.renderEmptyElement)($xeSelect)])] : [])]);
    }
  },
  watch: {
    'reactData.staticOptions': function reactDataStaticOptions(val) {
      var $xeSelect = this;
      $xeSelect.loadData(val);
    },
    options: function options(val) {
      var $xeSelect = this;
      $xeSelect.loadData(val);
    },
    optionGroups: function optionGroups(val) {
      var $xeSelect = this;
      $xeSelect.loadData(val);
    }
  },
  mounted: function mounted() {
    var $xeSelect = this;
    var props = $xeSelect;
    $xeSelect.$nextTick(function () {
      var options = props.options,
        optionGroups = props.optionGroups;
      if (optionGroups) {
        $xeSelect.loadData(optionGroups);
      } else if (options) {
        $xeSelect.loadData(options);
      }
    });
    _ui.globalEvents.on($xeSelect, 'mousewheel', $xeSelect.handleGlobalMousewheelEvent);
    _ui.globalEvents.on($xeSelect, 'mousedown', $xeSelect.handleGlobalMousedownEvent);
    _ui.globalEvents.on($xeSelect, 'keydown', $xeSelect.handleGlobalKeydownEvent);
    _ui.globalEvents.on($xeSelect, 'blur', $xeSelect.handleGlobalBlurEvent);
  },
  beforeDestroy: function beforeDestroy() {
    var $xeSelect = this;
    var panelElem = $xeSelect.$refs.refOptionPanel;
    if (panelElem && panelElem.parentNode) {
      panelElem.parentNode.removeChild(panelElem);
    }
    _ui.globalEvents.off($xeSelect, 'mousewheel');
    _ui.globalEvents.off($xeSelect, 'mousedown');
    _ui.globalEvents.off($xeSelect, 'keydown');
    _ui.globalEvents.off($xeSelect, 'blur');
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */