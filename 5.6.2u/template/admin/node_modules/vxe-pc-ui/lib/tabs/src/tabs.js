"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comp = require("../../ui/src/comp");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _vn = require("../../ui/src/vn");
var _dom = require("../../ui/src/dom");
var _utils = require("../../ui/src/utils");
var _log = require("../../ui/src/log");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default2 = exports.default = /* define-vxe-component start */(0, _comp.defineVxeComponent)({
  name: 'VxeTabs',
  props: {
    value: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: function _default() {
        return (0, _ui.getConfig)().tabs.padding;
      }
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 已废弃
    beforeCloseMethod: Function
  },
  inject: {
    $xeParentTabs: {
      from: '$xeTabs',
      default: null
    }
  },
  provide: function provide() {
    var $xeTabs = this;
    return {
      $xeTabs: $xeTabs
    };
  },
  data: function data() {
    var xID = _xeUtils.default.uniqueId();
    var reactData = {
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    };
    var internalData = {
      slTimeout: undefined
    };
    return {
      xID: xID,
      reactData: reactData,
      internalData: internalData
    };
  },
  computed: Object.assign(Object.assign({}, {}), {
    computeParentResizeFlag: function computeParentResizeFlag() {
      var $xeTabs = this;
      var $xeParentTabs = $xeTabs.$xeParentTabs;
      return $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null;
    },
    computeCloseOpts: function computeCloseOpts() {
      var $xeTabs = this;
      var props = $xeTabs;
      return Object.assign({}, (0, _ui.getConfig)().tabs.closeConfig, props.closeConfig);
    },
    computeRefreshOpts: function computeRefreshOpts() {
      var $xeTabs = this;
      var props = $xeTabs;
      return Object.assign({}, (0, _ui.getConfig)().tabs.refreshConfig, props.refreshConfig);
    },
    computeTabOptions: function computeTabOptions() {
      var $xeTabs = this;
      var props = $xeTabs;
      var options = props.options;
      return (options || []).filter(function (item) {
        return $xeTabs.handleFilterTab(item);
      });
    },
    computeTabStaticOptions: function computeTabStaticOptions() {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      var staticTabs = reactData.staticTabs;
      return staticTabs.filter(function (item) {
        return $xeTabs.handleFilterTab(item);
      });
    }
  }),
  methods: {
    //
    // Method
    //
    dispatchEvent: function dispatchEvent(type, params, evnt) {
      var $xeTabs = this;
      $xeTabs.$emit(type, (0, _ui.createEvent)(evnt, {
        $tabs: $xeTabs
      }, params));
    },
    emitModel: function emitModel(value) {
      var $xeTabs = this;
      var _events = $xeTabs._events;
      $xeTabs.$emit('input', value);
      if (_events && _events.modelValue) {
        $xeTabs.$emit('modelValue', value);
      } else {
        $xeTabs.$emit('model-value', value);
      }
    },
    prev: function prev() {
      var $xeTabs = this;
      return $xeTabs.handlePrevNext(false);
    },
    next: function next() {
      var $xeTabs = this;
      return $xeTabs.handlePrevNext(true);
    },
    prevTab: function prevTab() {
      var $xeTabs = this;
      (0, _log.warnLog)('vxe.error.delFunc', ['prevTab', 'prev']);
      return $xeTabs.prev();
    },
    nextTab: function nextTab() {
      var $xeTabs = this;
      (0, _log.warnLog)('vxe.error.delFunc', ['nextTab', 'next']);
      return $xeTabs.next();
    },
    handleFilterTab: function handleFilterTab(item) {
      var permissionCode = item.permissionCode;
      if (permissionCode) {
        if (!_ui.permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    },
    callSlot: function callSlot(slotFunc, params, h) {
      var $xeTabs = this;
      var slots = $xeTabs.$scopedSlots;
      if (slotFunc) {
        if (_xeUtils.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (_xeUtils.default.isFunction(slotFunc)) {
          return (0, _vn.getSlotVNs)(slotFunc.call($xeTabs, params, h));
        }
      }
      return [];
    },
    updateTabStyle: function updateTabStyle() {
      var $xeTabs = this;
      var props = $xeTabs;
      var reactData = $xeTabs.reactData;
      $xeTabs.$nextTick(function () {
        var type = props.type;
        var activeName = reactData.activeName;
        var tabOptions = $xeTabs.computeTabOptions;
        var tabStaticOptions = $xeTabs.computeTabStaticOptions;
        var headerWrapperEl = $xeTabs.$refs.refHeadWrapperElem;
        var lintWidth = 0;
        var lintLeft = 0;
        var isOver = false;
        if (headerWrapperEl) {
          var index = _xeUtils.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, function (item) {
            return item.name === activeName;
          });
          var children = headerWrapperEl.children,
            scrollWidth = headerWrapperEl.scrollWidth,
            clientWidth = headerWrapperEl.clientWidth;
          isOver = scrollWidth !== clientWidth;
          if (index > -1) {
            var tabEl = children[index];
            var tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === 'card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === 'border-card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    },
    addInitName: function addInitName(name, evnt) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      var initNames = reactData.initNames;
      if (name && !initNames.includes(name)) {
        $xeTabs.dispatchEvent('tab-load', {
          name: name
        }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    },
    initDefaultName: function initDefaultName(list) {
      var $xeTabs = this;
      var props = $xeTabs;
      var reactData = $xeTabs.reactData;
      var activeName = null;
      var nameMaps = {};
      if (list && list.length) {
        var validVal = false;
        activeName = props.value;
        list.forEach(function (item) {
          var _ref = item || {},
            name = _ref.name,
            preload = _ref.preload;
          if (name) {
            nameMaps["".concat(name)] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              $xeTabs.addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          $xeTabs.addInitName(activeName, null);
          $xeTabs.emitModel(activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    },
    clickEvent: function clickEvent(evnt, item) {
      var $xeTabs = this;
      var props = $xeTabs;
      var reactData = $xeTabs.reactData;
      var trigger = props.trigger;
      var beforeMethod = props.beforeChangeMethod || (0, _ui.getConfig)().tabs.beforeChangeMethod;
      var activeName = reactData.activeName;
      var name = item.name;
      var value = name;
      $xeTabs.dispatchEvent('tab-click', {
        name: name
      }, evnt);
      if (trigger === 'manual') {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({
          $tabs: $xeTabs,
          name: name,
          oldName: activeName,
          newName: name,
          option: item
        })).then(function (status) {
          if (status) {
            reactData.activeName = name;
            $xeTabs.emitModel(value);
            $xeTabs.addInitName(name, evnt);
            $xeTabs.dispatchEvent('change', {
              value: value,
              name: name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
            $xeTabs.dispatchEvent('tab-change', {
              value: value,
              name: name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          } else {
            $xeTabs.dispatchEvent('tab-change-fail', {
              value: value,
              name: name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          }
        }).catch(function () {
          $xeTabs.dispatchEvent('tab-change-fail', {
            value: value,
            name: name,
            oldName: activeName,
            newName: name,
            option: item
          }, evnt);
        });
      }
    },
    handleRefreshTabEvent: function handleRefreshTabEvent(evnt, item) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      evnt.stopPropagation();
      var activeName = reactData.activeName,
        cacheTabMaps = reactData.cacheTabMaps;
      var name = item.name;
      var refreshOpts = $xeTabs.computeRefreshOpts;
      var queryMethod = refreshOpts.queryMethod;
      var cacheItem = name ? cacheTabMaps["".concat(name)] : null;
      if (cacheItem) {
        if (queryMethod) {
          cacheItem.loading = true;
          Promise.resolve(queryMethod({
            $tabs: $xeTabs,
            value: activeName,
            name: name,
            option: item
          })).finally(function () {
            cacheItem.loading = false;
          });
        } else {
          (0, _log.errLog)('vxe.error.notFunc', ['refresh-config.queryMethod']);
        }
      }
    },
    handleCloseTabEvent: function handleCloseTabEvent(evnt, item, index, list) {
      var $xeTabs = this;
      var props = $xeTabs;
      var reactData = $xeTabs.reactData;
      evnt.stopPropagation();
      var activeName = reactData.activeName;
      var closeOpts = $xeTabs.computeCloseOpts;
      var beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || (0, _ui.getConfig)().tabs.beforeCloseMethod;
      var name = item.name;
      var value = activeName;
      var nextName = value;
      if (activeName === name) {
        var nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({
        $tabs: $xeTabs,
        value: value,
        name: name,
        nextName: nextName,
        option: item
      })).then(function (status) {
        if (status) {
          $xeTabs.dispatchEvent('tab-close', {
            value: value,
            name: name,
            nextName: nextName
          }, evnt);
        } else {
          $xeTabs.dispatchEvent('tab-close-fail', {
            value: value,
            name: name,
            nextName: nextName
          }, evnt);
        }
      }).catch(function () {
        $xeTabs.dispatchEvent('tab-close-fail', {
          value: value,
          name: name,
          nextName: nextName
        }, evnt);
      });
    },
    startScrollAnimation: function startScrollAnimation(offsetPos, offsetSize) {
      var $xeTabs = this;
      var internalData = $xeTabs.internalData;
      var slTimeout = internalData.slTimeout;
      var offsetLeft = offsetSize;
      var scrollCount = 6;
      var delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = undefined;
      }
      var _scrollAnimate = function scrollAnimate() {
        var headerWrapperEl = $xeTabs.$refs.refHeadWrapperElem;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            var clientWidth = headerWrapperEl.clientWidth,
              scrollWidth = headerWrapperEl.scrollWidth,
              scrollLeft = headerWrapperEl.scrollLeft;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(_scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(_scrollAnimate, delayNum);
              }
            }
            $xeTabs.updateTabStyle();
          }
        }
      };
      _scrollAnimate();
    },
    handleScrollToLeft: function handleScrollToLeft(offsetPos) {
      var $xeTabs = this;
      var headerWrapperEl = $xeTabs.$refs.refHeadWrapperElem;
      if (headerWrapperEl) {
        var offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        $xeTabs.startScrollAnimation(offsetPos, offsetSize);
      }
    },
    scrollLeftEvent: function scrollLeftEvent() {
      var $xeTabs = this;
      $xeTabs.handleScrollToLeft(-1);
    },
    scrollRightEvent: function scrollRightEvent() {
      var $xeTabs = this;
      $xeTabs.handleScrollToLeft(1);
    },
    scrollToTab: function scrollToTab(name) {
      var $xeTabs = this;
      var tabOptions = $xeTabs.computeTabOptions;
      var tabStaticOptions = $xeTabs.computeTabStaticOptions;
      return $xeTabs.$nextTick().then(function () {
        var headerWrapperEl = $xeTabs.$refs.refHeadWrapperElem;
        if (headerWrapperEl) {
          var index = _xeUtils.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, function (item) {
            return item.name === name;
          });
          if (index > -1) {
            var scrollLeft = headerWrapperEl.scrollLeft,
              clientWidth = headerWrapperEl.clientWidth,
              children = headerWrapperEl.children;
            var tabEl = children[index];
            if (tabEl) {
              var tabOffsetLeft = tabEl.offsetLeft;
              var tabClientWidth = tabEl.clientWidth;
              // 如果右侧被挡
              var overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              // 如果左侧被挡，优先
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          $xeTabs.updateTabStyle();
        }
      });
    },
    handlePrevNext: function handlePrevNext(isNext) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      var activeName = reactData.activeName;
      var tabOptions = $xeTabs.computeTabOptions;
      var tabStaticOptions = $xeTabs.computeTabStaticOptions;
      var list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      var index = _xeUtils.default.findIndexOf(list, function (item) {
        return item.name === activeName;
      });
      if (index > -1) {
        var item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          }
        }
        if (item) {
          var name = item.name;
          var value = name;
          reactData.activeName = name;
          $xeTabs.emitModel(value);
          $xeTabs.addInitName(name, null);
        }
      }
      return $xeTabs.$nextTick();
    },
    //
    // Render
    //
    renderTabHeader: function renderTabHeader(h, tabList) {
      var $xeTabs = this;
      var props = $xeTabs;
      var slots = $xeTabs.$scopedSlots;
      var reactData = $xeTabs.reactData;
      var type = props.type,
        allTitleWidth = props.titleWidth,
        allTitleAlign = props.titleAlign,
        showClose = props.showClose,
        closeConfig = props.closeConfig,
        refreshConfig = props.refreshConfig;
      var activeName = reactData.activeName,
        lintLeft = reactData.lintLeft,
        lintWidth = reactData.lintWidth,
        isTabOver = reactData.isTabOver,
        cacheTabMaps = reactData.cacheTabMaps;
      var extraSlot = slots.extra;
      var closeOpts = $xeTabs.computeCloseOpts;
      var closeVisibleMethod = closeOpts.visibleMethod;
      var refreshOpts = $xeTabs.computeRefreshOpts;
      var refreshVisibleMethod = refreshOpts.visibleMethod;
      return h('div', {
        class: 'vxe-tabs-header'
      }, [isTabOver ? h('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--left-bar',
        on: {
          click: $xeTabs.scrollLeftEvent
        }
      }, [h('span', {
        class: (0, _ui.getIcon)().TABS_TAB_BUTTON_LEFT
      })]) : (0, _ui.renderEmptyElement)($xeTabs), h('div', {
        class: 'vxe-tabs-header--wrapper'
      }, [h('div', {
        ref: 'refHeadWrapperElem',
        class: 'vxe-tabs-header--item-wrapper'
      }, tabList.map(function (item, index) {
        var title = item.title,
          titleWidth = item.titleWidth,
          titleAlign = item.titleAlign,
          icon = item.icon,
          name = item.name,
          slots = item.slots;
        var titleSlot = slots ? slots.title || slots.tab : null;
        var itemWidth = titleWidth || allTitleWidth;
        var itemAlign = titleAlign || allTitleAlign;
        var params = {
          $tabs: $xeTabs,
          value: activeName,
          name: name,
          option: item
        };
        var isActive = activeName === name;
        var cacheItem = name ? cacheTabMaps["".concat(name)] : null;
        var isLoading = cacheItem ? cacheItem.loading : false;
        return h('div', {
          key: "".concat(name),
          class: ['vxe-tabs-header--item', itemAlign ? "align--".concat(itemAlign) : '', {
            'is--active': isActive
          }],
          style: itemWidth ? {
            width: (0, _dom.toCssUnit)(itemWidth)
          } : {},
          on: {
            click: function click(evnt) {
              $xeTabs.clickEvent(evnt, item);
            }
          }
        }, [h('div', {
          class: 'vxe-tabs-header--item-inner'
        }, [h('div', {
          class: 'vxe-tabs-header--item-content'
        }, [icon ? h('span', {
          class: 'vxe-tabs-header--item-icon'
        }, [h('i', {
          class: icon
        })]) : (0, _ui.renderEmptyElement)($xeTabs), h('span', {
          class: 'vxe-tabs-header--item-name'
        }, titleSlot ? $xeTabs.callSlot(titleSlot, {
          name: name,
          title: title
        }, h) : "".concat(title))]), ((0, _utils.isEnableConf)(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : isActive) ? h('div', {
          class: 'vxe-tabs-header--refresh-btn',
          on: {
            click: function click(evnt) {
              $xeTabs.handleRefreshTabEvent(evnt, item);
            }
          }
        }, [h('i', {
          class: isLoading ? (0, _ui.getIcon)().TABS_TAB_REFRESH_LOADING : (0, _ui.getIcon)().TABS_TAB_REFRESH
        })]) : (0, _ui.renderEmptyElement)($xeTabs), (showClose || (0, _utils.isEnableConf)(closeConfig) || closeOpts.enabled) && (!closeVisibleMethod || closeVisibleMethod(params)) ? h('div', {
          class: 'vxe-tabs-header--close-btn',
          on: {
            click: function click(evnt) {
              $xeTabs.handleCloseTabEvent(evnt, item, index, tabList);
            }
          }
        }, [h('i', {
          class: (0, _ui.getIcon)().TABS_TAB_CLOSE
        })]) : (0, _ui.renderEmptyElement)($xeTabs)])]);
      }).concat([h('span', {
        key: 'line',
        class: "vxe-tabs-header--active-line type--".concat(type || 'default'),
        style: {
          left: "".concat(lintLeft, "px"),
          width: "".concat(lintWidth, "px")
        }
      })]))]), isTabOver ? h('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--right-bar',
        on: {
          click: $xeTabs.scrollRightEvent
        }
      }, [h('span', {
        class: (0, _ui.getIcon)().TABS_TAB_BUTTON_RIGHT
      })]) : (0, _ui.renderEmptyElement)($xeTabs), extraSlot ? h('div', {
        class: 'vxe-tabs-header--extra'
      }, $xeTabs.callSlot(extraSlot, {}, h)) : (0, _ui.renderEmptyElement)($xeTabs)]);
    },
    renderTabPane: function renderTabPane(h, item) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      var initNames = reactData.initNames,
        activeName = reactData.activeName;
      var name = item.name,
        slots = item.slots;
      var defaultSlot = slots ? slots.default : null;
      return name && initNames.includes(name) ? h('div', {
        key: "".concat(name),
        class: ['vxe-tabs-pane--item', {
          'is--visible': activeName === name,
          'has--content': !!defaultSlot
        }]
      }, defaultSlot ? $xeTabs.callSlot(defaultSlot, {
        name: name
      }, h) : []) : (0, _ui.renderEmptyElement)($xeTabs);
    },
    renderTabContent: function renderTabContent(h, tabList) {
      var $xeTabs = this;
      var props = $xeTabs;
      var reactData = $xeTabs.reactData;
      var destroyOnClose = props.destroyOnClose;
      var activeName = reactData.activeName;
      var activeDefaultTab = tabList.find(function (item) {
        return item.name === activeName;
      });
      if (destroyOnClose) {
        return [activeDefaultTab ? $xeTabs.renderTabPane(h, activeDefaultTab) : (0, _ui.renderEmptyElement)($xeTabs)];
      }
      return tabList.map(function (item) {
        return $xeTabs.renderTabPane(h, item);
      });
    },
    renderVN: function renderVN(h) {
      var $xeTabs = this;
      var props = $xeTabs;
      var slots = $xeTabs.$scopedSlots;
      var type = props.type,
        height = props.height,
        padding = props.padding,
        trigger = props.trigger;
      var tabOptions = $xeTabs.computeTabOptions;
      var tabStaticOptions = $xeTabs.computeTabStaticOptions;
      var defaultSlot = slots.default;
      var footerSlot = slots.footer;
      var tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return h('div', {
        ref: 'refElem',
        class: ['vxe-tabs', "vxe-tabs--".concat(type || 'default'), "trigger--".concat(trigger === 'manual' ? 'trigger' : 'default'), {
          'is--padding': padding,
          'is--height': height
        }],
        style: height ? {
          height: (0, _dom.toCssUnit)(height)
        } : {}
      }, [h('div', {
        class: 'vxe-tabs-slots'
      }, defaultSlot ? $xeTabs.callSlot(defaultSlot, {}, h) : []), $xeTabs.renderTabHeader(h, tabList), h('div', {
        class: 'vxe-tabs-pane'
      }, $xeTabs.renderTabContent(h, tabList)), footerSlot ? h('div', {
        class: 'vxe-tabs-footer'
      }, $xeTabs.callSlot(footerSlot, {}, h)) : (0, _ui.renderEmptyElement)($xeTabs)]);
    }
  },
  watch: {
    value: function value(val) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      $xeTabs.addInitName(val, null);
      reactData.activeName = val;
    },
    'reactData.activeName': function reactDataActiveName(val) {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      $xeTabs.scrollToTab(val);
      $xeTabs.$nextTick(function () {
        reactData.resizeFlag++;
      });
    },
    options: function options() {
      var $xeTabs = this;
      var props = $xeTabs;
      $xeTabs.initDefaultName(props.options);
      $xeTabs.updateTabStyle();
    },
    'reactData.staticTabs': function reactDataStaticTabs() {
      var $xeTabs = this;
      var reactData = $xeTabs.reactData;
      $xeTabs.initDefaultName(reactData.staticTabs);
      $xeTabs.updateTabStyle();
    },
    computeParentResizeFlag: function computeParentResizeFlag() {
      var $xeTabs = this;
      $xeTabs.$nextTick(function () {
        $xeTabs.updateTabStyle();
      });
    }
  },
  created: function created() {
    var $xeTabs = this;
    var props = $xeTabs;
    var reactData = $xeTabs.reactData;
    $xeTabs.addInitName(props.value, null);
    $xeTabs.initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
  },
  mounted: function mounted() {
    var $xeTabs = this;
    $xeTabs.updateTabStyle();
    _ui.globalEvents.on($xeTabs, 'resize', $xeTabs.updateTabStyle);
  },
  beforeDestroy: function beforeDestroy() {
    var $xeTabs = this;
    _ui.globalEvents.off($xeTabs, 'resize');
  },
  render: function render(h) {
    return this.renderVN(h);
  }
});
/* define-vxe-component end */