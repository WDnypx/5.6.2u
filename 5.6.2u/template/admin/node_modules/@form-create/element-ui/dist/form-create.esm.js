/*!
 * FormCreate 低代码表单渲染器
 * @form-create/element-ui v2.6.3
 * (c) 2018-2024 xaboy
 * Github https://github.com/xaboy/form-create
 * Site https://form-create.com/
 * Released under the MIT License.
 */
(function(){"use strict";try{if(typeof document!="undefined"){var o=document.createElement("style");o.appendChild(document.createTextNode('._fc-frame .fc-files img{width:100%;height:100%;display:inline-block;vertical-align:top}._fc-frame .fc-upload-btn{border:1px dashed #c0ccda;cursor:pointer}._fc-frame .fc-upload-cover{opacity:0;position:absolute;inset:0;background:#0009;-webkit-transition:opacity .3s;-o-transition:opacity .3s;transition:opacity .3s}._fc-frame .fc-upload-cover i{color:#fff;font-size:20px;cursor:pointer;margin:0 2px}._fc-frame .fc-files:hover .fc-upload-cover{opacity:1}._fc-frame .el-upload{display:block}._fc-frame .fc-upload-btn,.fc-files{display:inline-block;width:58px;height:58px;text-align:center;line-height:58px;border:1px solid #c0ccda;border-radius:4px;overflow:hidden;background:#fff;position:relative;-webkit-box-shadow:2px 2px 5px rgba(0,0,0,.1);box-shadow:2px 2px 5px #0000001a;margin-right:4px;-webkit-box-sizing:border-box;box-sizing:border-box}._fc-upload .fc-files img{width:100%;height:100%;display:inline-block;vertical-align:top}._fc-upload .fc-upload-btn{border:1px dashed #c0ccda;cursor:pointer}._fc-upload .fc-upload-cover{opacity:0;position:absolute;inset:0;background:#0009;-webkit-transition:opacity .3s;-o-transition:opacity .3s;transition:opacity .3s}._fc-upload .fc-upload-cover i{color:#fff;font-size:20px;cursor:pointer;margin:0 2px}._fc-upload .fc-files:hover .fc-upload-cover{opacity:1}._fc-upload .el-upload{display:block}._fc-upload .fc-upload-btn,._fc-upload .fc-files{display:inline-block;width:58px;height:58px;text-align:center;line-height:58px;border:1px solid #c0ccda;border-radius:4px;overflow:hidden;background:#fff;position:relative;-webkit-box-shadow:2px 2px 5px rgba(0,0,0,.1);box-shadow:2px 2px 5px #0000001a;margin-right:4px;-webkit-box-sizing:border-box;box-sizing:border-box}._fc-group{display:flex;min-height:42px;justify-content:center;flex-direction:column}._fc-group-disabled ._fc-group-btn,._fc-group-disabled ._fc-group-add{cursor:not-allowed}._fc-group-handle{display:flex;flex-direction:row;position:absolute;bottom:-15px;right:30px;border-radius:15px;border:1px dashed #d9d9d9;padding:3px 8px;background-color:#fff}._fc-group-btn{cursor:pointer}._fc-group-idx{position:absolute;bottom:-15px;left:10px;width:30px;height:30px;display:flex;align-items:center;justify-content:center;background:#eee;border-radius:15px;font-weight:700}._fc-group-handle ._fc-group-btn+._fc-group-btn{margin-left:7px}._fc-group-container{position:relative;display:flex;flex-direction:column;border:1px dashed #d9d9d9;padding:20px 20px 25px;margin:5px 5px 25px;border-radius:5px}._fc-group-arrow{position:relative;width:20px;height:20px}._fc-group-arrow:before{content:"";position:absolute;top:8px;left:5px;width:9px;height:9px;border-left:2px solid #999;border-top:2px solid #999}._fc-group-arrow:before{transform:rotate(45deg)}._fc-group-arrow._fc-group-down{transform:rotate(180deg)}._fc-group-plus-minus{width:20px;height:20px;position:relative;cursor:pointer}._fc-group-plus-minus:before,._fc-group-plus-minus:after{content:"";position:absolute;top:50%;left:50%;width:60%;height:2px;background-color:#409eff;transform:translate(-50%,-50%)}._fc-group-plus-minus:before{transform:translate(-50%,-50%) rotate(90deg)}._fc-group-plus-minus._fc-group-minus:before{display:none}._fc-group-plus-minus._fc-group-minus:after{background-color:#f56c6c}._fc-group-add{cursor:pointer;width:25px;height:25px;border:1px solid rgb(64 158 255 / 50%);border-radius:15px}._fc-group-add._fc-group-plus-minus:before,._fc-group-add._fc-group-plus-minus:after{width:50%}.form-create .form-create .el-form-item{margin-bottom:22px}.form-create .form-create .el-form-item .el-form-item{margin-bottom:0}')),document.head.appendChild(o)}}catch(r){console.error("vite-plugin-css-injected-by-js",r)}})();
var pt = Object.defineProperty, mt = Object.defineProperties;
var yt = Object.getOwnPropertyDescriptors;
var Ee = Object.getOwnPropertySymbols;
var gt = Object.prototype.hasOwnProperty, $t = Object.prototype.propertyIsEnumerable;
var Se = (t, e, r) => e in t ? pt(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, y = (t, e) => {
  for (var r in e || (e = {}))
    gt.call(e, r) && Se(t, r, e[r]);
  if (Ee)
    for (var r of Ee(e))
      $t.call(e, r) && Se(t, r, e[r]);
  return t;
}, N = (t, e) => mt(t, yt(e));
import T from "vue";
function vt(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function ae() {
  return ae = Object.assign ? Object.assign.bind() : function(t) {
    for (var e, r = 1; r < arguments.length; r++) for (var i in e = arguments[r], e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    return t;
  }, ae.apply(this, arguments);
}
var bt = ["attrs", "props", "domProps"], Ct = ["class", "style", "directives"], _t = ["on", "nativeOn"], Ot = function(t) {
  return t.reduce(function(e, r) {
    for (var i in r) if (!e[i]) e[i] = r[i];
    else if (bt.indexOf(i) !== -1) e[i] = ae({}, e[i], r[i]);
    else if (Ct.indexOf(i) !== -1) {
      var s = e[i] instanceof Array ? e[i] : [e[i]], n = r[i] instanceof Array ? r[i] : [r[i]];
      e[i] = [].concat(s, n);
    } else if (_t.indexOf(i) !== -1)
      for (var o in r[i]) if (e[i][o]) {
        var a = e[i][o] instanceof Array ? e[i][o] : [e[i][o]], u = r[i][o] instanceof Array ? r[i][o] : [r[i][o]];
        e[i][o] = [].concat(a, u);
      } else e[i][o] = r[i][o];
    else if (i === "hook") for (var l in r[i]) e[i][l] = e[i][l] ? kt(e[i][l], r[i][l]) : r[i][l];
    else e[i] = r[i];
    return e;
  }, {});
}, kt = function(t, e) {
  return function() {
    t && t.apply(this, arguments), e && e.apply(this, arguments);
  };
}, wt = Ot;
const F = /* @__PURE__ */ vt(wt);
function Y(t, e) {
  return Object.keys(t).reduce((r, i) => ((!e || e.indexOf(i) === -1) && r.push(t[i]), r), []);
}
const Ft = "fcCheckbox", Et = {
  name: Ft,
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    },
    value: {
      type: Array,
      default: () => []
    },
    type: String
  },
  watch: {
    "formCreateInject.options": {
      handler() {
        this.update();
      },
      deep: !0
    },
    value() {
      this.update();
    }
  },
  data() {
    return {
      trueValue: []
    };
  },
  methods: {
    options() {
      const t = this.formCreateInject.options;
      return Array.isArray(t) ? t : [];
    },
    onInput(t) {
      this.$emit("input", this.options().filter((e) => t.indexOf(e.label) !== -1).map((e) => e.value).filter((e) => e !== void 0));
    },
    update() {
      const t = Array.isArray(this.value) ? this.value : [this.value];
      this.trueValue = this.options().filter((e) => t.indexOf(e.value) !== -1).map((e) => e.label);
    }
  },
  created() {
    this.update();
  },
  render() {
    const t = arguments[0];
    return t("ElCheckboxGroup", F([{}, this.formCreateInject.prop, {}, {
      props: {
        value: this.trueValue
      }
    }, {
      ref: "el",
      on: {
        input: this.onInput
      }
    }]), [this.options().map((e, r) => {
      const i = y({}, e), s = this.type === "button" ? "ElCheckboxButton" : "ElCheckbox";
      return delete i.value, t(s, F([{}, {
        props: i
      }, {
        key: s + r + "-" + e.value
      }]));
    }), Y(this.$slots)]);
  },
  mounted() {
    this.$emit("fc.el", this.$refs.el);
  }
};
function j(t) {
  return Array.isArray(t) ? t : [null, void 0, ""].indexOf(t) > -1 ? [] : [t];
}
const St = "fcFrame", Rt = {
  name: St,
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    },
    type: {
      type: String,
      default: "input"
    },
    field: String,
    helper: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    src: {
      type: String,
      required: !0
    },
    icon: {
      type: String,
      default: "el-icon-upload2"
    },
    width: {
      type: String,
      default: "500px"
    },
    height: {
      type: String,
      default: "370px"
    },
    maxLength: {
      type: Number,
      default: 0
    },
    okBtnText: {
      type: String,
      default: "确定"
    },
    closeBtnText: {
      type: String,
      default: "关闭"
    },
    modalTitle: String,
    handleIcon: {
      type: [String, Boolean],
      default: void 0
    },
    title: String,
    allowRemove: {
      type: Boolean,
      default: !0
    },
    onOpen: {
      type: Function,
      default: () => {
      }
    },
    onOk: {
      type: Function,
      default: () => {
      }
    },
    onCancel: {
      type: Function,
      default: () => {
      }
    },
    onLoad: {
      type: Function,
      default: () => {
      }
    },
    onBeforeRemove: {
      type: Function,
      default: () => {
      }
    },
    onRemove: {
      type: Function,
      default: () => {
      }
    },
    onHandle: {
      type: Function,
      default(t) {
        this.previewImage = this.getSrc(t), this.previewVisible = !0;
      }
    },
    modal: {
      type: Object,
      default: () => ({})
    },
    srcKey: {
      type: [String, Number]
    },
    value: [Array, String, Number, Object],
    previewMask: void 0,
    footer: {
      type: Boolean,
      default: !0
    },
    reload: {
      type: Boolean,
      default: !0
    },
    closeBtn: {
      type: Boolean,
      default: !0
    },
    okBtn: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      fileList: j(this.value),
      previewVisible: !1,
      frameVisible: !1,
      previewImage: ""
    };
  },
  watch: {
    value(t) {
      this.fileList = j(t);
    },
    fileList(t) {
      const e = this.maxLength === 1 ? t[0] || "" : t;
      this.$emit("input", e), this.$emit("change", e);
    },
    src(t) {
      this.modalVm && (this.modalVm.src = t);
    }
  },
  methods: {
    key(t) {
      return t;
    },
    closeModel(t) {
      this.$emit(t ? "$close" : "$ok"), this.reload && (this.$off("$ok"), this.$off("$close")), this.frameVisible = !1;
    },
    handleCancel() {
      this.previewVisible = !1;
    },
    showModel() {
      this.disabled || this.onOpen() === !1 || (this.frameVisible = !0);
    },
    makeInput() {
      const t = this.$createElement, e = {
        type: "text",
        value: this.fileList.map((r) => this.getSrc(r)).toString(),
        readonly: !0
      };
      return t("ElInput", F([{}, {
        props: e
      }, {
        key: this.key("input")
      }]), [this.fileList.length ? t("i", {
        slot: "suffix",
        class: "el-input__icon el-icon-circle-close",
        on: {
          click: () => this.fileList = []
        }
      }) : null, t("ElButton", F([{
        attrs: {
          icon: this.icon
        }
      }, {
        on: {
          click: () => this.showModel()
        }
      }, {
        slot: "append"
      }]))]);
    },
    makeGroup(t) {
      const e = this.$createElement;
      return (!this.maxLength || this.fileList.length < this.maxLength) && t.push(this.makeBtn()), e("div", {
        key: this.key("group")
      }, [...t]);
    },
    makeItem(t, e) {
      const r = this.$createElement;
      return r("div", {
        class: "fc-files",
        key: this.key("file" + t)
      }, [...e]);
    },
    valid(t) {
      const e = this.formCreateInject.field || this.field;
      if (e && t !== e)
        throw new Error("[frame]无效的字段值");
    },
    makeIcons(t, e) {
      const r = this.$createElement;
      if (this.handleIcon !== !1 || this.allowRemove === !0) {
        const i = [];
        return (this.type !== "file" && this.handleIcon !== !1 || this.type === "file" && this.handleIcon) && i.push(this.makeHandleIcon(t, e)), this.allowRemove && i.push(this.makeRemoveIcon(t, e)), r("div", {
          class: "fc-upload-cover",
          key: this.key("uc")
        }, [i]);
      }
    },
    makeHandleIcon(t, e) {
      const r = this.$createElement;
      return r("i", {
        class: this.handleIcon === !0 || this.handleIcon === void 0 ? "el-icon-view" : this.handleIcon,
        on: {
          click: () => this.handleClick(t)
        },
        key: this.key("hi" + e)
      });
    },
    makeRemoveIcon(t, e) {
      const r = this.$createElement;
      return r("i", {
        class: "el-icon-delete",
        on: {
          click: () => this.handleRemove(t)
        },
        key: this.key("ri" + e)
      });
    },
    makeFiles() {
      const t = this.$createElement;
      return this.makeGroup(this.fileList.map((e, r) => this.makeItem(r, [t("i", {
        class: "el-icon-tickets",
        on: {
          click: () => this.handleClick(e)
        }
      }), this.makeIcons(e, r)])));
    },
    makeImages() {
      const t = this.$createElement;
      return this.makeGroup(this.fileList.map((e, r) => this.makeItem(r, [t("img", {
        attrs: {
          src: this.getSrc(e)
        }
      }), this.makeIcons(e, r)])));
    },
    makeBtn() {
      const t = this.$createElement;
      return t("div", {
        class: "fc-upload-btn",
        on: {
          click: () => this.showModel()
        },
        key: this.key("btn")
      }, [t("i", {
        class: this.icon
      })]);
    },
    handleClick(t) {
      return this.onHandle(t);
    },
    handleRemove(t) {
      this.disabled || this.onBeforeRemove(t) !== !1 && (this.fileList.splice(this.fileList.indexOf(t), 1), this.onRemove(t));
    },
    getSrc(t) {
      return this.srcKey ? t[this.srcKey] : t;
    },
    frameLoad(t) {
      this.onLoad(t);
      try {
        this.helper === !0 && (t.form_create_helper = {
          api: this.formCreateInject.api,
          close: (e) => {
            this.valid(e), this.closeModel();
          },
          set: (e, r) => {
            this.valid(e), this.disabled || this.$emit("input", r);
          },
          get: (e) => (this.valid(e), this.value),
          onOk: (e) => this.$on("$ok", e),
          onClose: (e) => this.$on("$close", e)
        });
      } catch (e) {
        console.log(e);
      }
    },
    makeFooter() {
      const t = this.$createElement, {
        okBtnText: e,
        closeBtnText: r,
        closeBtn: i,
        okBtn: s,
        footer: n
      } = this.$props;
      if (n)
        return t("div", {
          slot: "footer"
        }, [i ? t("ElButton", {
          on: {
            click: () => this.onCancel() !== !1 && (this.frameVisible = !1)
          }
        }, [r]) : null, s ? t("ElButton", {
          attrs: {
            type: "primary"
          },
          on: {
            click: () => this.onOk() !== !1 && this.closeModel()
          }
        }, [e]) : null]);
    }
  },
  render() {
    const t = arguments[0], e = this.type;
    let r;
    e === "input" ? r = this.makeInput() : e === "image" ? r = this.makeImages() : r = this.makeFiles();
    const {
      width: i = "30%",
      height: s,
      src: n,
      title: o,
      modalTitle: a
    } = this.$props;
    return this.$nextTick(() => {
      this.$refs.frame && this.frameLoad(this.$refs.frame.contentWindow || {});
    }), t("div", {
      class: "_fc-frame"
    }, [r, t("el-dialog", F([{}, {
      props: {
        appendToBody: !0,
        modal: this.previewMask,
        title: a,
        visible: this.previewVisible
      }
    }, {
      on: {
        close: this.handleCancel
      }
    }]), [t("img", {
      style: "width: 100%",
      attrs: {
        src: this.previewImage
      }
    })]), t("el-dialog", F([{}, {
      props: N(y({
        width: i,
        title: o,
        appendToBody: !0
      }, this.modal), {
        visible: this.frameVisible
      })
    }, {
      on: {
        close: () => this.closeModel(!0)
      }
    }]), [this.frameVisible || !this.reload ? t("iframe", {
      ref: "frame",
      attrs: {
        src: n,
        frameBorder: "0"
      },
      style: {
        height: s,
        border: "0 none",
        width: "100%"
      }
    }) : null, this.makeFooter()])]);
  },
  mounted() {
    this.$on("fc.closeModal", this.closeModal);
  }
}, jt = "fcRadio", It = {
  name: jt,
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    },
    value: {},
    type: String
  },
  watch: {
    "formCreateInject.options": {
      handler() {
        this.update();
      },
      deep: !0
    },
    value() {
      this.update();
    }
  },
  data() {
    return {
      trueValue: []
    };
  },
  methods: {
    options() {
      const t = this.formCreateInject.options;
      return Array.isArray(t) ? t : [];
    },
    onInput(t) {
      this.$emit("input", this.options().filter((e) => e.label === t).reduce((e, r) => r.value, ""));
    },
    update() {
      this.trueValue = this.options().filter((t) => t.value === this.value).reduce((t, e) => e.label, "");
    }
  },
  created() {
    this.update();
  },
  render() {
    const t = arguments[0];
    return t("ElRadioGroup", F([{}, this.formCreateInject.prop, {
      ref: "el"
    }, {
      props: {
        value: this.trueValue
      }
    }, {
      on: {
        input: this.onInput
      }
    }]), [this.options().map((e, r) => {
      const i = y({}, e), s = this.type === "button" ? "ElRadioButton" : "ElRadio";
      return delete i.value, t(s, F([{}, {
        props: i
      }, {
        key: s + r + "-" + e.value
      }]));
    }), Y(this.$slots)]);
  },
  mounted() {
    this.$emit("fc.el", this.$refs.el);
  }
}, h = {
  type(t, e) {
    return Object.prototype.toString.call(t) === "[object " + e + "]";
  },
  Undef(t) {
    return t == null;
  },
  Element(t) {
    return typeof t == "object" && t !== null && t.nodeType === 1 && !h.Object(t);
  },
  trueArray(t) {
    return Array.isArray(t) && t.length > 0;
  },
  Function(t) {
    const e = this.getType(t);
    return e === "Function" || e === "AsyncFunction";
  },
  getType(t) {
    const e = Object.prototype.toString.call(t);
    return /^\[object (.*)\]$/.exec(e)[1];
  },
  empty(t) {
    return t == null || Array.isArray(t) && Array.isArray(t) && !t.length ? !0 : typeof t == "string" && !t;
  }
};
["Date", "Object", "String", "Boolean", "Array", "Number"].forEach((t) => {
  h[t] = function(e) {
    return h.type(e, t);
  };
});
function k(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
const At = "fcSelect", Vt = {
  name: At,
  functional: !0,
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    }
  },
  render(t, e) {
    const r = (n, o) => {
      const a = n.slot;
      return t("ElOption", F([{}, {
        props: n
      }, {
        key: "" + o + "-" + n.value
      }]), [a ? t("template", {
        slot: n.slotName || "default"
      }, [h.Function(a) ? n.slot(t) : a]) : null]);
    }, i = (n, o) => t("ElOptionGroup", {
      attrs: {
        label: n.label
      },
      key: "" + o + "-" + n.label
    }, [h.trueArray(n.options) && n.options.map((a, u) => r(a, u))]), s = e.props.formCreateInject.options;
    return t("ElSelect", F([{}, e.data, {
      ref: "el"
    }]), [(Array.isArray(s) ? s : []).map((n, o) => k(n || "", "options") ? i(n, o) : r(n, o)), e.children]);
  },
  mounted() {
    this.$emit("fc.el", this.$refs.el);
  }
}, Pt = "fcTree", Tt = {
  name: Pt,
  formCreateParser: {
    mergeProp(t) {
      const e = t.prop.props;
      e.nodeKey || (e.nodeKey = "id"), e.props || (e.props = {
        label: "title"
      });
    }
  },
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    },
    type: {
      type: String,
      default: "checked"
    },
    value: {
      type: [Array, String, Number],
      default: () => []
    }
  },
  watch: {
    value() {
      this.setValue();
    }
  },
  methods: {
    onChange() {
      this.updateValue();
    },
    updateValue() {
      if (!this.$refs.tree) return;
      const t = this.type.toLocaleLowerCase();
      let e;
      t === "selected" ? e = this.$refs.tree.getCurrentKey() : e = this.$refs.tree.getCheckedKeys(), this.$emit("input", e);
    },
    setValue() {
      this.type.toLocaleLowerCase() === "selected" ? this.$refs.tree.setCurrentKey(this.value) : this.$refs.tree.setCheckedKeys(j(this.value));
    }
  },
  render() {
    const t = arguments[0];
    return t("ElTree", F([{}, this.formCreateInject.prop, {
      ref: "tree",
      on: {
        check: () => this.updateValue(),
        "node-click": () => this.updateValue()
      }
    }]), [Y(this.$slots)]);
  },
  mounted() {
    this.setValue(), this.$emit("fc.el", this.$refs.tree);
  }
};
function Re(t, e) {
  return {
    url: t,
    name: Dt(t),
    uid: e
  };
}
function Dt(t) {
  return ("" + t).split("/").pop();
}
const Bt = "fcUpload", Lt = {
  name: Bt,
  props: {
    formCreateInject: {
      type: Object,
      required: !0
    },
    onHandle: {
      type: Function,
      default(t) {
        this.previewImage = t.url, this.previewVisible = !0;
      }
    },
    uploadType: {
      type: String,
      default: "file"
    },
    limit: {
      type: Number,
      default: 0
    },
    allowRemove: {
      type: Boolean,
      default: !0
    },
    previewMask: void 0,
    modalTitle: String,
    handleIcon: {
      type: [String, Boolean],
      default: () => {
      }
    },
    value: [Array, String]
  },
  data() {
    return {
      uploadList: [],
      previewVisible: !1,
      previewImage: "",
      cacheFiles: []
    };
  },
  created() {
    this.formCreateInject.prop.props.showFileList === void 0 && (this.formCreateInject.prop.props.showFileList = !1), this.formCreateInject.prop.props.fileList = j(this.value).map(Re);
  },
  watch: {
    value(t) {
      this.$refs.upload.uploadFiles.every((e) => !e.status || e.status === "success") && (this.$refs.upload.uploadFiles = j(t).map(Re), this.uploadList = this.$refs.upload.uploadFiles);
    },
    limit(t, e) {
      (e === 1 || t === 1) && this.update();
    }
  },
  methods: {
    key(t) {
      return t;
    },
    isDisabled() {
      return this.formCreateInject.prop.props.disabled === !0;
    },
    onRemove(t) {
      this.isDisabled() || this.$refs.upload.handleRemove(t);
    },
    handleClick(t) {
      this.onHandle(t);
    },
    makeItem(t, e) {
      const r = this.$createElement;
      return this.uploadType === "image" ? r("img", {
        attrs: {
          src: t.url
        },
        key: this.key("img" + e)
      }) : r("i", {
        class: "el-icon-tickets",
        key: this.key("i" + e)
      });
    },
    makeRemoveIcon(t, e) {
      const r = this.$createElement;
      return r("i", {
        class: "el-icon-delete",
        on: {
          click: () => this.onRemove(t)
        },
        key: this.key("ri" + e)
      });
    },
    makeHandleIcon(t, e) {
      const r = this.$createElement;
      return r("i", {
        class: this.handleIcon === !0 || this.handleIcon === void 0 ? "el-icon-view" : this.handleIcon,
        on: {
          click: () => this.handleClick(t)
        },
        key: this.key("hi" + e)
      });
    },
    makeProgress(t, e) {
      const r = this.$createElement;
      return r("ElProgress", F([{}, {
        props: {
          percentage: t.percentage,
          type: "circle",
          width: 52
        }
      }, {
        style: "margin-top:2px;",
        key: this.key("pg" + e)
      }]));
    },
    makeIcons(t, e) {
      const r = this.$createElement, i = [];
      if (this.allowRemove || this.handleIcon !== !1)
        return (this.uploadType !== "file" && this.handleIcon !== !1 || this.uploadType === "file" && this.handleIcon) && i.push(this.makeHandleIcon(t, e)), this.allowRemove && i.push(this.makeRemoveIcon(t, e)), r("div", {
          class: "fc-upload-cover"
        }, [i]);
    },
    makeFiles() {
      const t = this.$createElement;
      return this.uploadList.map((e, r) => this.$scopedSlots.fileList ? this.$scopedSlots.fileList({
        file: e,
        index: r,
        vm: this
      }) : t("div", {
        key: this.key(r),
        class: "fc-files"
      }, [e.percentage !== void 0 && e.status !== "success" ? this.makeProgress(e, r) : [this.makeItem(e, r), this.makeIcons(e, r)]]));
    },
    makeUpload() {
      const t = this.$createElement, e = !this.limit || this.limit > this.uploadList.length;
      return t("ElUpload", F([{}, this.formCreateInject.prop, {}, {
        style: {
          display: "inline-block"
        },
        key: this.key("upload"),
        ref: "upload"
      }]), [e ? t("template", {
        slot: "default"
      }, [this.$slots.default || t("div", {
        class: "fc-upload-btn"
      }, [t("i", {
        class: "el-icon-upload2"
      })])]) : null, Y(this.$slots, ["default"])]);
    },
    update() {
      let t = this.$refs.upload.uploadFiles.map((e) => e.url).filter((e) => e !== void 0 && e.indexOf("blob:") !== 0);
      JSON.stringify(t) !== JSON.stringify(this.cacheFiles) && (this.cacheFiles = [...t], this.$emit("input", this.limit === 1 ? t[0] || "" : t));
    },
    handleCancel() {
      this.previewVisible = !1;
    }
  },
  render() {
    const t = arguments[0];
    return this.$refs.upload && (this.formCreateInject.prop.props.showFileList === void 0 && (this.formCreateInject.prop.props.showFileList = this.$refs.upload.showFileList), this.formCreateInject.prop.props.fileList = this.$refs.upload.fileList), t("div", {
      class: "_fc-upload"
    }, [[this.formCreateInject.prop.props.showFileList ? [] : this.makeFiles(), this.makeUpload()], t("el-dialog", F([{}, {
      props: {
        appendToBody: !0,
        modal: this.previewMask,
        title: this.modalTitle,
        visible: this.previewVisible
      }
    }, {
      on: {
        close: this.handleCancel
      }
    }]), [t("img", {
      attrs: {
        alt: "example",
        src: this.previewImage
      },
      style: "width: 100%"
    })])]);
  },
  mounted() {
    this.uploadList = this.$refs.upload.uploadFiles, this.$watch(() => this.$refs.upload.uploadFiles, () => {
      this.update();
    }, {
      deep: !0
    }), this.$emit("fc.el", this.$refs.upload);
  }
};
function w(t, e, r) {
  T.set(t, e, r);
}
function B(t, e) {
  T.delete(t, e);
}
function K(t, e = {}, r) {
  let i = !1;
  for (let s in e)
    if (Object.prototype.hasOwnProperty.call(e, s)) {
      let n = e[s];
      if ((i = Array.isArray(n)) || h.Object(n)) {
        let o = t[s] === void 0;
        if (i)
          i = !1, o && w(t, s, []);
        else if (n._clone && r !== void 0)
          if (r)
            n = n.getRule(), o && w(t, s, {});
          else {
            w(t, s, n._clone());
            continue;
          }
        else
          o && w(t, s, {});
        t[s] = K(t[s], n, r);
      } else
        w(t, s, n), h.Undef(n) || (h.Undef(n.__json) || (t[s].__json = n.__json), h.Undef(n.__origin) || (t[s].__origin = n.__origin));
    }
  return r !== void 0 && Array.isArray(t) ? t.filter((s) => !s || !s.__ctrl) : t;
}
function L(t) {
  return K({}, { value: t }).value;
}
const Mt = Object.assign || function(t) {
  for (let e, r = 1; r < arguments.length; r++)
    for (let i in e = arguments[r], e)
      Object.prototype.hasOwnProperty.call(e, i) && w(t, i, e[i]);
  return t;
};
function p() {
  return Mt.apply(this, arguments);
}
const Nt = "fcGroup", qt = {
  name: Nt,
  props: {
    field: String,
    rule: [Array, Object],
    rules: Array,
    expand: Number,
    options: Object,
    formCreateInject: {
      type: Object,
      required: !0
    },
    button: {
      type: Boolean,
      default: !0
    },
    max: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    value: {
      type: Array,
      default: () => []
    },
    sortBtn: {
      type: Boolean,
      default: !0
    },
    defaultValue: Object,
    disabled: {
      type: Boolean,
      default: !1
    },
    syncDisabled: {
      type: Boolean,
      default: !0
    },
    onBeforeRemove: {
      type: Function,
      default: () => {
      }
    },
    onBeforeAdd: {
      type: Function,
      default: () => {
      }
    },
    parse: Function
  },
  data() {
    return {
      len: 0,
      cacheRule: {},
      cacheValue: {},
      sort: [],
      type: void 0
    };
  },
  computed: {
    formRule() {
      return this.rules ? this.rules : this.rule ? Array.isArray(this.rule) ? this.rule : [this.rule] : [];
    }
  },
  watch: {
    cacheRule: {
      handler(t) {
        this.sort = Object.keys(t);
      },
      immediate: !0
    },
    formRule: {
      handler(t, e) {
        Object.keys(this.cacheRule).forEach((r) => {
          const i = this.cacheRule[r];
          if (i.$f) {
            const s = i.$f.formData();
            if (t === e)
              i.$f.deferSyncValue(() => {
                K(i.rule, t), i.$f.setValue(s);
              }, !0);
            else {
              const n = i.$f.formData();
              i.$f.once("reloading", () => {
                i.$f.setValue(n);
              }), i.rule = L(t);
            }
          }
        });
      },
      deep: !0
    },
    expand(t) {
      let e = t - this.value.length;
      e > 0 && this.expandRule(e);
    },
    value(t, e) {
      t = t || [];
      let r = this.sort, i = r.length, s = i - t.length;
      if (s < 0) {
        for (let n = s; n < 0; n++)
          this.addRule(t.length + n);
        this.sort = Object.keys(this.cacheRule);
        for (let n = 0; n < i; n++)
          this.setValue(r[n], t[n]);
      } else {
        if (s > 0) {
          for (let n = 0; n < s; n++)
            this.removeRule(r[i - n - 1]);
          this.sort = Object.keys(this.cacheRule);
        }
        t.forEach((n, o) => {
          this.setValue(r[o], t[o]);
        });
      }
    }
  },
  methods: {
    _value(t) {
      return t && k(t, this.field) ? t[this.field] : t;
    },
    cache(t, e) {
      this.cacheValue[t] = JSON.stringify(e);
    },
    input(t) {
      this.$emit("input", t), this.$emit("change", t);
    },
    formData(t, e) {
      const r = this.cacheRule, i = this.sort;
      if (i.filter((n) => r[n].$f).length !== i.length)
        return;
      const s = i.map((n) => {
        const o = t === n ? e : y({}, this.cacheRule[n].$f.form), a = this.field ? o[this.field] || null : o;
        return this.cache(n, a), a;
      });
      this.input(s);
    },
    setValue(t, e) {
      const r = this.field, i = this.cacheRule[t].$f;
      r && (e = {
        [r]: this._value(e)
      }), this.cacheValue[t] !== JSON.stringify(r ? e[r] : e) && (this.cache(t, e), i && i.coverValue(e || {}));
    },
    addRule(t, e) {
      const r = this.formCreateInject.form.copyRules(this.formRule), i = this.options ? y({}, this.options) : {
        submitBtn: !1,
        resetBtn: !1
      };
      if (this.defaultValue) {
        i.formData || (i.formData = {});
        const s = L(this.defaultValue);
        p(i.formData, this.field ? {
          [this.field]: s
        } : s);
      }
      this.parse && this.parse({
        rule: r,
        options: i,
        index: this.sort.length
      }), this.$set(this.cacheRule, ++this.len, {
        rule: r,
        options: i
      }), e && this.$nextTick(() => this.$emit("add", r, Object.keys(this.cacheRule).length - 1));
    },
    add$f(t, e, r) {
      this.cacheRule[e].$f = r, this.$nextTick(() => {
        this.$emit("itemMounted", r, Object.keys(this.cacheRule).indexOf(e));
      });
    },
    removeRule(t, e) {
      const r = Object.keys(this.cacheRule).indexOf(t);
      this.$delete(this.cacheRule, t), this.$delete(this.cacheValue, t), e && this.$nextTick(() => this.$emit("remove", r));
    },
    add(t) {
      this.disabled || this.onBeforeAdd(this.value) === !1 || this.addRule(t, !0);
    },
    del(t, e) {
      if (this.disabled || this.onBeforeRemove(this.value, t) === !1)
        return;
      this.removeRule(e, !0);
      const r = [...this.value];
      r.splice(t, 1), this.input(r);
    },
    addIcon(t) {
      const e = this.$createElement;
      return e("div", {
        class: "_fc-group-btn _fc-group-plus-minus",
        on: {
          click: this.add
        }
      });
    },
    delIcon(t, e) {
      const r = this.$createElement;
      return r("div", {
        class: "_fc-group-btn _fc-group-plus-minus _fc-group-minus",
        on: {
          click: () => this.del(t, e)
        }
      });
    },
    sortUpIcon(t) {
      const e = this.$createElement;
      return e("div", {
        class: "_fc-group-btn _fc-group-arrow _fc-group-up",
        on: {
          click: () => this.changeSort(t, -1)
        }
      });
    },
    sortDownIcon(t) {
      const e = this.$createElement;
      return e("div", {
        class: "_fc-group-btn _fc-group-arrow _fc-group-down",
        on: {
          click: () => this.changeSort(t, 1)
        }
      });
    },
    changeSort(t, e) {
      const r = this.sort[t];
      this.$set(this.sort, t, this.sort[t + e]), this.sort[t + e] = r, this.formData(0);
    },
    makeIcon(t, e, r) {
      if (this.$scopedSlots.button)
        return this.$scopedSlots.button({
          total: t,
          index: e,
          vm: this,
          key: r,
          del: () => this.del(e, r),
          add: this.add
        });
      const i = [];
      return (!this.max || t < this.max) && t === e + 1 && i.push(this.addIcon(r)), t > this.min && i.push(this.delIcon(e, r)), this.sortBtn && e && i.push(this.sortUpIcon(e)), this.sortBtn && e !== t - 1 && i.push(this.sortDownIcon(e)), i;
    },
    emitEvent(t, e, r, i) {
      this.$emit(t, ...e, this.cacheRule[i].$f, r);
    },
    expandRule(t) {
      for (let e = 0; e < t; e++)
        this.value.push(this.field ? null : {});
    }
  },
  created() {
    this.type = this.formCreateInject.form.$form();
    const t = (this.expand || 0) - this.value.length;
    t > 0 && this.expandRule(t);
    for (let e = 0; e < this.value.length; e++)
      this.addRule(e);
  },
  render() {
    const t = arguments[0], e = this.sort, r = this.button, i = this.type, s = this.disabled, n = e.length === 0 ? this.$scopedSlots.default ? this.$scopedSlots.default({
      vm: this,
      add: this.add
    }) : t("div", {
      key: "a_def",
      class: "_fc-group-plus-minus _fc-group-add",
      on: {
        click: this.add
      }
    }) : e.map((o, a) => {
      const {
        rule: u,
        options: l
      } = this.cacheRule[o], c = r && !s ? this.makeIcon(e.length, a, o) : [];
      return t("div", {
        class: "_fc-group-container",
        key: o
      }, [t(i, F([{
        key: o
      }, {
        on: {
          "update:value": (m) => this.formData(o, m),
          "emit-event": (m, ...v) => this.emitEvent(m, v, a, o),
          input: (m) => this.add$f(a, o, m)
        }
      }, {}, {
        props: {
          disabled: s,
          inFor: !0,
          value: this.field ? {
            [this.field]: this._value(this.value[a])
          } : this.value[a],
          rule: u,
          option: l,
          extendOption: !0
        }
      }])), t("div", {
        class: "_fc-group-idx"
      }, [a + 1]), c.length ? t("div", {
        class: "_fc-group-handle"
      }, [c]) : null]);
    });
    return t("div", {
      key: "con",
      class: "_fc-group " + (s ? "_fc-group-disabled" : "")
    }, [n]);
  }
}, Ut = "fcSubForm", Ht = {
  name: Ut,
  props: {
    rule: Array,
    options: Object,
    formCreateInject: {
      type: Object,
      required: !0
    },
    value: {
      type: Object,
      default: () => ({})
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    syncDisabled: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      cacheRule: {},
      cacheValue: {},
      type: void 0
    };
  },
  watch: {
    value(t) {
      this.setValue(t);
    }
  },
  methods: {
    formData(t) {
      this.cacheValue = JSON.stringify(t), this.$emit("input", t), this.$emit("change", t);
    },
    setValue(t) {
      const e = JSON.stringify(t);
      this.cacheValue !== e && (this.cacheValue = e, this.cacheRule.$f.coverValue(t || {}));
    },
    addRule() {
      const t = this.options ? this.options : {
        submitBtn: !1,
        resetBtn: !1
      };
      t.formData = y({}, this.value || {}), this.cacheRule = {
        rule: this.rule,
        options: t
      };
    },
    add$f(t) {
      this.cacheRule.$f = t, this.$nextTick(() => {
        this.$emit("itemMounted", t);
      });
    },
    emitEvent(t, ...e) {
      this.$emit(t, ...e);
    }
  },
  created() {
    this.addRule(), this.type = this.formCreateInject.form.$form();
  },
  render() {
    const t = arguments[0], {
      rule: e,
      options: r
    } = this.cacheRule, i = this.type;
    return t(i, F([{}, {
      on: {
        "update:value": this.formData,
        "emit-event": this.emitEvent,
        input: this.add$f
      }
    }, {}, {
      props: {
        rule: e,
        option: r,
        disabled: this.disabled,
        extendOption: !0
      }
    }]));
  }
}, Jt = [
  Et,
  Rt,
  It,
  Vt,
  Tt,
  Lt,
  qt,
  Ht
], je = "FormCreate", le = (t, e) => {
  if (!(!t || t === e)) {
    if (t.formCreateInject)
      return t.formCreateInject;
    if (t.$parent)
      return le(t.$parent, e);
  }
};
function xt(t, e, r) {
  return {
    name: je,
    componentName: je,
    model: {
      prop: "api"
    },
    components: e,
    directives: r,
    provide() {
      return {
        $pfc: this
      };
    },
    inject: { $pfc: { default: null } },
    props: {
      rule: {
        type: Array,
        required: !0
      },
      option: {
        type: Object,
        default: () => ({})
      },
      extendOption: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      value: Object,
      api: Object,
      name: String,
      subForm: {
        type: Boolean,
        default: !0
      },
      inFor: Boolean
    },
    data() {
      return {
        formData: void 0,
        destroyed: !1,
        validate: {},
        $f: void 0,
        isShow: !0,
        unique: 1,
        renderRule: [...this.rule || []],
        ctxInject: {},
        updateValue: JSON.stringify(this.value || {}),
        isMore: !!this.inFor
      };
    },
    render() {
      return this.formCreate.render();
    },
    methods: {
      _refresh() {
        ++this.unique;
      },
      _renderRule() {
        this.renderRule = [...this.rule || []];
      },
      _updateValue(i) {
        this.destroyed || (this.updateValue = JSON.stringify(i), this.$emit("update:value", i));
      }
    },
    watch: {
      value: {
        handler(i) {
          JSON.stringify(i || {}) !== this.updateValue && (this.$f.config.forceCoverValue ? this.$f.coverValue(i || {}) : this.$f.setValue(i || {}));
        },
        deep: !0
      },
      option: {
        handler() {
          this.formCreate.initOptions(), this.$f.refresh();
        },
        deep: !0
      },
      rule(i, s) {
        i.length === this.renderRule.length && i.every((n) => this.renderRule.indexOf(n) > -1) || (this.formCreate.$handle.reloadRule(i), this._renderRule(), i !== s && this.formCreate.$handle.targetReload());
      },
      disabled() {
        this.$f.refresh();
      }
    },
    beforeCreate() {
      this.formCreate = new t(this), Object.keys(this.formCreate.prop).forEach((i) => {
        p(this.$options[i], this.formCreate.prop[i]);
      }), this.$emit("beforeCreate", this.formCreate.api());
    },
    created() {
      const i = this, s = this.formCreate.api(), n = () => {
        if (i.$pfc) {
          const a = le(i, i.$pfc);
          if (a) {
            let u;
            i.isMore ? (u = j(a.getSubForm()), u.push(s)) : u = s, a.subForm(u);
          }
        }
      }, o = () => {
        const a = le(i, i.$pfc);
        if (a)
          if (i.isMore) {
            const u = j(a.getSubForm()), l = u.indexOf(s);
            l > -1 && u.splice(l, 1);
          } else
            a.subForm();
      };
      i.$on("hook:beforeDestroy", () => {
        o();
      }), this.$watch(() => this.subForm, (a) => {
        a ? n() : o();
      }, { immediate: !0 });
    }
  };
}
const Ke = ["attrs", "props", "domProps", "scopedSlots"], We = ["class", "style", "directives"], Ge = ["on", "nativeOn"], D = (t, e = {}, r = {}) => {
  const i = [...Ke, ...r.normal || []], s = [...We, ...r.array || []], n = [...Ge, ...r.functional || []], o = r.props || [];
  return t.reduce((a, u) => {
    for (const l in u)
      if (a[l])
        if (o.indexOf(l) > -1)
          a[l] = D([u[l]], a[l]);
        else if (i.indexOf(l) > -1)
          a[l] = y(y({}, a[l]), u[l]);
        else if (s.indexOf(l) > -1) {
          const c = a[l] instanceof Array ? a[l] : [a[l]], m = u[l] instanceof Array ? u[l] : [u[l]];
          a[l] = [...c, ...m];
        } else if (n.indexOf(l) > -1)
          for (const c in u[l])
            if (a[l][c]) {
              const m = a[l][c] instanceof Array ? a[l][c] : [a[l][c]], v = u[l][c] instanceof Array ? u[l][c] : [u[l][c]];
              a[l][c] = [...m, ...v];
            } else
              a[l][c] = u[l][c];
        else if (l === "hook")
          for (let c in u[l])
            a[l][c] ? a[l][c] = Kt(a[l][c], u[l][c]) : a[l][c] = u[l][c];
        else
          a[l] = u[l];
      else
        i.indexOf(l) > -1 || n.indexOf(l) > -1 || o.indexOf(l) > -1 ? a[l] = y({}, u[l]) : s.indexOf(l) > -1 ? a[l] = u[l] instanceof Array ? [...u[l]] : typeof u[l] == "object" ? y({}, u[l]) : u[l] : a[l] = u[l];
    return a;
  }, e);
}, Kt = (t, e) => function() {
  t && t.apply(this, arguments), e && e.apply(this, arguments);
}, Xe = ["type", "slot", "emitPrefix", "value", "name", "native", "hidden", "display", "inject", "options", "emit", "nativeEmit", "link", "prefix", "suffix", "update", "sync", "optionsTo", "key", "preview", "component", "cache"], pe = ["validate", "children", "control"], me = ["effect", "deep"];
function Wt() {
  return [...Xe, ...Ke, ...We, ...Ge, ...pe, ...me];
}
function ye(t, e, r) {
  return `[form-create ${t}]: ${e}`;
}
function Gt(t, e) {
  console.warn(ye("tip", t));
}
function ge(t, e) {
  console.error(ye("err", t));
}
function Xt(t) {
  ge(t.toString()), console.error(t);
}
const ue = "[[FORM-CREATE-PREFIX-", fe = "-FORM-CREATE-SUFFIX]]";
function ze(t, e) {
  return JSON.stringify(K(Array.isArray(t) ? [] : {}, t, !0), function(r, i) {
    if (!(i && i._isVue === !0)) {
      if (typeof i != "function")
        return i;
      if (i.__json)
        return i.__json;
      if (i.__origin && (i = i.__origin), !i.__emit)
        return ue + i + fe;
    }
  }, e);
}
function te(t) {
  return new Function("return " + t)();
}
function q(t, e) {
  if (t && h.String(t) && t.length > 4) {
    let r = t.trim(), i = !1;
    try {
      if (r.indexOf(fe) > 0 && r.indexOf(ue) === 0)
        r = r.replace(fe, "").replace(ue, ""), i = !0;
      else if (r.indexOf("$FN:") === 0)
        r = r.substring(4), i = !0;
      else if (r.indexOf("$EXEC:") === 0)
        r = r.substring(6), i = !0;
      else if (r.indexOf("$GLOBAL:") === 0) {
        const n = r.substring(8);
        return r = function(...o) {
          const a = o[0].api.getGlobalEvent(n);
          if (a)
            return a.call(this, ...o);
        }, r.__json = t, r.__inject = !0, r;
      } else {
        if (r.indexOf("$FNX:") === 0)
          return r = te("function($inject){" + r.substring(5) + "}"), r.__json = t, r.__inject = !0, r;
        (!e && r.indexOf("function ") === 0 && r !== "function " || !e && r.indexOf("function(") === 0 && r !== "function(") && (i = !0);
      }
      if (!i) return t;
      let s;
      try {
        s = te(r);
      } catch (n) {
        s = te("function " + r);
      }
      return s.__json = t, s;
    } catch (s) {
      ge(`解析失败:${r}

err: ${s}`);
      return;
    }
  }
  return t;
}
function zt(t, e) {
  return JSON.parse(t, function(r, i) {
    return h.Undef(i) || !i.indexOf ? i : q(i, e);
  });
}
function he(t, e) {
  return {
    value: t,
    enumerable: !1,
    configurable: !1,
    writable: !!e
  };
}
function $e(t) {
  return Qe([t])[0];
}
function Qe(t, e) {
  return K([], [...t], e || !1);
}
function U(t, e) {
  return D(Array.isArray(e) ? e : [e], t, { array: pe, normal: me }), t;
}
function Ie(t) {
  const e = h.Function(t.getRule) ? t.getRule() : t;
  return e.type || (e.type = "input"), e;
}
function Qt(t, e) {
  return t ? (Object.keys(e || {}).forEach((r) => {
    e[r] && (t[r] = U(t[r] || {}, e[r]));
  }), t) : e;
}
function Ze(t, e) {
  Object.defineProperties(t, Object.keys(e).reduce((r, i) => (r[i] = {
    get() {
      return e[i]();
    }
  }, r), {}));
}
function z(t) {
  return t.__fc__ || (t.__origin__ ? t.__origin__.__fc__ : null);
}
function R(t, e) {
  try {
    e = t();
  } catch (r) {
    Xt(r);
  }
  return e;
}
const Ae = (t, e) => typeof t == "string" ? String(e) : typeof t == "number" ? Number(e) : e, x = {
  "==": (t, e) => JSON.stringify(t) === JSON.stringify(Ae(t, e)),
  "!=": (t, e) => !x["=="](t, e),
  ">": (t, e) => t > e,
  ">=": (t, e) => t >= e,
  "<": (t, e) => t < e,
  "<=": (t, e) => t <= e,
  on(t, e) {
    return t && t.indexOf && t.indexOf(Ae(t[0], e)) > -1;
  },
  notOn(t, e) {
    return !x.on(t, e);
  },
  in(t, e) {
    return e && e.indexOf && e.indexOf(t) > -1;
  },
  notIn(t, e) {
    return !x.in(t, e);
  },
  between(t, e) {
    return t > e[0] && t < e[1];
  },
  notBetween(t, e) {
    return t < e[0] || t > e[1];
  },
  empty(t) {
    return h.empty(t);
  },
  notEmpty(t) {
    return !h.empty(t);
  },
  pattern(t, e) {
    return new RegExp(e, "g").test(t);
  }
};
function Ye() {
  return {
    props: {},
    on: {},
    options: [],
    children: [],
    effect: {},
    hidden: !1,
    display: !0,
    value: void 0
  };
}
function E(t, e) {
  return (r, i, s, n = {}) => {
    const o = new ve(t, r, i, s, n);
    return e && (h.Function(e) ? e(o) : o.props(e)), o;
  };
}
function ve(t, e, r, i, s) {
  this._data = p(Ye(), { type: t, title: e, field: r, value: i, props: s || {} }), this.event = this.on;
}
p(ve.prototype, {
  getRule() {
    return this._data;
  },
  setProp(t, e) {
    return w(this._data, t, e), this;
  },
  _clone() {
    const t = new this.constructor();
    return t._data = $e(this._data), t;
  }
});
function et(t) {
  t.forEach((e) => {
    ve.prototype[e] = function(r) {
      return U(this._data, { [e]: arguments.length < 2 ? r : { [r]: arguments[1] } }), this;
    };
  });
}
et(Wt());
const tt = E("");
function Zt(t, e, r) {
  let i = tt("", e);
  return i._data.type = t, i._data.title = r, i;
}
function Ve(t, e, r, i) {
  let s = tt("", r);
  return s._data.type = "template", s._data.template = t, s._data.title = i, s._data.vm = e, s;
}
function Yt() {
  return {
    create: Zt,
    createTmp: Ve,
    template: Ve,
    factory: E
  };
}
function er(t, e, r) {
  const i = `fail to ${t} ${r.status}'`, s = new Error(i);
  return s.status = r.status, s.url = t, s;
}
function Pe(t) {
  const e = t.responseText || t.response;
  if (!e)
    return e;
  try {
    return JSON.parse(e);
  } catch (r) {
    return e;
  }
}
function rt(t) {
  if (typeof XMLHttpRequest == "undefined")
    return;
  const e = new XMLHttpRequest(), r = t.action;
  e.onerror = function(o) {
    t.onError(o);
  }, e.onload = function() {
    if (e.status < 200 || e.status >= 300)
      return t.onError(er(r, t, e), Pe(e));
    t.onSuccess(Pe(e));
  }, e.open(t.method || "get", r, !0);
  let i;
  t.data && ((t.dataType || "").toLowerCase() !== "json" ? (i = new FormData(), Object.keys(t.data).map((n) => {
    i.append(n, t.data[n]);
  })) : (i = JSON.stringify(t.data), e.setRequestHeader("content-type", "application/json"))), t.withCredentials && "withCredentials" in e && (e.withCredentials = !0);
  const s = t.headers || {};
  Object.keys(s).forEach((n) => {
    s[n] !== null && e.setRequestHeader(n, s[n]);
  }), e.send(i);
}
function tr(t) {
  return new Promise((e, r) => {
    rt(N(y({}, t), {
      onSuccess(i) {
        let s = (o) => o;
        const n = q(t.parse);
        h.Function(n) ? s = n : n && h.String(n) && (s = (o) => (n.split(".").forEach((a) => {
          o && (o = o[a]);
        }), o)), e(s(i));
      },
      onError(i) {
        r(i);
      }
    }));
  });
}
function X(t) {
  return L(t);
}
function rr(t) {
  function e(n) {
    return h.Undef(n) ? n = t.fields() : Array.isArray(n) || (n = [n]), n;
  }
  function r(n, o, a) {
    e(n).forEach((u) => {
      t.getCtxs(u).forEach((l) => {
        w(l.rule, o, a), t.$render.clearCache(l);
      });
    });
  }
  function i() {
    const n = t.subForm;
    return Object.keys(n).reduce((o, a) => {
      const u = n[a];
      return u && (Array.isArray(u) ? o.push(...u) : o.push(u)), o;
    }, []);
  }
  const s = {
    get config() {
      return t.options;
    },
    get options() {
      return t.options;
    },
    get form() {
      return t.form;
    },
    get rule() {
      return t.rules;
    },
    get parent() {
      return t.vm.$pfc && t.vm.$pfc.$f;
    },
    get top() {
      return s.parent ? s.parent.top : s;
    },
    get children() {
      return i();
    },
    formData(n) {
      return e(n).reduce((o, a) => {
        const u = t.getFieldCtx(a);
        return u && (o[u.field] = X(u.rule.value)), o;
      }, t.options.appendValue !== !1 ? X(t.appendData) : {});
    },
    getValue(n) {
      const o = t.getFieldCtx(n);
      if (o)
        return X(o.rule.value);
    },
    coverValue(n) {
      const o = y({}, n || {});
      t.deferSyncValue(() => {
        s.fields().forEach((a) => {
          const u = t.fieldCtx[a];
          if (u) {
            const l = k(o, a);
            u.forEach((c) => {
              c.rule.value = l ? o[a] : void 0;
            }), delete o[a];
          }
        }), p(t.appendData, o);
      });
    },
    setValue(n) {
      let o = n;
      arguments.length >= 2 && (o = { [n]: arguments[1] }), t.deferSyncValue(() => {
        Object.keys(o).forEach((a) => {
          const u = t.fieldCtx[a];
          if (!u) return t.appendData[a] = o[a];
          u.forEach((l) => {
            l.rule.value = o[a];
          });
        });
      });
    },
    removeField(n) {
      const o = t.getCtx(n);
      return t.deferSyncValue(() => {
        t.getCtxs(n).forEach((a) => {
          a.rm();
        });
      }, !0), o ? o.origin : void 0;
    },
    removeRule(n) {
      const o = n && z(n);
      if (o)
        return o.rm(), o.origin;
    },
    destroy: () => {
      t.vm.$el.parentNode && t.vm.$el.parentNode.removeChild(t.vm.$el), t.vm.$destroy();
    },
    fields: () => t.fields(),
    append: (n, o, a) => {
      let u = t.sort.length - 1, l;
      const c = t.getCtx(o);
      c ? a ? (l = c.rule.children, u = c.rule.children.length - 1) : (u = c.root.indexOf(c.origin), l = c.root) : l = t.rules, l.splice(u + 1, 0, n);
    },
    prepend: (n, o, a) => {
      let u = 0, l;
      const c = t.getCtx(o);
      c ? a ? l = c.rule.children : (u = c.root.indexOf(c.origin), l = c.root) : l = t.rules, l.splice(u, 0, n);
    },
    hidden(n, o) {
      r(o, "hidden", !!n), t.refresh();
    },
    hiddenStatus(n) {
      const o = t.getCtx(n);
      if (o)
        return !!o.rule.hidden;
    },
    display(n, o) {
      r(o, "display", !!n), t.refresh();
    },
    displayStatus(n) {
      const o = t.getCtx(n);
      if (o)
        return !!o.rule.display;
    },
    disabled(n, o) {
      e(o).forEach((a) => {
        t.getCtxs(a).forEach((u) => {
          u.rule.props && w(u.rule.props, "disabled", !!n);
        });
      }), t.refresh();
    },
    all(n) {
      return Object.keys(t.ctxs).map((o) => {
        const a = t.ctxs[o];
        return n ? a.origin : a.rule;
      });
    },
    model(n) {
      return t.fields().reduce((o, a) => {
        const u = t.fieldCtx[a][0];
        return o[a] = n ? u.origin : u.rule, o;
      }, {});
    },
    component(n) {
      return Object.keys(t.nameCtx).reduce((o, a) => {
        const u = t.nameCtx[a].map((l) => n ? l.origin : l.rule);
        return o[a] = u.length === 1 ? u[0] : u, o;
      }, {});
    },
    bind() {
      return s.form;
    },
    reload: (n) => {
      t.reloadRule(n);
    },
    updateOptions(n) {
      t.fc.updateOptions(n), s.refresh();
    },
    onSubmit(n) {
      s.updateOptions({ onSubmit: n });
    },
    sync: (n) => {
      if (Array.isArray(n)) {
        n.forEach((a) => s.sync(a));
        return;
      }
      let o = h.Object(n) ? z(n) : t.getCtxs(n);
      o && (o = Array.isArray(o) ? o : [o], o.forEach((a) => {
        if (!a.deleted) {
          const u = t.subForm[a.id];
          u && (Array.isArray(u) ? u.forEach((l) => {
            l.refresh();
          }) : u && u.refresh()), t.$render.clearCache(a);
        }
      }), t.refresh());
    },
    refresh: () => {
      i().forEach((n) => {
        n.refresh();
      }), t.$render.clearCacheAll(), t.refresh();
    },
    refreshOptions() {
      t.$manager.updateOptions(t.options), s.refresh();
    },
    hideForm: (n) => {
      w(t.vm, "isShow", !n);
    },
    changeStatus: () => t.changeStatus,
    clearChangeStatus: () => {
      t.changeStatus = !1;
    },
    updateRule(n, o) {
      t.getCtxs(n).forEach((a) => {
        p(a.rule, o);
      });
    },
    updateRules(n) {
      Object.keys(n).forEach((o) => {
        s.updateRule(o, n[o]);
      });
    },
    mergeRule: (n, o) => {
      t.getCtxs(n).forEach((a) => {
        U(a.rule, o);
      });
    },
    mergeRules(n) {
      Object.keys(n).forEach((o) => {
        s.mergeRule(o, n[o]);
      });
    },
    getRule: (n, o) => {
      const a = t.getCtx(n);
      if (a)
        return o ? a.origin : a.rule;
    },
    getRenderRule: (n) => {
      const o = t.getCtx(n);
      if (o)
        return o.prop;
    },
    getRefRule: (n) => {
      const o = t.getCtxs(n);
      if (o && o.length) {
        const a = o.map((u) => u.rule);
        return a.length === 1 ? a[0] : a;
      }
    },
    setEffect(n, o, a) {
      const u = t.getCtx(n);
      u && o && (o[0] === "$" && (o = o.substr(1)), k(u.rule, "$" + o) && w(u.rule, "$" + o, a), k(u.rule, "effect") || w(u.rule, "effect", {}), w(u.rule.effect, o, a));
    },
    clearEffectData(n, o) {
      const a = t.getCtx(n);
      a && (o && o[0] === "$" && (o = o.substr(1)), a.clearEffectData(o), s.sync(n));
    },
    updateValidate(n, o, a) {
      a ? s.mergeRule(n, { validate: o }) : r(n, "validate", o);
    },
    updateValidates(n, o) {
      Object.keys(n).forEach((a) => {
        s.updateValidate(a, n[a], o);
      });
    },
    refreshValidate() {
      t.vm.validate = {}, s.refresh();
    },
    resetFields(n) {
      e(n).forEach((o) => {
        t.getCtxs(o).forEach((a) => {
          t.$render.clearCache(a), a.rule.value = X(a.defaultValue);
        });
      }), t.vm.$nextTick(() => {
        s.clearValidateState();
      }), n == null && (h.Function(t.options.onReset) && R(() => t.options.onReset(s)), t.vm.$emit("reset", s));
    },
    method(n, o) {
      const a = s.el(n);
      if (!a || !a[o])
        throw new Error(ye("err", `${o}方法不存在`));
      return (...u) => a[o](...u);
    },
    exec(n, o, ...a) {
      return R(() => s.method(n, o)(...a));
    },
    toJson(n) {
      return ze(s.rule, n);
    },
    trigger(n, o, ...a) {
      const u = s.el(n);
      u && u.$emit(o, ...a);
    },
    el(n) {
      const o = t.getCtx(n);
      if (o) return o.exportEl || o.el || t.vm.$refs[o.ref];
    },
    closeModal: (n) => {
      const o = s.el(n);
      o && o.$emit && o.$emit("close-modal");
    },
    getSubForm(n) {
      const o = t.getCtx(n);
      return o ? t.subForm[o.id] : void 0;
    },
    nextTick(n) {
      t.bus.$once("next-tick", n), t.refresh();
    },
    nextRefresh(n) {
      t.nextRefresh(), n && R(n);
    },
    emit(n, ...o) {
      t.vm.$emit(n, ...o);
    },
    deferSyncValue(n, o) {
      t.deferSyncValue(n, o);
    },
    fetch(n) {
      return new Promise((o, a) => {
        t.beforeFetch(n).then(() => tr(n).then(o).catch(a));
      });
    },
    getData(n, o) {
      return t.fc.getData(n, o);
    },
    setData(n, o) {
      return t.fc.setData(n, o);
    },
    helper: {
      tidyFields: e,
      props: r
    }
  };
  return ["on", "once", "off", "set", "emit"].forEach((n) => {
    s[n] = function(...o) {
      t.vm[`$${n}`](...o);
    };
  }), s.changeValue = s.changeField = s.setValue, s;
}
function ir(t) {
  p(t.prototype, {
    initCache() {
      this.clearCacheAll();
    },
    clearCache(e) {
      if (e.rule.cache)
        return;
      if (!this.cache[e.id]) {
        e.parent && this.clearCache(e.parent);
        return;
      }
      (this.cache[e.id].use === !0 || this.cache[e.id].parent) && this.$handle.refresh();
      const r = this.cache[e.id].parent;
      this.cache[e.id] = null, r && this.clearCache(r);
    },
    clearCacheAll() {
      this.cache = {};
    },
    setCache(e, r, i) {
      this.cache[e.id] = {
        vnode: r,
        use: !1,
        parent: i,
        slot: e.rule.slot
      };
    },
    getCache(e) {
      const r = this.cache[e.id];
      if (r)
        return r.use = !0, r.vnode;
    }
  });
}
function I(t) {
  const e = t.replace(/(-[a-z])/g, function(r) {
    return r.replace("-", "").toLocaleUpperCase();
  });
  return it(e);
}
function it(t) {
  return t.replace(t[0], t[0].toLowerCase());
}
function nt(t) {
  return t == null ? "" : typeof t == "object" ? JSON.stringify(t, null, 2) : String(t);
}
function Q(t) {
  let e = t.replace(/([A-Z])/g, "-$1").toLocaleLowerCase();
  return e.indexOf("-") === 0 && (e = e.substr(1)), e;
}
let nr = 0;
function ee() {
  const t = 370 + ++nr;
  return "F" + Math.random().toString(36).substr(3, 3) + (+`${Date.now()}`).toString(36) + t.toString(36) + "c";
}
function Z(t, e, r) {
  let i = t, s;
  return (e || "").split(".").forEach((n) => {
    s && ((!i[s] || typeof i[s] != "object") && (i[s] = {}), i = i[s]), s = n;
  }), i[s] = r, i;
}
function sr(t) {
  p(t.prototype, {
    initRender() {
      this.tempList = {}, this.clearOrgChildren();
    },
    initOrgChildren() {
      const e = this.$handle.ctxs;
      this.orgChildren = Object.keys(e).reduce((r, i) => {
        if (e[i].parser.loadChildren !== !1) {
          const s = e[i].rule.children;
          r[i] = h.trueArray(s) ? [...s] : [];
        }
        return r;
      }, {});
    },
    clearOrgChildren() {
      this.orgChildren = {};
    },
    getTypeSlot(e) {
      const r = (i) => {
        if (i) {
          let s;
          return e.rule.field && (s = i.$scopedSlots["field-" + Q(e.rule.field)] || i.$scopedSlots["field-" + e.rule.field]), s || (s = i.$scopedSlots["type-" + Q(e.type)] || i.$scopedSlots["type-" + e.type]), s || r(i.$pfc);
        }
      };
      return r(this.vm);
    },
    render() {
      if (!this.vm.isShow)
        return;
      this.$h = this.vm.$createElement, this.$manager.beforeRender();
      let e;
      const r = () => this.renderList();
      return r.renderSlot = (i) => this.renderList(i), r.renderName = (i) => this.renderId(i), r.renderField = (i) => this.renderId(i, "field"), this.vm.$scopedSlots.container ? e = [this.vm.$scopedSlots.container(r)] : e = r(), this.$manager.render(e);
    },
    renderList(e) {
      return this.sort.map((r) => e ? this.renderSlot(this.$handle.ctxs[r], e) : this.renderCtx(this.$handle.ctxs[r])).filter((r) => r !== void 0);
    },
    makeVm(e) {
      const r = e.vm;
      if (r) {
        if (h.Function(r))
          return R(() => e.vm(this.$handle.getInjectData(e)));
        if (!r._isVue)
          return new T(r);
      } else return new T();
      return r;
    },
    mergeGlobal(e) {
      const r = this.$handle.options.global;
      r && (e.cacheConfig || (e.cacheConfig = r[e.originType] || r[e.type] || r[e.trueType] || {}), e.prop = U({}, [r["*"], e.cacheConfig, e.prop]));
    },
    setOptions(e) {
      e.prop.optionsTo && e.prop.options && Z(e.prop, e.prop.optionsTo, e.prop.options);
    },
    deepSet(e) {
      const r = e.rule.deep;
      r && Object.keys(r).sort((i, s) => i.length < s.length ? -1 : 1).forEach((i) => {
        Z(e.prop, i, r[i]);
      });
    },
    setTempProps(e, r) {
      if (!e.$props) return;
      const { prop: i } = r, s = Object.keys(e.$props), n = this.injectProp(r), o = Object.keys(n);
      s.forEach((u) => {
        k(i.props, u) ? e.$props[u] = i.props[u] : o.indexOf(u) > -1 && (e.$props[u] = n[u]);
      });
      const a = e.$options.model && e.$options.model.prop || "value";
      s.indexOf(a) > -1 && (e.$props[a] = i.value);
    },
    renderTemp(e) {
      if (!T.compile)
        return Gt("当前使用的Vue构建版本不支持compile,无法使用template功能"), [];
      const r = e.prop, { id: i, key: s } = e;
      if (!this.tempList[i]) {
        e.el || (e.el = this.makeVm(r), this.vm.$nextTick(() => e.parser.mounted(e)));
        let u = e.el;
        e.input && u.$on(u.$options.model && u.$options.model.event || "input", (l) => {
          this.onInput(e, l);
        }), this.tempList[i] = {
          vm: u,
          template: T.compile(r.template)
        };
      }
      const { vm: n, template: o } = this.tempList[i];
      this.setTempProps(n, e);
      const a = o.render.call(n);
      return h.Undef(a.data) && (a.data = {}), a.key = s, a.data.ref = e.ref, a.data.key = s, a;
    },
    parseSide(e, r) {
      return h.Object(e) ? U({ props: { formCreateInject: r.prop.props.formCreateInject } }, e) : e;
    },
    renderSides(e, r, i) {
      const s = r[i ? "rule" : "prop"];
      return [this.renderRule(this.parseSide(s.prefix, r)), e, this.renderRule(this.parseSide(s.suffix, r))];
    },
    renderSlot(e, r) {
      return e.rule.slot === r ? this.renderCtx(e) : void 0;
    },
    renderId(e, r) {
      const i = this.$handle[r === "field" ? "fieldCtx" : "nameCtx"][e];
      return i ? i.map((s) => this.renderCtx(s, s.parent)) : void 0;
    },
    renderCtx(e, r) {
      if (e.type === "hidden") return;
      const i = e.rule;
      if (!this.cache[e.id] || this.cache[e.id].slot !== i.slot) {
        let s, n = i.cache !== !1;
        const o = e.trueType, a = !(h.Undef(i.display) || i.display);
        if (o === "template" && !i.template)
          s = this.renderSides(this.renderChildren(e), e, !0), a && this.display(s), s = this.item(e, s);
        else if (o === "fcFragment")
          s = this.renderChildren(e);
        else {
          e.initProp(), this.mergeGlobal(e), this.$manager.tidyRule(e), this.deepSet(e), this.setOptions(e), this.ctxProp(e);
          let u = e.prop;
          u.preview = !!(k(u, "preview") ? u.preview : this.options.preview), u.props.formCreateInject = this.injectProp(e);
          const l = u.preview;
          if (u.hidden) {
            this.setCache(e, void 0, r);
            return;
          }
          if (o === "template" && u.template)
            s = this.renderTemp(e), n = !1;
          else {
            let c = [];
            e.parser.renderChildren ? c = e.parser.renderChildren(e) : e.parser.loadChildren !== !1 && (c = this.renderChildren(e));
            const m = this.getTypeSlot(e);
            m ? s = m({
              rule: i,
              prop: u,
              preview: l,
              children: c,
              api: this.$handle.api,
              model: u.model || {}
            }) : s = l ? e.parser.preview(c, e) : e.parser.render(c, e);
          }
          s = this.renderSides(s, e), !(!e.input && h.Undef(u.native)) && u.native !== !0 && (s = this.$manager.makeWrap(e, s)), a && (s = this.display(s)), s = this.item(e, s);
        }
        return n && this.setCache(e, s, r), s;
      }
      return this.getCache(e);
    },
    display(e) {
      if (Array.isArray(e)) {
        const r = [];
        return e.forEach((i) => {
          if (Array.isArray(i)) return this.display(i);
          this.none(i) && r.push(i);
        }), r;
      } else
        return this.none(e);
    },
    none(e) {
      if (e && e.data)
        return Array.isArray(e.data.style) ? e.data.style.push({ display: "none" }) : h.String(e.data.style) ? e.data.style += ";display:none;" : e.data.style = [e.data.style, { display: "none" }], e;
    },
    item(e, r) {
      return this.$h("fcFragment", {
        slot: e.rule.slot,
        key: e.key
      }, [r]);
    },
    injectProp(e) {
      this.vm.ctxInject[e.id] || w(this.vm.ctxInject, e.id, {
        api: this.$handle.api,
        form: this.fc.create,
        subForm: (i) => {
          this.$handle.addSubForm(e, i);
        },
        getSubForm: () => this.$handle.subForm[e.id],
        options: [],
        children: [],
        prop: {},
        preview: !1,
        id: e.id,
        field: e.field,
        rule: e.rule,
        input: e.input
      });
      const r = this.vm.ctxInject[e.id];
      return p(r, {
        preview: e.prop.preview,
        options: e.prop.options,
        children: e.rule.children,
        prop: function() {
          const i = y({}, e.prop);
          return i.on = i.on ? y({}, i.on) : {}, delete i.model, i;
        }()
      }), r;
    },
    ctxProp(e) {
      const { ref: r, key: i, rule: s } = e;
      this.$manager.mergeProp(e), e.parser.mergeProp(e);
      const n = [
        {
          ref: r,
          key: s.key || `${i}fc`,
          slot: void 0,
          on: {
            "hook:mounted": () => {
              this.onMounted(e);
            },
            "fc.sub-form": (o) => {
              this.$handle.addSubForm(e, o);
            },
            "fc.el": (o) => {
              e.exportEl = o, o && ((o.$el || o).__rule__ = e.rule);
            }
          }
        }
      ];
      return e.input && (this.vm.$props.disabled === !0 && (e.prop.props.disabled = !0), e.prop.model = {
        value: this.$handle.getFormData(e),
        callback: (o) => {
          this.onInput(e, o);
        },
        expression: `formData.${e.id}`
      }), D(n, e.prop), e.prop;
    },
    onMounted(e) {
      e.el = this.vm.$refs[e.ref], e.el && ((e.el.$el || e.el).__rule__ = e.rule), e.parser.mounted(e), this.$handle.effect(e, "mounted");
    },
    onInput(e, r) {
      this.$handle.onInput(e, r);
    },
    renderChildren(e) {
      const { children: r } = e.rule, i = this.orgChildren[e.id], s = (n) => !h.String(n) && n.__fc__ && !this.$handle.ctxs[n.__fc__.id];
      return !h.trueArray(r) && i ? (this.$handle.deferSyncValue(() => {
        i.forEach((n) => {
          n && s(n) && this.$handle.rmCtx(n.__fc__);
        });
      }), this.orgChildren[e.id] = [], []) : (i && this.$handle.deferSyncValue(() => {
        i.forEach((n) => {
          n && r.indexOf(n) === -1 && s(n) && this.$handle.rmCtx(n.__fc__);
        });
      }), r.map((n) => {
        if (n) {
          if (h.String(n)) return n;
          if (n.__fc__)
            return this.renderCtx(n.__fc__, e);
          n.type && this.vm.$nextTick(() => {
            this.$handle.loadChildren(r, e), this.$handle.refresh();
          });
        }
      }));
    },
    defaultRender(e, r) {
      const i = e.prop;
      return i.component ? this.vNode.makeComponent(i.component, i, r) : this.vNode[e.type] ? this.vNode[e.type](i, r) : this.vNode[e.originType] ? this.vNode[e.originType](i, r) : this.vNode.make(it(e.originType), i, r);
    },
    renderRule(e, r, i) {
      if (!e) return;
      if (h.String(e)) return e;
      let s;
      if (i)
        s = e.type;
      else if (s = e.is, e.type) {
        s = I(e.type);
        const o = this.vNode.aliasMap[s];
        o && (s = I(o));
      }
      if (!s) return;
      let n = [[r]];
      return h.trueArray(e.children) && n.push(e.children.map((o) => this.renderRule(o))), this.$h(s, y({}, e), n);
    }
  });
}
function be(t) {
  p(this, {
    $handle: t,
    fc: t.fc,
    vm: t.vm,
    $manager: t.$manager,
    vNode: new t.fc.CreateNode(t.vm)
  }), Ze(this, {
    options() {
      return t.options;
    },
    sort() {
      return t.sort;
    }
  }), this.initCache(), this.initRender();
}
ir(be);
sr(be);
function or(t) {
  p(t.prototype, {
    parseInjectEvent(e, r) {
      const i = e.inject || this.options.injectEvent;
      return this.parseEventLst(e, r, i);
    },
    parseEventLst(e, r, i, s) {
      return Object.keys(r).forEach((n) => {
        const o = this.parseEvent(e, r[n], i, s);
        o && (r[n] = o);
      }), r;
    },
    parseEvent(e, r, i, s) {
      if (h.Function(r) && (i !== !1 && !h.Undef(i) || r.__inject))
        return this.inject(e, r, i);
      if (!s && Array.isArray(r) && r[0] && (h.String(r[0]) || h.Function(r[0])))
        return this.parseEventLst(e, r, i, !0);
      if (h.String(r)) {
        const n = q(r);
        if (n && r !== n)
          return n.__inject ? this.parseEvent(e, n, i, !0) : n;
      }
    },
    parseEmit(e, r) {
      let i = {}, s = e.rule, { emitPrefix: n, field: o, name: a, inject: u } = s, l = s[r ? "emit" : "nativeEmit"] || [];
      return h.trueArray(l) && l.forEach((c) => {
        if (!c) return;
        let m, v = n || o || a;
        if (h.Object(c) && (m = c.inject, c = c.name, v = c.prefix || v), v) {
          r || (v = `native-${v}`);
          const _ = Q(`${v}-${c}`), g = (...O) => {
            this.vm.$emit(_, ...O), this.vm.$emit("emit-event", _, ...O);
          };
          if (g.__emit = !0, !m && u === !1)
            i[c] = g;
          else {
            let O = m || u || this.options.injectEvent;
            i[c] = h.Undef(O) ? g : this.inject(s, g, O);
          }
        }
      }), e.computed[r ? "on" : "nativeOn"] = i, i;
    },
    getInjectData(e, r) {
      const { option: i, rule: s } = this.vm.$options.propsData;
      return {
        api: this.api,
        $f: this.api,
        rule: s,
        self: e.__origin__,
        option: i,
        inject: r
      };
    },
    inject(e, r, i) {
      if (r.__origin) {
        if (this.watching && !this.loading)
          return r;
        r = r.__origin;
      }
      const s = this, n = function(...o) {
        const a = s.getInjectData(e, i);
        return a.args = [...o], o.unshift(a), r.apply(this, o);
      };
      return n.__origin = r, n.__json = r.__json, n;
    }
  });
}
const Te = ["hook:updated", "hook:mounted"];
function ar(t) {
  p(t.prototype, {
    usePage() {
      const e = this.options.page;
      if (!e) return;
      let r = 25, i = lr(this.rules);
      h.Object(e) && (e.first && (r = parseInt(e.first, 10) || r), e.limit && (i = parseInt(e.limit, 10) || i)), p(this, {
        first: r,
        limit: i,
        pageEnd: this.rules.length <= r
      }), this.bus.$on("page-end", () => this.vm.$emit("page-end", this.api)), this.pageLoad();
    },
    pageLoad() {
      const e = () => {
        this.pageEnd ? (this.vm.$off(Te, e), this.bus.$emit("page-end")) : (this.first += this.limit, this.pageEnd = this.rules.length <= this.first, this.loadRule(), this.refresh());
      };
      this.vm.$on(Te, e);
    }
  });
}
function lr(t) {
  return t.length < 31 ? 31 : Math.ceil(t.length / 3);
}
function ur(t) {
  p(t.prototype, {
    clearNextTick() {
      this.nextTick && clearTimeout(this.nextTick), this.nextTick = null;
    },
    bindNextTick(e) {
      this.clearNextTick(), this.nextTick = setTimeout(() => {
        e(), this.nextTick = null;
      }, 10);
    },
    render() {
      return ++this.loadedId, this.vm.unique > 0 ? this.$render.render() : (this.vm.unique = 1, []);
    }
  });
}
function fr(t) {
  Object.defineProperties(t.origin, {
    __fc__: he(t, !0)
  }), t.rule !== t.origin && Object.defineProperties(t.rule, {
    __fc__: he(t, !0)
  });
}
function st(t, e, r) {
  const i = ee();
  p(this, {
    id: i,
    ref: i,
    wrapRef: i + "fi",
    rule: e,
    origin: e.__origin__ || e,
    name: e.name,
    watch: [],
    linkOn: [],
    root: [],
    ctrlRule: [],
    parent: null,
    cacheConfig: null,
    prop: y({}, e),
    computed: {},
    payload: {},
    input: !!e.field,
    el: void 0,
    exportEl: void 0,
    defaultValue: e.field ? L(r) : void 0,
    field: e.field || void 0
  }), this.updateKey(), fr(this), this.update(t, !0);
}
p(st.prototype, {
  effectData(t) {
    return this.payload[t] || (this.payload[t] = {}), this.payload[t];
  },
  clearEffectData(t) {
    t === void 0 ? this.payload = {} : delete this.payload[t];
  },
  updateKey(t) {
    this.key = ee(), t && this.parent && this.parent.updateKey(t);
  },
  updateType() {
    this.originType = this.rule.type, this.type = I(this.rule.type), this.trueType = this.$handle.getType(this.originType);
  },
  setParser(t) {
    this.parser = t, t.init(this);
  },
  initProp() {
    const t = y({}, this.rule);
    delete t.children, this.prop = U({}, [t, ...Object.keys(this.payload).map((e) => this.payload[e]), this.computed]);
  },
  injectValidate() {
    return j(this.prop.validate).map((t) => {
      if (h.Function(t.validator)) {
        const e = y({}, t), r = this;
        return e.validator = function(...i) {
          return t.validator.call({
            that: this,
            id: r.id,
            field: r.field,
            rule: r.rule,
            api: r.$handle.api
          }, ...i);
        }, e;
      }
      return t;
    });
  },
  check(t) {
    return this.vm === t.vm;
  },
  unwatch() {
    this.watch.forEach((t) => t()), this.watch = [];
  },
  unlink() {
    this.linkOn.forEach((t) => t()), this.linkOn = [];
  },
  link() {
    this.unlink(), this.$handle.appendLink(this);
  },
  watchTo() {
    this.$handle.watchCtx(this);
  },
  delete() {
    this.unwatch(), this.unlink(), this.rmCtrl(), p(this, {
      deleted: !0,
      prop: y({}, this.rule),
      computed: {},
      el: void 0,
      $handle: void 0,
      $render: void 0,
      $api: void 0,
      vm: void 0,
      vNode: void 0,
      parent: null,
      cacheConfig: null
    });
  },
  rmCtrl() {
    this.ctrlRule.forEach((t) => t.__fc__ && t.__fc__.rm()), this.ctrlRule = [];
  },
  rm() {
    const t = () => {
      let e = this.root.indexOf(this.origin);
      e > -1 && (this.root.splice(e, 1), this.$handle && this.$handle.refresh());
    };
    if (this.deleted) {
      t();
      return;
    }
    this.$handle.noWatch(() => {
      this.$handle.deferSyncValue(() => {
        this.rmCtrl(), t(), this.$handle.rmCtx(this), p(this, {
          root: []
        });
      }, this.input);
    });
  },
  update(t, e) {
    p(this, {
      deleted: !1,
      $handle: t,
      $render: t.$render,
      $api: t.api,
      vm: t.vm,
      vNode: t.$render.vNode,
      updated: !1,
      cacheValue: this.rule.value
    }), !e && this.unwatch(), this.watchTo(), this.link(), this.updateType();
  }
});
function hr(t) {
  p(t.prototype, {
    nextRefresh(e) {
      const r = this.loadedId;
      this.vm.$nextTick(() => {
        r === this.loadedId && (e ? e() : this.refresh());
      });
    },
    parseRule(e) {
      const r = Ie(e);
      return Object.defineProperties(r, {
        __origin__: he(e, !0)
      }), cr(r), this.appendValue(r), r.options = Array.isArray(r.options) ? r.options : [], [r, r.prefix, r.suffix].forEach((i) => {
        i && this.loadFn(i, r);
      }), this.loadCtrl(r), r.update && (r.update = q(r.update)), r;
    },
    loadFn(e, r) {
      ["on", "props", "nativeOn", "deep"].forEach((i) => {
        e[i] && this.parseInjectEvent(r, e[i]);
      });
    },
    loadCtrl(e) {
      e.control && e.control.forEach((r) => {
        r.handle && (r.handle = q(r.handle));
      });
    },
    syncProp(e) {
      const r = e.rule;
      h.trueArray(r.sync) && D([{
        on: r.sync.reduce((i, s) => (i[`update:${s}`] = (n) => {
          r.props[s] = n, this.vm.$emit("sync", s, n, r, this.fapi);
        }, i), {})
      }], e.computed);
    },
    loadRule() {
      this.cycleLoad = !1, this.loading = !0, this.pageEnd && this.bus.$emit("load-start"), this.deferSyncValue(() => {
        if (this._loadRule(this.rules), this.loading = !1, this.cycleLoad && this.pageEnd)
          return this.loadRule();
        this.pageEnd && this.bus.$emit("load-end"), this.vm._renderRule(), this.$render.initOrgChildren(), this.syncForm();
      });
    },
    loadChildren(e, r) {
      if (this.cycleLoad = !1, this.loading = !0, this.bus.$emit("load-start"), this._loadRule(e, r), this.loading = !1, this.cycleLoad)
        return this.loadRule();
      this.bus.$emit("load-end"), this.syncForm(), this.$render.clearCache(r);
    },
    _loadRule(e, r) {
      const i = (n) => {
        let o = e[n - 1];
        if (!o || !o.__fc__)
          return n > 0 ? i(n - 1) : -1;
        let a = this.sort.indexOf(o.__fc__.id);
        return a > -1 ? a : i(n - 1);
      }, s = (n, o) => {
        h.trueArray(n) && this._loadRule(n, o);
      };
      e.map((n, o) => {
        if (r && !h.Object(n) || !this.pageEnd && !r && o >= this.first) return;
        if (n.__fc__ && n.__fc__.root === e && this.ctxs[n.__fc__.id])
          return s(n.__fc__.rule.children, n.__fc__), n.__fc__;
        let a = Ie(n);
        const u = () => !!(a.field && this.fieldCtx[a.field] && this.fieldCtx[a.field][0] !== n.__fc__);
        this.ruleEffect(a, "init", { repeat: u() }), u() && this.vm.$emit("repeat-field", n, this.api);
        let l, c = !1, m = !!n.__fc__, v = a.value;
        if (m) {
          l = n.__fc__, v = l.defaultValue;
          const g = !l.check(this);
          if (l.deleted) {
            if (g) {
              if (De(l))
                return;
              l.update(this);
            }
          } else if (g) {
            if (De(l))
              return;
            e[o] = n = n._clone ? n._clone() : $e(n), l = null, c = !0;
          }
        }
        if (l)
          l.originType !== l.rule.type && l.updateType(), this.bindParser(l), this.appendValue(l.rule);
        else {
          const g = this.parseRule(n);
          l = new st(this, g, v), this.bindParser(l);
        }
        if ([!1, !0].forEach((g) => this.parseEmit(l, g)), this.syncProp(l), l.parent = r || null, l.root = e, this.setCtx(l), !c && !m && this.effect(l, "load"), this.effect(l, "created"), l.parser.loadChildren === !1 || s(l.rule.children, l), !r) {
          const g = i(o);
          g > -1 || !o ? this.sort.splice(g + 1, 0, l.id) : this.sort.push(l.id);
        }
        const _ = l.rule;
        return l.updated || (l.updated = !0, h.Function(_.update) && this.bus.$once("load-end", () => {
          this.refreshUpdate(l, _.value, "init");
        }), this.effect(l, "loaded")), l.input && Object.defineProperty(_, "value", this.valueHandle(l)), this.refreshControl(l) && (this.cycleLoad = !0), l;
      });
    },
    refreshControl(e) {
      return e.input && e.rule.control && this.useCtrl(e);
    },
    useCtrl(e) {
      const r = dr(e), i = [], s = this.api;
      if (!r.length) return !1;
      for (let a = 0; a < r.length; a++) {
        const u = r[a], l = u.handle || function(m) {
          return (x[u.condition || "=="] || x["=="])(m, u.value);
        };
        if (!h.trueArray(u.rule)) continue;
        const c = N(y({}, u), {
          valid: R(() => l(e.rule.value, s)),
          ctrl: pr(e, u.rule),
          isHidden: h.String(u.rule[0])
        });
        c.valid && c.ctrl || !c.valid && !c.ctrl && !c.isHidden || i.push(c);
      }
      if (!i.length) return !1;
      const n = [];
      let o = !1;
      return this.deferSyncValue(() => {
        i.reverse().forEach(({ isHidden: a, valid: u, rule: l, prepend: c, append: m, child: v, ctrl: _, method: g }) => {
          if (a) {
            u ? e.ctrlRule.push({
              __ctrl: !0,
              children: l,
              valid: u
            }) : _ && e.ctrlRule.splice(e.ctrlRule.indexOf(_) >>> 0, 1), n[u ? "push" : "unshift"](() => {
              g === "disabled" || g === "enabled" ? this.api.disabled(!u, l) : g === "display" ? this.api.display(u, l) : g === "required" ? (l.forEach((O) => {
                this.api.setEffect(O, "required", u);
              }), u || this.api.clearValidateState(l)) : this.api.hidden(!u, l);
            });
            return;
          }
          if (u) {
            o = !0;
            const O = {
              type: "fcFragment",
              native: !0,
              __ctrl: !0,
              children: l
            };
            e.ctrlRule.push(O), this.bus.$once("load-start", () => {
              c ? s.prepend(O, c, v) : m || v ? s.append(O, m || e.id, v) : e.root.splice(e.root.indexOf(e.origin) + 1, 0, O);
            });
          } else {
            e.ctrlRule.splice(e.ctrlRule.indexOf(_), 1);
            const O = z(_);
            O && O.rm();
          }
        });
      }), n.length && this.vm.$nextTick(() => {
        n.forEach((a) => a());
      }), this.vm.$emit("control", e.origin, this.api), this.effect(e, "control"), o;
    },
    reloadRule(e) {
      return this._reloadRule(e);
    },
    _reloadRule(e) {
      e || (e = this.rules);
      const r = y({}, this.ctxs);
      this.clearNextTick(), this.$render.clearOrgChildren(), this.initData(e), this.fc.rules = e, this.deferSyncValue(() => {
        this.bus.$once("load-end", () => {
          Object.keys(r).filter((i) => this.ctxs[i] === void 0).forEach((i) => this.rmCtx(r[i])), this.$render.clearCacheAll();
        }), this.reloading = !0, this.loadRule(), this.reloading = !1, this.refresh(), this.vm.$emit("reloading", this.api);
      }), this.vm.$emit("update", this.api);
    },
    //todo 组件生成全部通过 alias
    refresh() {
      this.vm._refresh();
    }
  });
}
function cr(t) {
  const e = Ye();
  return Object.keys(e).forEach((r) => {
    k(t, r) || w(t, r, e[r]);
  }), t;
}
function dr(t) {
  const e = t.rule.control || [];
  return h.Object(e) ? [e] : e;
}
function pr(t, e) {
  for (let r = 0; r < t.ctrlRule.length; r++) {
    const i = t.ctrlRule[r];
    if (i.children === e)
      return i;
  }
}
function De(t) {
  return !!t.rule.__ctrl;
}
function mr(t) {
  p(t.prototype, {
    getValue(e) {
      return h.Undef(e.cacheValue) && (e.cacheValue = e.parser.toValue(this.getFormData(e), e)), e.cacheValue;
    },
    setValue(e, r, i, s) {
      e.deleted || (e.cacheValue = r, this.changeStatus = !0, this.nextRefresh(), this.$render.clearCache(e), this.setFormData(e, i), this.syncValue(), this.valueChange(e, r), this.vm.$emit("change", e.field, r, e.origin, this.api, s || !1), this.effect(e, "value"), this.emitEvent("change", e.field, r, {
        rule: e.origin,
        api: this.api,
        setFlag: s || !1
      }));
    },
    onInput(e, r) {
      let i;
      e.input && (this.isQuote(e, i = e.parser.toValue(r, e)) || this.isChange(e, i)) && this.setValue(e, i, r);
    },
    setFormData(e, r) {
      w(this.formData, e.id, r === null ? void 0 : r);
    },
    getFormData(e) {
      return this.formData[e.id];
    },
    validate() {
      return Le(this.vm.validate), this.fields().forEach((e) => {
        this.fieldCtx[e].forEach((r) => {
          this.vm.validate[r.id] = j(r.rule.validate);
        });
      }), this.vm.validate;
    },
    syncForm() {
      Le(this.form), Object.defineProperties(this.form, this.fields().reduce((e, r) => {
        const i = this.getFieldCtx(r), s = this.valueHandle(i);
        return s.configurable = !0, e[r] = s, e;
      }, this.options.appendValue !== !1 ? Object.keys(this.appendData).reduce((e, r) => (e[r] = {
        enumerable: !0,
        configurable: !0,
        get: () => this.appendData[r],
        set: (i) => {
          this.appendData[r] = i;
        }
      }, e), {}) : {})), this.syncValue();
    },
    valueHandle(e) {
      return {
        enumerable: !0,
        get: () => this.getValue(e),
        set: (r) => {
          this.isChange(e, r) && this.setValue(e, r, e.parser.toFormValue(r, e), !0);
        }
      };
    },
    appendValue(e) {
      !e.field || !k(this.appendData, e.field) || (e.value = this.appendData[e.field], delete this.appendData[e.field]);
    },
    addSubForm(e, r) {
      this.subForm[e.id] = r;
    },
    deferSyncValue(e, r) {
      this.deferSyncFn || (this.deferSyncFn = e), this.deferSyncFn.sync || (this.deferSyncFn.sync = r), R(e), this.deferSyncFn === e && (this.deferSyncFn = null, e.sync && this.syncValue());
    },
    syncValue() {
      if (this.deferSyncFn)
        return this.deferSyncFn.sync = !0;
      this.vm._updateValue(y(y({}, this.options.appendValue !== !1 ? this.appendData : {}), this.form));
    },
    isChange(e, r) {
      return JSON.stringify(e.rule.value, Be) !== JSON.stringify(r === null ? void 0 : r, Be);
    },
    isQuote(e, r) {
      return (h.Object(r) || Array.isArray(r)) && r === e.rule.value;
    },
    refreshUpdate(e, r, i, s) {
      if (h.Function(e.rule.update)) {
        const n = R(() => e.rule.update(r, e.origin, this.api, {
          origin: i || "change",
          linkField: s
        }));
        if (n === void 0) return;
        e.rule.hidden = n === !0;
      }
    },
    valueChange(e, r) {
      this.refreshRule(e, r), this.bus.$emit("change-" + e.field, r);
    },
    refreshRule(e, r, i, s) {
      this.refreshControl(e) && (this.$render.clearCacheAll(), this.loadRule(), this.vm.$emit("update", this.api), this.refresh()), this.refreshUpdate(e, r, i, s);
    },
    appendLink(e) {
      const r = e.rule.link;
      h.trueArray(r) && r.forEach((i) => {
        const s = () => this.refreshRule(e, e.rule.value, "link", i);
        this.bus.$on("change-" + i, s), e.linkOn.push(() => this.bus.$off("change-" + i, s));
      });
    },
    fields() {
      return Object.keys(this.fieldCtx);
    }
  });
}
function Be(t, e) {
  return typeof e == "function" ? "" + e : e;
}
function Le(t) {
  Object.keys(t).forEach((e) => delete t[e]);
}
const ce = {
  init(t) {
  },
  toFormValue(t, e) {
    return t;
  },
  toValue(t, e) {
    return t;
  },
  mounted(t) {
  },
  render(t, e) {
    return e.$render.defaultRender(e, t);
  },
  preview(t, e) {
    return this.render(t, e);
  },
  mergeProp(t) {
  }
}, yr = ["field", "value", "vm", "template", "name", "config", "control", "inject", "sync", "payload", "optionsTo", "update", "component", "cache"];
function gr(t) {
  p(t.prototype, {
    getCtx(e) {
      return this.getFieldCtx(e) || this.getNameCtx(e)[0] || this.ctxs[e];
    },
    getCtxs(e) {
      return this.fieldCtx[e] || this.nameCtx[e] || (this.ctxs[e] ? [this.ctxs[e]] : []);
    },
    setIdCtx(e, r, i) {
      const s = `${i}Ctx`;
      this[s][r] ? this[s][r].push(e) : this[s][r] = [e];
    },
    rmIdCtx(e, r, i) {
      const s = `${i}Ctx`, n = this[s][r];
      if (!n) return !1;
      const o = n.splice(n.indexOf(e) >>> 0, 1).length > 0;
      return n.length || delete this[s][r], o;
    },
    getFieldCtx(e) {
      return (this.fieldCtx[e] || [])[0];
    },
    getNameCtx(e) {
      return this.nameCtx[e] || [];
    },
    setCtx(e) {
      let { id: r, field: i, name: s, rule: n } = e;
      this.ctxs[r] = e, s && this.setIdCtx(e, s, "name"), e.input && (this.setIdCtx(e, i, "field"), this.setFormData(e, e.parser.toFormValue(n.value, e)), this.isMounted && !this.reloading && this.vm.$emit("change", e.field, n.value, e.origin, this.api));
    },
    getParser(e) {
      const r = this.fc.parsers;
      return r[e.originType] || r[I(e.type)] || r[e.trueType] || ce;
    },
    bindParser(e) {
      e.setParser(this.getParser(e));
    },
    getType(e) {
      const r = this.fc.CreateNode.aliasMap, i = r[e] || r[I(e)] || e;
      return I(i);
    },
    noWatch(e) {
      this.noWatchFn || (this.noWatchFn = e), R(e), this.noWatchFn === e && (this.noWatchFn = null);
    },
    watchCtx(e) {
      const r = this.vm;
      Object.keys(e.rule).filter((i) => i[0] !== "_" && i[0] !== "$" && yr.indexOf(i) === -1).forEach((i) => {
        const s = i === "children";
        e.watch.push(r.$watch(() => e.rule[i], (n, o) => {
          if (!(this.loading || this.noWatchFn || this.reloading)) {
            if (s && e.parser.loadChildren === !1) {
              this.$render.clearCache(e), this.nextRefresh();
              return;
            }
            if (this.watching = !0, i === "link") {
              e.link();
              return;
            } else if (["props", "on", "nativeOn", "deep"].indexOf(i) > -1)
              this.parseInjectEvent(e.rule, n || {}), i === "props" && e.input && this.setFormData(e, e.parser.toFormValue(e.rule.value, e));
            else if (["emit", "nativeEmit"].indexOf(i) > -1)
              this.parseEmit(e, i === "emit");
            else if (["prefix", "suffix"].indexOf(i) > -1)
              n && this.loadFn(n, e.rule);
            else if (i === "type")
              e.updateType(), this.bindParser(e);
            else if (i === "children") {
              const a = h.trueArray(n);
              this.deferSyncValue(() => {
                n !== o && (this.rmSub(o, e), this.$render.initOrgChildren()), a && this.loadChildren(n, e), this.vm.$emit("update", this.api);
              });
            }
            this.$render.clearCache(e), this.refresh(), this.watching = !1;
          }
        }, { deep: !s, sync: s }));
      }), this.watchEffect(e);
    },
    rmSub(e, r) {
      h.trueArray(e) && e.forEach((i) => {
        i && i.__fc__ && i.__fc__.parent === r && this.rmCtx(i.__fc__);
      });
    },
    rmCtx(e) {
      if (e.deleted) return;
      const { id: r, field: i, input: s, name: n } = e;
      e.input && Object.defineProperty(e.rule, "value", {
        value: e.rule.value,
        writable: !0
      }), B(this.ctxs, r), B(this.$render.tempList, r), B(this.$render.orgChildren, r), B(this.vm.ctxInject, r), B(this.formData, r), B(this.subForm, r), B(e, "cacheValue"), s && this.rmIdCtx(e, i, "field"), n && this.rmIdCtx(e, n, "name"), s && !k(this.fieldCtx, i) && B(this.form, i), this.deferSyncValue(() => {
        this.reloading || (e.parser.loadChildren !== !1 && h.trueArray(e.rule.children) && e.rule.children.forEach((a) => a.__fc__ && this.rmCtx(a.__fc__)), e.root === this.rules && this.vm._renderRule());
      }, s);
      const o = this.sort.indexOf(r);
      return o > -1 && this.sort.splice(o, 1), this.$render.clearCache(e), e.delete(), this.effect(e, "deleted"), s && !this.fieldCtx[i] && this.vm.$emit("removeField", i, e.rule, this.api), e.rule.__ctrl || this.vm.$emit("removeRule", e.rule, this.api), e;
    }
  });
}
function $r(t) {
  p(t.prototype, {
    mounted() {
      const e = () => {
        this.isMounted = !0, this.lifecycle("mounted");
      };
      this.pageEnd ? e() : this.bus.$once("page-end", e);
    },
    lifecycle(e) {
      this.vm.$emit(e, this.api), this.emitEvent(e, this.api);
    },
    targetReload() {
      this.bus.$off("next-tick", this.nextReload), this.bus.$once("next-tick", this.nextReload);
    },
    emitEvent(e, ...r) {
      const i = this.options[e] || this.options[I("on-" + e)];
      if (i) {
        const s = q(i);
        h.Function(s) && R(() => s(...r));
      }
      this.bus.$emit(e, ...r);
    }
  });
}
function vr(t) {
  p(t.prototype, {
    useProvider() {
      const e = this.fc.providers;
      Object.keys(e).forEach((r) => {
        let i = e[r];
        h.Function(i) && (i = i(this.fc)), i._c = Cr(i), this.onEffect(i), this.providers[r] = i;
      });
    },
    onEffect(e) {
      const r = [];
      (e._c || ["*"]).forEach((i) => {
        const s = i === "*" ? "*" : this.getType(i);
        r.indexOf(s) > -1 || (r.push(s), this.bus.$on(`p:${e.name}:${s}:${e.input ? 1 : 0}`, (n, o) => {
          e[n] && e[n](...o);
        }));
      }), e._used = r;
    },
    watchEffect(e) {
      const r = this.vm;
      let i = {
        required: () => {
          var s, n;
          return (k(e.rule, "$required") ? e.rule.$required : (n = (s = e.rule) == null ? void 0 : s.effect) == null ? void 0 : n.required) || !1;
        }
      };
      Object.keys(e.rule.effect || {}).forEach((s) => {
        i[s] = () => e.rule.effect[s];
      }), Object.keys(e.rule).forEach((s) => {
        s[0] === "$" && (i[s.substr(1)] = () => e.rule[s]);
      }), Object.keys(i || {}).forEach((s) => {
        e.watch.push(r.$watch(i[s], (n) => {
          this.effect(e, "watch", { [s]: n });
        }, { deep: !0 }));
      });
    },
    ruleEffect(e, r, i) {
      this.emitEffect({
        rule: e,
        input: !!e.field,
        type: this.getType(e.type)
      }, r, i);
    },
    effect(e, r, i) {
      this.emitEffect({
        rule: e.rule,
        input: e.input,
        type: e.trueType,
        ctx: e,
        custom: i
      }, r);
    },
    getEffect(e, r) {
      if (k(e, "$" + r))
        return e["$" + r];
      if (k(e, "effect") && k(e.effect, r))
        return e.effect[r];
    },
    emitEffect({ ctx: e, rule: r, input: i, type: s, custom: n }, o, a) {
      if (!s || s === "fcFragment") return;
      const u = n || Object.keys(r).reduce((l, c) => (c[0] === "$" && (l[c.substr(1)] = r[c]), l), y({}, r.effect || {}));
      Object.keys(u).forEach((l) => {
        const c = this.providers[l];
        if (!c || c.input && !i) return;
        let m;
        if (!c._c)
          m = "*";
        else if (c._used.indexOf(s) > -1)
          m = s;
        else
          return;
        const v = y({ value: u[l], getValue: () => this.getEffect(r, l) }, a || {});
        e && (v.getProp = () => e.effectData(l), v.clearProp = () => e.clearEffectData(l), v.mergeProp = (_) => U(v.getProp(), [_]), v.id = e.id), this.bus.$emit(`p:${l}:${m}:${c.input ? 1 : 0}`, o, [v, r, this.api]);
      });
    }
  });
}
function br(t) {
  return t.filter(function(e, r, i) {
    return i.indexOf(e, 0) === r;
  });
}
function Cr(t) {
  const e = t.components;
  if (Array.isArray(e)) {
    const r = br(e.filter((i) => i !== "*"));
    return r.length ? r : !1;
  } else return h.String(e) ? [e] : !1;
}
function V(t) {
  p(this, {
    fc: t,
    vm: t.vm,
    watching: !1,
    loading: !1,
    reloading: !1,
    noWatchFn: null,
    deferSyncFn: null,
    isMounted: !1,
    formData: {},
    subForm: {},
    form: {},
    appendData: {},
    providers: {},
    cycleLoad: null,
    loadedId: 1,
    nextTick: null,
    changeStatus: !1,
    pageEnd: !0,
    nextReload: () => {
      this.lifecycle("reload");
    }
  }), Ze(this, {
    options() {
      return t.options;
    },
    bus() {
      return t.bus;
    }
  }), this.initData(t.rules), this.$manager = new t.manager(this), this.$render = new be(this), this.api = t.extendApi(rr(this), this);
}
p(V.prototype, {
  initData(t) {
    p(this, {
      ctxs: {},
      fieldCtx: {},
      nameCtx: {},
      sort: [],
      rules: t
    });
  },
  init() {
    this.appendData = y(y(y({}, this.fc.options.formData || {}), this.vm.value || {}), this.appendData), this.useProvider(), this.usePage(), this.loadRule(), this.$manager.__init(), this.lifecycle("created"), this.vm.$set(this.vm, "formData", this.formData);
  },
  beforeFetch(t) {
    return new Promise((e) => {
      const r = this.options.beforeFetch && R(() => this.options.beforeFetch(t, { api: this.api }));
      r && h.Function(r.then) ? r.then(e) : e();
    });
  }
});
or(V);
ar(V);
ur(V);
hr(V);
mr(V);
gr(V);
$r(V);
vr(V);
const _r = "fcFragment", re = {
  name: _r,
  functional: !0,
  props: ["vnode"],
  render(t, e) {
    return e.props.vnode ? e.props.vnode : e.children;
  }
};
function Or(t) {
  return h.String(t) ? { domProps: { innerHTML: t } } : t;
}
function kr() {
  const t = {};
  function e(r) {
    r && this.setVm(r);
  }
  return p(e.prototype, {
    setVm(r) {
      this.vm = r, this.$h = r.$createElement;
    },
    make(r, i, s) {
      return T.config.isReservedTag(r) && i.nativeOn && delete i.nativeOn, this.makeComponent(r, i, s);
    },
    makeComponent(r, i, s) {
      let n = this.$h(r, Or(i), s || []);
      return n.context = this.vm, n;
    },
    aliasMap: t
  }), p(e, {
    aliasMap: t,
    alias(r, i) {
      t[r] = i;
    },
    use(r) {
      Object.keys(r).forEach((i) => {
        const s = Q(i), n = nt(i).toLocaleLowerCase(), o = r[i];
        [i, s, n].forEach((a) => {
          e.alias(i, o), e.prototype[a] = function(u, l) {
            return this.make(o, u, l);
          };
        });
      });
    }
  }), e;
}
function wr(t) {
  class e extends ot {
  }
  return Object.assign(e.prototype, t), e;
}
function ot(t) {
  p(this, {
    $handle: t,
    vm: t.vm,
    options: {},
    ref: "fcForm",
    mergeOptionsRule: {
      normal: ["form", "row", "info", "submitBtn", "resetBtn"]
    }
  }), this.updateKey(), this.init();
}
p(ot.prototype, {
  __init() {
    this.$render = this.$handle.$render, this.$r = (...t) => this.$render.renderRule(...t);
  },
  updateKey() {
    this.key = ee();
  },
  //TODO interface
  init() {
  },
  update() {
  },
  beforeRender() {
  },
  form() {
    return this.vm.$refs[this.ref];
  },
  getSlot(t) {
    const e = (r) => {
      if (r) {
        let i = r.$scopedSlots[t];
        return i || e(r.$pfc);
      }
    };
    return e(this.vm);
  },
  mergeOptions(t, e) {
    return D(t.map((r) => this.tidyOptions(r)), e, this.mergeOptionsRule);
  },
  updateOptions(t) {
    this.options = this.mergeOptions([t], this.getDefaultOptions()), this.update();
  },
  tidyOptions(t) {
    return t;
  },
  tidyRule(t) {
  },
  mergeProp(t) {
  },
  getDefaultOptions() {
    return {};
  },
  render(t) {
  }
});
const Fr = function(t) {
  const e = {
    name: "loadData",
    _fn: [],
    created(r, i, s) {
      this.deleted(r);
      let n = j(r.getValue());
      const o = [];
      n.forEach((a) => {
        if (a) {
          const u = () => {
            a.watch !== !1 && (t.bus.$off("p.loadData." + a.attr, u), t.bus.$once("p.loadData." + a.attr, u));
            let l;
            a.attr && (l = t.loadData[a.attr] || a.default, a.copy !== !1 && (l = L(l))), Z(r.getProp(), a.to || "options", l), s.sync(i);
          };
          o.push(() => t.bus.$off("p.loadData." + a.attr, u)), u();
        }
      }), this._fn[r.id] = o;
    },
    deleted(r) {
      this._fn[r.id] && (this._fn[r.id].forEach((i) => {
        i();
      }), delete this._fn[r.id]), r.clearProp();
    }
  };
  return e.watch = e.created, e;
}, at = {
  name: "componentValidate",
  load(t, e, r) {
    const i = t.getValue();
    i ? t.getProp().validate = [{
      validator(...s) {
        const n = z(e);
        if (n)
          return r.exec(n.id, i === !0 ? "formCreateValidate" : i, ...s, {
            attr: t,
            rule: e,
            api: r
          });
      }
    }] : (t.clearProp(), r.clearValidateState([e.field]));
  },
  watch(...t) {
    at.load(...t);
  }
}, Er = function(t) {
  function e(i) {
    return h.String(i) && (i = {
      action: i,
      to: "options"
    }), i;
  }
  function r(i, s, n) {
    let o = i.value;
    const a = (m) => {
      m === void 0 ? (i.clearProp(), n.sync(s)) : Z(i.getProp(), o.to || "options", m);
    };
    if (h.Function(o) && (o = o(s, n)), o = e(o), !o || !o.action) {
      a(void 0);
      return;
    }
    o = L(o), o.to || (o.to = "options");
    const u = o.onError, l = () => {
      if (!i.getValue())
        return i.clearProp(), n.sync(s), !0;
    }, c = N(y({
      headers: {}
    }, o), {
      onSuccess(m, v) {
        if (l()) return;
        let _ = (g) => v ? g : k(g, "data") ? g.data : g;
        h.Function(o.parse) ? _ = o.parse : o.parse && h.String(o.parse) && (_ = (g) => (o.parse.split(".").forEach((O) => {
          g && (g = g[O]);
        }), g)), a(_(m, s, n)), n.sync(s);
      },
      onError(m) {
        a(void 0), !l() && (u || ((v) => ge(v.message || "fetch fail " + o.action)))(m, s, n);
      }
    });
    t.$handle.beforeFetch(c, { rule: s, api: n }).then(() => {
      if (h.Function(o.action)) {
        o.action(s, n).then((m) => {
          c.onSuccess(m, !0);
        }).catch((m) => {
          c.onError(m);
        });
        return;
      }
      R(() => t.create.fetch(c, { inject: i, rule: s, api: n }));
    });
  }
  return {
    name: "fetch",
    loaded(...i) {
      r(...i);
    },
    watch(...i) {
      r(...i);
    }
  };
}, lt = {
  name: "required",
  load(t, e, r) {
    const i = Sr(t.getValue());
    if (i.required === !1)
      t.clearProp(), r.clearValidateState([e.field]);
    else {
      const s = y({
        required: !0,
        validator(n, o, a) {
          h.empty(o) ? a(s.message) : a();
        }
      }, i);
      if (!s.message) {
        let n = e.title || "";
        s.message = ((typeof n == "object" ? n.title : n) || "") + "不能为空";
      }
      t.getProp().validate = [s];
    }
    r.sync(e);
  },
  watch(...t) {
    lt.load(...t);
  }
};
function Sr(t) {
  return h.Boolean(t) ? { required: t } : h.String(t) ? { message: t } : h.Undef(t) ? { required: !1 } : h.Function(t) ? { validator: t } : h.Object(t) ? t : {};
}
const Rr = {
  fetch: Er,
  loadData: Fr,
  required: lt,
  componentValidate: at
}, jr = "html", Ir = {
  name: jr,
  loadChildren: !1,
  render(t, e) {
    return e.prop.domProps || (e.prop.domProps = {}), e.prop.domProps.innerHTML = t, e.vNode.make(e.prop.props.tag || "div", e.prop);
  },
  renderChildren(t) {
    return Array.isArray(t.rule.children) ? t.rule.children.filter((e) => h.String(e)).join("") : "";
  }
};
function Ar(t, e) {
  let r;
  return arguments.length === 2 ? (r = arguments[1], e = r[t]) : r = arguments[2], { id: e, prop: r };
}
function ie() {
  return Ar("name", ...arguments);
}
function Me(t) {
  return !t || !t.el ? window.document.body : h.Element(t.el) ? t.el : document.querySelector(t.el);
}
function Ne(t, e) {
  const r = new T({
    data() {
      return { rule: t, option: e || {} };
    },
    render(i) {
      return i("FormCreate", { ref: "fc", props: this.$data });
    }
  });
  return r.$mount(), r;
}
function Vr(t) {
  const e = t.key || [], r = t.array || [], i = t.normal || [];
  Xe.push(...e), pe.push(...r), me.push(...i), et([...e, ...r, ...i]);
}
let Pr = 1;
const S = {};
function ut(t) {
  const e = {
    [re.name]: re
  }, r = {}, i = {}, s = y({}, Rr), n = Yt();
  let o = { global: {} };
  const a = {}, u = kr(), l = {};
  Vr(t.attrs || {});
  function c(f) {
    const d = S[f];
    if (Array.isArray(d))
      return d.map(($) => $.api());
    if (d)
      return d.api();
  }
  function m() {
    const f = ie(...arguments);
    f.id && f.prop && (i[f.id] = f.prop);
  }
  function v() {
    const f = ie(...arguments);
    f.id && f.prop && (s[f.id] = N(y({}, f.prop), { name: f.id }));
  }
  function _(f) {
    u.use(f);
  }
  function g() {
    const f = ie(...arguments);
    if (!f.id || !f.prop) return ce;
    const d = I(f.id), $ = f.prop, b = $.merge === !0 ? r[d] : void 0;
    r[d] = $, Object.setPrototypeOf($, b || ce), n[d] = E(d), $.maker && p(n, $.maker);
  }
  function O(f, d) {
    let $;
    if (h.String(f)) {
      if ($ = I(f), ["form-create", "formcreate"].indexOf($) > -1)
        return W();
      if (d === void 0)
        return e[$];
    } else
      $ = I(f.name), d = f;
    if (!$ || !d) return;
    const b = I($);
    e[$] = d, e[b] = d, delete u.aliasMap[$], delete u.aliasMap[b], delete r[$], delete r[b], d.formCreateParser && g($, d.formCreateParser);
  }
  function Ce(f) {
    Object.keys(S).forEach((d) => {
      (Array.isArray(S[d]) ? S[d] : [S[d]]).forEach((b) => {
        b.bus.$emit("p.loadData." + f);
      });
    });
  }
  function _e(f, d) {
    a[f] = d, Ce(f);
  }
  function Oe(f, d) {
    return k(a, f) ? a[f] : d;
  }
  function ft(f) {
    delete a[f], Ce(f);
  }
  function W() {
    return xt(we, e, i);
  }
  function ke() {
    return re;
  }
  function ht(f, d) {
    return h.Function(f.install) ? f.install(M, d) : h.Function(f) && f(M, d), this;
  }
  function M(f, d, $) {
    let b = Ne(f, d || {});
    const A = b.$refs.fc.formCreate;
    return A.$parent = $, Me(A.options).appendChild(b.$el), A.api();
  }
  Object.setPrototypeOf(M, l);
  function ct(f) {
    let d = y({}, t);
    return f ? d.inherit = {
      components: e,
      parsers: r,
      directives: i,
      providers: s,
      maker: n,
      loadData: a
    } : delete d.inherit, ut(d);
  }
  function we(f) {
    const d = f.$options.propsData.rule;
    p(this, {
      id: Pr++,
      vm: f,
      create: M,
      manager: wr(t.manager),
      parsers: r,
      providers: s,
      rules: Array.isArray(d) ? d : [],
      name: f.$options.propsData.name || ee(),
      inFor: f.$options.propsData.inFor,
      prop: {
        components: e,
        directives: i
      },
      setData: _e,
      getData: Oe,
      loadData: a,
      CreateNode: u,
      bus: new T(),
      unwatch: null,
      options: {},
      extendApi: t.extendApi || (($) => $)
    }), this.init(), this.initOptions(), this.name && (this.inFor ? (S[this.name] || (S[this.name] = []), S[this.name].push(this)) : S[this.name] = this);
  }
  p(we.prototype, {
    init() {
      const f = this.vm, d = new V(this);
      this.$handle = d, f.$f = d.api, f.$emit("input", d.api), f.$on("hook:created", () => {
        this.isSub() && (this.unwatch = f.$watch(() => f.$pfc.option, () => {
          this.initOptions(), f.$f.refresh();
        }, { deep: !0 }), this.initOptions()), this.created();
      }), f.$on("hook:mounted", () => {
        this.mounted();
      }), f.$on("hook:beforeDestroy", () => {
        if (f.destroyed = !0, this.unwatch && this.unwatch(), d.reloadRule([]), this.name)
          if (this.inFor) {
            const $ = S[this.name].indexOf(this);
            S[this.name].splice($, 1), S[this.name].length || delete S[this.name];
          } else
            delete S[this.name];
      }), f.$on("hook:updated", () => {
        d.bindNextTick(() => this.bus.$emit("next-tick", d.api));
      });
    },
    isSub() {
      return this.vm.$pfc && this.vm.extendOption;
    },
    initOptions() {
      this.options = {};
      let f = y({ formData: {}, submitBtn: {}, resetBtn: {} }, L(o));
      this.isSub() && this.mergeOptions(this.options, this.vm.$pfc.$f.config || {}, !0), f = this.mergeOptions(f, this.vm.$options.propsData.option), this.updateOptions(f);
    },
    mergeOptions(f, d, $) {
      return d = L(d), $ && ["page", "onSubmit", "onReset", "onCreated", "onChange", "onMounted", "mounted", "onReload", "reload", "formData", "el"].forEach((b) => {
        delete d[b];
      }), d.global && (f.global = Qt(f.global, d.global), delete d.global), this.$handle.$manager.mergeOptions([d], f), f;
    },
    updateOptions(f) {
      this.mergeOptions(this.options, f), this.$handle.$manager.updateOptions(this.options);
    },
    created() {
      this.$handle.init(), this.vm.$emit("created", this.api());
    },
    api() {
      return this.$handle.api;
    },
    render() {
      return this.$handle.render();
    },
    mounted() {
      this.$handle.mounted();
    }
  });
  function Fe(f) {
    p(f, {
      version: t.version,
      ui: t.ui,
      setData: _e,
      getData: Oe,
      removeData: ft,
      maker: n,
      component: O,
      directive: m,
      register: v,
      $vnode: ke,
      parser: g,
      use: ht,
      factory: ct,
      componentAlias: _,
      copyRule: $e,
      copyRules: Qe,
      fetch: rt,
      $form: W,
      parseFn: q,
      parseJson: zt,
      toJson: ze,
      getApi: c,
      init(d, $ = {}) {
        let b = Ne(d, $), A = b.$refs.fc.formCreate;
        return {
          mount(J) {
            return J && h.Element(J) && (A.options.el = J), Me(A.options).appendChild(b.$el), A.api();
          },
          remove() {
            b.$el.parentNode && b.$el.parentNode.removeChild(b.$el);
          },
          destroy() {
            this.remove(), b.$destroy();
          },
          $f: A.api()
        };
      }
    });
  }
  function dt(f) {
    p(f, {
      create: M,
      install(d, $) {
        if (o = y(y({}, o), $ || {}), d._installedFormCreate === !0) return;
        d._installedFormCreate = !0;
        const b = function(A, J = {}) {
          return M(A, J, this);
        };
        Fe(b), d.prototype.$formCreate = b, d.component("FormCreate", W()), d.component("FcFragment", ke());
      }
    });
  }
  if (Fe(l), dt(l), u.use({ fragment: "fcFragment" }), g(Ir), t.install && M.use(t), t.inherit) {
    const f = t.inherit;
    f.components && p(e, f.components), f.parsers && p(r, f.parsers), f.directives && p(i, f.directives), f.providers && p(s, f.providers), f.maker && p(n, f.maker), f.loadData && p(a, f.loadData);
  }
  const G = W();
  return Object.setPrototypeOf(G, l), Object.defineProperties(G, {
    fetch: {
      get() {
        return l.fetch;
      },
      set(f) {
        l.fetch = f;
      }
    }
  }), G.util = l, G;
}
const qe = {
  date: "yyyy-MM-dd",
  month: "yyyy-MM",
  datetime: "yyyy-MM-dd HH:mm:ss",
  timerange: "HH:mm:ss",
  daterange: "yyyy-MM-dd",
  monthrange: "yyyy-MM",
  datetimerange: "yyyy-MM-dd HH:mm:ss",
  year: "yyyy"
}, Ue = "datePicker", Tr = {
  name: Ue,
  maker: function() {
    return ["year", "month", "date", "dates", "week", "datetime", "datetimeRange", "dateRange", "monthRange"].reduce((t, e) => (t[e] = E(Ue, { type: e.toLowerCase() }), t), {});
  }(),
  mergeProp(t) {
    const e = t.prop.props;
    e.valueFormat || (e.valueFormat = qe[e.type] || qe.date);
  }
}, ne = "hidden", Dr = {
  name: ne,
  maker: {
    [ne]: (t, e) => E(ne)("", t, e)
  },
  render() {
    return [];
  }
}, se = "input", Br = {
  name: se,
  maker: function() {
    const t = ["password", "url", "email", "text", "textarea"].reduce((e, r) => (e[r] = E(se, { type: r }), e), {});
    return t.idate = E(se, { type: "date" }), t;
  }(),
  mergeProp(t) {
    let { props: e } = t.prop;
    e && e.autosize && e.autosize.minRows && (e.rows = e.autosize.minRows || 2);
  }
}, He = "slider", Lr = {
  name: He,
  maker: {
    sliderRange: E(He, { range: !0 })
  },
  toFormValue(t, e) {
    let r = Array.isArray(t), i = e.prop.props, s = i.min || 0, n;
    return i.range === !0 ? n = r ? t : [s, parseFloat(t) || s] : n = r ? parseFloat(t[0]) || s : parseFloat(t), n;
  }
}, oe = "timePicker", Mr = {
  name: oe,
  maker: {
    time: E(oe, (t) => t.props.isRange = !1),
    timeRange: E(oe, (t) => t.props.isRange = !0)
  },
  mergeProp(t) {
    const e = t.prop.props;
    e.valueFormat || (e.valueFormat = "HH:mm:ss");
  }
}, Nr = {
  name: "FcRow",
  render(t, e) {
    return e.vNode.col({ props: { span: 24 } }, [
      e.vNode.row(e.prop, t)
    ]);
  }
}, qr = "select", Ur = {
  name: qr,
  toFormValue(t, e) {
    return e.prop.props.multiple && !Array.isArray(t) ? j(t) : t;
  }
}, Hr = [
  Tr,
  Dr,
  Br,
  Lr,
  Mr,
  Nr,
  Ur
], C = "el", Jr = {
  button: C + "Button",
  icon: "i",
  slider: C + "Slider",
  rate: C + "Rate",
  upload: "fcUpload",
  cascader: C + "Cascader",
  popover: C + "Popover",
  tooltip: C + "Tooltip",
  colorPicker: C + "ColorPicker",
  timePicker: C + "TimePicker",
  timeSelect: C + "TimeSelect",
  datePicker: C + "DatePicker",
  switch: C + "Switch",
  select: "fcSelect",
  checkbox: "fcCheckbox",
  radio: "fcRadio",
  inputNumber: C + "InputNumber",
  number: C + "InputNumber",
  input: C + "Input",
  formItem: C + "FormItem",
  form: C + "Form",
  frame: "fcFrame",
  col: C + "Col",
  row: C + "Row",
  tree: "fcTree",
  autoComplete: C + "Autocomplete",
  auto: C + "Autocomplete",
  group: "fcGroup",
  object: "fcSubForm",
  subForm: "fcSubForm"
};
function xr() {
  return {
    form: {
      inline: !1,
      labelPosition: "right",
      labelWidth: "125px",
      disabled: !1,
      size: void 0
    },
    row: {
      show: !0,
      gutter: 0
    },
    submitBtn: {
      type: "primary",
      loading: !1,
      disabled: !1,
      innerText: "提交",
      show: !0,
      col: void 0,
      click: void 0
    },
    resetBtn: {
      type: "default",
      loading: !1,
      disabled: !1,
      icon: "el-icon-refresh",
      innerText: "重置",
      show: !1,
      col: void 0,
      click: void 0
    }
  };
}
function Kr(t) {
  return t.type === "tooltip";
}
const Wr = /[A-Z]/;
function Gr(t, e) {
  return !Wr.test(t) && (h.String(e) || h.Number(e));
}
function Je(t, e) {
  k(t, e) && h.String(t[e]) && (t[e] = { [e]: t[e], show: !0 });
}
function P(t) {
  return t === !1;
}
function Xr(t, e) {
  k(t, e) && !h.Object(t[e]) && (t[e] = { show: !!t[e] });
}
const zr = {
  validate() {
    const t = this.form();
    return t ? t.validate() : new Promise((e) => e());
  },
  validateField(t) {
    const e = this.form();
    return e ? new Promise((r, i) => {
      e.validateField(t, (s) => {
        s ? i(s) : r(null);
      });
    }) : new Promise((r) => r());
  },
  clearValidateState(t) {
    const e = this.vm.$refs[t.wrapRef];
    e && (e.validateMessage = "", e.validateState = "");
  },
  tidyOptions(t) {
    return ["submitBtn", "resetBtn", "row", "info", "wrap", "col", "title"].forEach((e) => {
      Xr(t, e);
    }), t;
  },
  tidyRule({ prop: t }) {
    return Je(t, "title"), Je(t, "info"), t;
  },
  mergeProp(t) {
    let e = t.prop.props;
    t.prop = D([{
      attrs: Object.keys(e).reduce((r, i) => (Gr(i, e[i]) && (r[i] = e[i]), r), {}),
      info: this.options.info || {},
      wrap: this.options.wrap || {},
      col: this.options.col || {},
      title: this.options.title || {}
    }, t.prop], {
      info: {
        trigger: "hover",
        placement: "top-start",
        icon: "el-icon-warning"
      },
      title: {},
      col: { span: 24 },
      wrap: {}
    }, { normal: ["title", "info", "col", "wrap"] });
  },
  getDefaultOptions() {
    return xr();
  },
  update() {
    const t = this.options.form;
    this.rule = {
      props: y({}, t),
      nativeOn: {
        submit: (e) => {
          e.preventDefault();
        }
      },
      class: [t.className, t.class, "form-create"],
      style: t.style,
      type: "form"
    };
  },
  beforeRender() {
    const { key: t, ref: e, $handle: r } = this;
    p(this.rule, { key: t, ref: e }), p(this.rule.props, {
      model: r.formData
      // rules: $handle.validate(),
    });
  },
  render(t) {
    return t.length && t.push(this.makeFormBtn()), this.$r(this.rule, P(this.options.row.show) ? t : [this.makeRow(t)]);
  },
  makeWrap(t, e) {
    const r = t.prop, i = `${this.key}${t.key}`, s = r.col, n = this.isTitle(r), o = !s.labelWidth && !n ? 0 : s.labelWidth, { inline: a, col: u } = this.rule.props, l = P(r.wrap.show) ? e : this.$r(D([r.wrap, {
      props: N(y({
        labelWidth: o === void 0 ? o : nt(o),
        label: n ? r.title.title : void 0
      }, r.wrap || {}), {
        prop: t.id,
        rules: t.injectValidate()
      }),
      class: r.className,
      key: `${i}fi`,
      ref: t.wrapRef,
      type: "formItem"
    }]), [e, n ? this.makeInfo(r, i, t) : null]);
    return a === !0 || P(u) || P(s.show) ? l : this.makeCol(r, i, [l]);
  },
  isTitle(t) {
    if (this.options.form.title === !1) return !1;
    const e = t.title;
    return !(!e.title && !e.native || P(e.show));
  },
  makeInfo(t, e, r) {
    const i = t.title, s = t.info, n = Kr(s), o = this.options.form, a = this.getSlot("title"), u = [a ? a({ title: i.title || "", rule: r.rule, options: this.options }) : (i.title || "") + (o.labelSuffix || o["label-suffix"] || "")];
    if (!P(s.show) && (s.info || s.native) && !P(s.icon)) {
      const l = {
        type: s.type || "popover",
        props: y({}, s),
        key: `${e}pop`,
        slot: "label"
      }, c = "content";
      s.info && !k(l.props, c) && (l.props[c] = s.info), u[s.align !== "left" ? "unshift" : "push"](this.$r(D([s, l]), [
        this.$r({
          type: "i",
          slot: n ? "default" : "reference",
          class: s.icon === !0 ? "el-icon-warning" : s.icon,
          key: `${e}i`
        })
      ]));
    }
    return this.$r(D([i, {
      props: i,
      slot: i.slot || "label",
      key: `${e}tit`,
      type: i.type || "span"
    }]), u);
  },
  makeCol(t, e, r) {
    const i = t.col;
    return this.$r({
      class: i.class,
      type: "col",
      props: i || { span: 24 },
      key: `${e}col`
    }, r);
  },
  makeRow(t) {
    const e = this.options.row || {};
    return this.$r({
      type: "row",
      props: e,
      class: e.class,
      key: `${this.key}row`
    }, t);
  },
  makeFormBtn() {
    let t = [];
    if (P(this.options.submitBtn.show) || t.push(this.makeSubmitBtn()), P(this.options.resetBtn.show) || t.push(this.makeResetBtn()), !t.length)
      return;
    const e = this.$r({
      type: "formItem",
      key: `${this.key}fb`
    }, t);
    return this.rule.props.inline === !0 ? e : this.$r({
      type: "col",
      props: { span: 24 },
      key: `${this.key}fc`
    }, [e]);
  },
  makeResetBtn() {
    const t = this.options.resetBtn;
    return this.$r({
      type: "button",
      props: t,
      style: { width: t.width },
      on: {
        click: () => {
          const e = this.$handle.api;
          t.click ? t.click(e) : e.resetFields();
        }
      },
      key: `${this.key}b2`
    }, [t.innerText]);
  },
  makeSubmitBtn() {
    const t = this.options.submitBtn;
    return this.$r({
      type: "button",
      props: t,
      style: { width: t.width },
      on: {
        click: () => {
          const e = this.$handle.api;
          t.click ? t.click(e) : e.submit();
        }
      },
      key: `${this.key}b1`
    }, [t.innerText]);
  }
}, H = {};
Qr(H);
Zr(H);
Yr(H);
ei(H);
ti(H);
function Qr(t) {
  ["group", "tree", "switch", "upload", "autoComplete", "checkbox", "cascader", "colorPicker", "datePicker", "frame", "inputNumber", "radio", "rate"].forEach((e) => {
    t[e] = E(e);
  }), t.auto = t.autoComplete, t.number = t.inputNumber, t.color = t.colorPicker;
}
function Zr(t) {
  const e = "select", r = "multiple";
  t.selectMultiple = E(e, { [r]: !0 }), t.selectOne = E(e, { [r]: !1 });
}
function Yr(t) {
  const e = "tree", r = { treeSelected: "selected", treeChecked: "checked" };
  Object.keys(r).reduce((i, s) => (i[s] = E(e, { type: r[s] }), i), t);
}
function ei(t) {
  const e = "upload", r = {
    image: ["image", 0],
    file: ["file", 0],
    uploadFileOne: ["file", 1],
    uploadImageOne: ["image", 1]
  };
  Object.keys(r).reduce((i, s) => (i[s] = E(e, (n) => n.props({ uploadType: r[s][0], maxLength: r[s][1] })), i), t), t.uploadImage = t.image, t.uploadFile = t.file;
}
function ti(t) {
  const e = {
    frameInputs: ["input", 0],
    frameFiles: ["file", 0],
    frameImages: ["image", 0],
    frameInputOne: ["input", 1],
    frameFileOne: ["file", 1],
    frameImageOne: ["image", 1]
  };
  return Object.keys(e).reduce((r, i) => (r[i] = E("frame", (s) => s.props({ type: e[i][0], maxLength: e[i][1] })), r), t), t.frameInput = t.frameInputs, t.frameFile = t.frameFiles, t.frameImage = t.frameImages, t;
}
function xe(t, e) {
  return h.Boolean(t) ? t = { show: t } : !h.Undef(t) && !h.Object(t) && (t = { show: e }), t;
}
function ri(t, e) {
  return p(t, {
    formEl() {
      return e.$manager.form();
    },
    wrapEl(r) {
      const i = e.getFieldCtx(r);
      if (i)
        return e.vm.$refs[i.wrapRef];
    },
    validate(r) {
      return new Promise((i, s) => {
        const n = t.children, o = [e.$manager.validate()];
        n.forEach((a) => {
          o.push(a.validate());
        }), Promise.all(o).then(() => {
          i(!0), r && r(!0);
        }).catch((a) => {
          s(a), r && r(!1, a), e.vm.$emit("validate-fail", a, { api: t });
        });
      });
    },
    validateField: (r, i) => new Promise((s, n) => {
      const o = e.getFieldCtx(r);
      if (!o) return;
      const a = e.subForm[o.id], u = [e.$manager.validateField(o.id)];
      j(a).forEach((l) => {
        u.push(l.validate().catch(() => Promise.reject("子表单验证未通过")));
      }), Promise.all(u).then(() => {
        s(null), i && i(null);
      }).catch((l) => {
        n(l), i && i(l), e.vm.$emit("validate-field-fail", l, { field: r, api: t });
      });
    }),
    clearValidateState(r, i = !0) {
      t.helper.tidyFields(r).forEach((s) => {
        i && this.clearSubValidateState(s), e.getCtxs(s).forEach((n) => {
          e.$manager.clearValidateState(n);
        });
      });
    },
    clearSubValidateState(r) {
      t.helper.tidyFields(r).forEach((i) => {
        e.getCtxs(i).forEach((s) => {
          const n = e.subForm[s.id];
          n && (Array.isArray(n) ? n.forEach((o) => {
            o.clearValidateState();
          }) : n && n.clearValidateState());
        });
      });
    },
    btn: {
      loading: (r = !0) => {
        t.submitBtnProps({ loading: !!r });
      },
      disabled: (r = !0) => {
        t.submitBtnProps({ disabled: !!r });
      },
      show: (r = !0) => {
        t.submitBtnProps({ show: !!r });
      }
    },
    resetBtn: {
      loading: (r = !0) => {
        t.resetBtnProps({ loading: !!r });
      },
      disabled: (r = !0) => {
        t.resetBtnProps({ disabled: !!r });
      },
      show: (r = !0) => {
        t.resetBtnProps({ show: !!r });
      }
    },
    submitBtnProps: (r = {}) => {
      let i = xe(e.options.submitBtn, !0);
      p(i, r), e.options.submitBtn = i, t.refreshOptions();
    },
    resetBtnProps: (r = {}) => {
      let i = xe(e.options.resetBtn, !1);
      p(i, r), e.options.resetBtn = i, t.refreshOptions();
    },
    submit(r, i) {
      t.validate((s) => {
        if (s) {
          let n = t.formData();
          h.Function(r) ? R(() => r(n, this)) : (h.Function(e.options.onSubmit) && R(() => e.options.onSubmit(n, this)), e.vm.$emit("submit", n, this));
        } else
          h.Function(i) && R(() => i(this, ...arguments));
      }).catch((s) => {
      });
    }
  }), t;
}
function ii(t) {
  t.componentAlias(Jr), Jt.forEach((e) => {
    t.component(e.name, e);
  }), Hr.forEach((e) => {
    t.parser(e);
  }), Object.keys(H).forEach((e) => {
    t.maker[e] = H[e];
  });
}
function ni() {
  return ut({
    ui: "element-ui",
    version: "2.6.3",
    manager: zr,
    extendApi: ri,
    install: ii,
    attrs: {
      normal: ["col", "wrap"],
      array: ["className"],
      key: ["title", "info"]
    }
  });
}
const de = ni();
typeof window != "undefined" && (window.formCreate = de, window.Vue && de.install(window.Vue));
const ai = de.maker;
export {
  de as default,
  ai as maker
};
