(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "@vxe-ui/core", "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUITable"] = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else
		root["VxeUITable"] = factory(root["Vue"], root["VxeUI"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__4345__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 4345:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4345__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 2195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 9519:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var userAgent = __webpack_require__(2839);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(2195);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(2195);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4576);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.38.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(9519);
var fails = __webpack_require__(9039);
var globalThis = __webpack_require__(4576);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Colgroup: function() { return /* reexport */ Colgroup; },
  Column: function() { return /* reexport */ Column; },
  Grid: function() { return /* reexport */ Grid; },
  Table: function() { return /* reexport */ Table; },
  Toolbar: function() { return /* reexport */ Toolbar; },
  VXETable: function() { return /* reexport */ VXETable; },
  VxeColgroup: function() { return /* reexport */ VxeColgroup; },
  VxeColumn: function() { return /* reexport */ VxeColumn; },
  VxeGrid: function() { return /* reexport */ VxeGrid; },
  VxeTable: function() { return /* reexport */ VxeTable; },
  VxeToolbar: function() { return /* reexport */ VxeToolbar; },
  VxeUI: function() { return /* reexport */ core_.VxeUI; },
  _t: function() { return /* reexport */ _t; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  config: function() { return /* reexport */ config; },
  "default": function() { return /* binding */ entry_lib; },
  formats: function() { return /* reexport */ formats; },
  getConfig: function() { return /* reexport */ getConfig; },
  getI18n: function() { return /* reexport */ getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ modal; },
  print: function() { return /* reexport */ print; },
  readFile: function() { return /* reexport */ readFile; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  t: function() { return /* reexport */ t; },
  use: function() { return /* reexport */ use; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ version; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Colgroup: function() { return Colgroup; },
  Column: function() { return Column; },
  Grid: function() { return Grid; },
  Table: function() { return Table; },
  Toolbar: function() { return Toolbar; },
  VXETable: function() { return VXETable; },
  VxeColgroup: function() { return VxeColgroup; },
  VxeColumn: function() { return VxeColumn; },
  VxeGrid: function() { return VxeGrid; },
  VxeTable: function() { return VxeTable; },
  VxeToolbar: function() { return VxeToolbar; },
  VxeUI: function() { return core_.VxeUI; },
  _t: function() { return _t; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  config: function() { return config; },
  formats: function() { return formats; },
  getConfig: function() { return getConfig; },
  getI18n: function() { return getI18n; },
  getIcon: function() { return getIcon; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return modal; },
  print: function() { return print; },
  readFile: function() { return readFile; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  t: function() { return t; },
  use: function() { return use; },
  validators: function() { return validators; },
  version: function() { return version; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: external {"root":"VxeUI","commonjs":"@vxe-ui/core","commonjs2":"@vxe-ui/core","amd":"@vxe-ui/core"}
var core_ = __webpack_require__(4345);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// CONCATENATED MODULE: ./node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = 'z-index-manage';
var styleEl = null;
var styleId = 'z-index-style';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== 'undefined') {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName('body')[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName('*');
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement('style');
        styleEl.id = styleId;
        dom.getElementsByTagName('head')[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = '--dom-';
    var propKey = '-z-index';
    styEl.innerHTML = ':root{' + prefixes + 'main' + propKey + ':' + getCurrent() + ';' + prefixes + 'sub' + propKey + ':' + getSubCurrent() + '}';
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement('div');
          storeEl.id = storeId;
          storeEl.style.display = 'none';
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + '';
        } else {
          el.setAttribute('data-' + key, value + '');
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
/* harmony default export */ var index_esm = (DomZIndex);
;// CONCATENATED MODULE: ./packages/ui/src/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content, args) {
  if (content) {
    const translate = core_.VxeUI.getConfig().translate;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(translate ? translate('' + content, args) : content);
  }
  return '';
}
function formatText(value, placeholder) {
  return '' + (isEmptyValue(value) ? placeholder ? core_.VxeUI.getConfig().emptyCell : '' : value);
}
/**
 * 判断值为：'' | null | undefined 时都属于空值
 */
function eqEmptyValue(cellValue) {
  return cellValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue);
}
function getClass(property, params) {
  return property ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(property) ? property(params) : property : '';
}
;// CONCATENATED MODULE: ./packages/ui/index.ts


const version = "3.15.37";
core_.VxeUI.version = version;
core_.VxeUI.tableVersion = version;
core_.VxeUI.setConfig({
  emptyCell: '　',
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    padding: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      // refreshDelay: 20
    },
    resizableConfig: {
      dragMode: 'auto',
      showDragTip: true,
      isSyncAutoHeight: true,
      isSyncAutoWidth: true,
      minHeight: 18
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    rowDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    columnDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: 'inline',
      msgMode: 'single',
      theme: 'beautify'
    },
    columnConfig: {
      maxFixedSize: 4
    },
    cellConfig: {
      padding: true
    },
    headerCellConfig: {
      height: 'unset'
    },
    footerCellConfig: {
      height: 'unset'
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      // enabled: false,
      allowVisible: true,
      allowResizable: true,
      allowFixed: true,
      allowSort: true,
      showFooter: true,
      placement: 'top-right',
      //  storage: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: true,
        mask: true,
        lockView: true,
        resize: true,
        escClosable: true
      },
      drawerOptions: {
        mask: true,
        lockView: true,
        escClosable: true,
        resize: true
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      allowClear: true,
      allowBtn: true,
      iconLayout: 'vertical'
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      // destroyOnClose: false,
      // isEvery: false,
      showIcon: true
    },
    aggregateConfig: {
      padding: true,
      rowField: 'id',
      parentField: '_X_ROW_PARENT_KEY',
      childrenField: '_X_ROW_CHILDREN',
      mapChildrenField: '_X_ROW_CHILD_LIST',
      indent: 20,
      showIcon: true
    },
    treeConfig: {
      padding: true,
      rowField: 'id',
      parentField: 'parentId',
      childrenField: 'children',
      hasChildField: 'hasChild',
      mapChildrenField: '_X_ROW_CHILD',
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true,
      mode: 'fixed'
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true,
      autoFocus: true
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true,
      selectCellByBody: true,
      extendDirection: {
        top: true,
        left: true,
        bottom: true,
        right: true
      }
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    virtualXConfig: {
      // enabled: false,
      gt: 24,
      preSize: 0,
      oSize: 0
    },
    virtualYConfig: {
      // enabled: false,
      gt: 100,
      preSize: 1,
      oSize: 0
    },
    scrollbarConfig: {
      // width: 14,
      // height: 14
    }
  },
  // export: {
  //   types: {}
  // },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      showResponseMsg: true,
      showActiveMsg: true,
      props: {
        list: null,
        result: 'result',
        total: 'page.total',
        message: 'message'
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  }
});
const iconPrefix = 'vxe-table-icon-';
core_.VxeUI.setIcon({
  // table
  TABLE_SORT_ASC: iconPrefix + 'caret-up',
  TABLE_SORT_DESC: iconPrefix + 'caret-down',
  TABLE_FILTER_NONE: iconPrefix + 'funnel',
  TABLE_FILTER_MATCH: iconPrefix + 'funnel',
  TABLE_EDIT: iconPrefix + 'edit',
  TABLE_TITLE_PREFIX: iconPrefix + 'question-circle-fill',
  TABLE_TITLE_SUFFIX: iconPrefix + 'question-circle-fill',
  TABLE_TREE_LOADED: iconPrefix + 'spinner roll',
  TABLE_TREE_OPEN: iconPrefix + 'caret-right rotate90',
  TABLE_TREE_CLOSE: iconPrefix + 'caret-right',
  TABLE_EXPAND_LOADED: iconPrefix + 'spinner roll',
  TABLE_EXPAND_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_EXPAND_CLOSE: iconPrefix + 'arrow-right',
  TABLE_CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  TABLE_CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  TABLE_CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  TABLE_RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  TABLE_RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  TABLE_CUSTOM_SORT: iconPrefix + 'drag-handle',
  TABLE_MENU_OPTIONS: iconPrefix + 'arrow-right',
  TABLE_DRAG_ROW: iconPrefix + 'drag-handle',
  TABLE_DRAG_COLUMN: iconPrefix + 'drag-handle',
  TABLE_DRAG_STATUS_ROW: iconPrefix + 'sort',
  TABLE_DRAG_STATUS_SUB_ROW: iconPrefix + 'add-sub',
  TABLE_DRAG_STATUS_COLUMN: iconPrefix + 'swap',
  TABLE_DRAG_DISABLED: iconPrefix + 'no-drop',
  TABLE_ROW_GROUP_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_ROW_GROUP_CLOSE: iconPrefix + 'arrow-right',
  // toolbar
  TOOLBAR_TOOLS_REFRESH: iconPrefix + 'repeat',
  TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + 'repeat roll',
  TOOLBAR_TOOLS_IMPORT: iconPrefix + 'upload',
  TOOLBAR_TOOLS_EXPORT: iconPrefix + 'download',
  TOOLBAR_TOOLS_PRINT: iconPrefix + 'print',
  TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + 'fullscreen',
  TOOLBAR_TOOLS_MINIMIZE: iconPrefix + 'minimize',
  TOOLBAR_TOOLS_CUSTOM: iconPrefix + 'custom-column',
  TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + 'fixed-left',
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: iconPrefix + 'fixed-left-fill',
  TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + 'fixed-right',
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: iconPrefix + 'fixed-right-fill'
});
const setTheme = core_.VxeUI.setTheme;
const getTheme = core_.VxeUI.getTheme;
const setConfig = core_.VxeUI.setConfig;
const getConfig = core_.VxeUI.getConfig;
const setIcon = core_.VxeUI.setIcon;
const getIcon = core_.VxeUI.getIcon;
const setLanguage = core_.VxeUI.setLanguage;
const setI18n = core_.VxeUI.setI18n;
const getI18n = core_.VxeUI.getI18n;
const globalEvents = core_.VxeUI.globalEvents;
const globalResize = core_.VxeUI.globalResize;
const renderer = core_.VxeUI.renderer;
const validators = core_.VxeUI.validators;
const menus = core_.VxeUI.menus;
const formats = core_.VxeUI.formats;
const commands = core_.VxeUI.commands;
const interceptor = core_.VxeUI.interceptor;
const clipboard = core_.VxeUI.clipboard;
const log = core_.VxeUI.log;
const use = core_.VxeUI.use;
/**
 * 已废弃
 * @deprecated
 */
const setup = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.setup = setup;
/**
 * 已废弃
 * @deprecated
 */
const config = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.config = config;
/**
 * 已废弃
 * @deprecated
 */
const t = (key, args) => {
  return core_.VxeUI.getI18n(key, args);
};
core_.VxeUI.t = t;
/**
 * 已废弃
 * @deprecated
 */
const _t = (content, args) => {
  return getFuncText(content, args);
};
core_.VxeUI._t = _t;
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const VXETable = core_.VxeUI;
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const saveFile = options => {
  return core_.VxeUI.saveFile(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const readFile = options => {
  return core_.VxeUI.readFile(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const print = options => {
  return core_.VxeUI.print(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const modal = {
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  get(id) {
    return core_.VxeUI.modal.get(id);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  close(id) {
    return core_.VxeUI.modal.close(id);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  open(options) {
    return core_.VxeUI.modal.open(options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  alert(content, title, options) {
    return core_.VxeUI.modal.alert(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  confirm(content, title, options) {
    return core_.VxeUI.modal.confirm(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  message(content, options) {
    return core_.VxeUI.modal.message(content, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  notification(content, title, options) {
    return core_.VxeUI.modal.notification(content, title, options);
  }
};

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
;// CONCATENATED MODULE: ./packages/ui/src/dom.ts

const reClsMap = {};
let tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
function getPropClass(property, params) {
  return property ? XEUtils.isFunction(property) ? property(params) : property : '';
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = 'px') {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ''}`;
}
function queryElement(elem, selector) {
  if (elem) {
    return elem.querySelector(selector);
  }
  return null;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
// export function setScrollLeftAndTop (elem: HTMLElement | null, scrollLeft: number, scrollTop: number) {
//   if (elem) {
//     elem.scrollLeft = scrollLeft
//     elem.scrollTop = scrollTop
//   }
// }
function updateCellTitle(overflowElem, column) {
  const content = column.type === 'html' ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute('title') !== content) {
    overflowElem.setAttribute('title', content);
  }
}
/**
 * 检查触发源是否属于目标节点
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * 获取元素相对于 document 的位置
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
;// CONCATENATED MODULE: ./packages/ui/src/log.ts

const {
  log: log_log
} = core_.VxeUI;
const log_version = `table v${"3.15.37"}`;
const warnLog = log_log.create('warn', log_version);
const errLog = log_log.create('error', log_version);
;// CONCATENATED MODULE: ./packages/table/src/columnInfo.ts





const {
  getI18n: columnInfo_getI18n,
  formats: columnInfo_formats
} = core_.VxeUI;
class ColumnInfo {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xeTable, _vm, {
    renderHeader,
    renderCell,
    renderFooter,
    renderData
  } = {}) {
    const tableProps = $xeTable;
    const $xeGrid = $xeTable.$xeGrid;
    const proxyOpts = $xeGrid ? $xeGrid.proxyOpts : null;
    const formatter = _vm.formatter;
    const visible = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.visible) ? _vm.visible : true;
    const types = ['seq', 'checkbox', 'radio', 'expand', 'html'];
    if (_vm.type && types.indexOf(_vm.type) === -1) {
      warnLog('vxe.error.errProp', [`type=${_vm.type}`, types.join(', ')]);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.cellRender) || _vm.cellRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.cellRender)) {
      warnLog('vxe.error.errProp', [`column.cell-render=${_vm.cellRender}`, 'column.cell-render={}']);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.editRender) || _vm.editRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.editRender)) {
      warnLog('vxe.error.errProp', [`column.edit-render=${_vm.editRender}`, 'column.edit-render={}']);
    }
    if (_vm.type === 'expand') {
      const {
        treeConfig
      } = tableProps;
      if (treeConfig && ($xeTable.treeOpts.showLine || $xeTable.treeOpts.line)) {
        errLog('vxe.error.errConflicts', ['tree-config.line', 'column.type=expand']);
      }
    }
    if (_vm.remoteSort) {
      warnLog('vxe.error.delProp', ['column.remote-sort', 'sort-config.remote']);
    }
    if (_vm.sortMethod) {
      warnLog('vxe.error.delProp', ['column.sort-method', 'sort-config.sortMethod']);
    }
    if (formatter) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter]);
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter[0]) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter[0]];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter[0]]);
        }
      }
    }
    Object.assign(this, {
      // 基本属性
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      footerFormatter: _vm.footerFormatter,
      padding: _vm.padding,
      verticalAlign: _vm.verticalAlign,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      sortMethod: _vm.sortMethod,
      remoteSort: _vm.remoteSort,
      filters: toFilters(_vm.filters),
      filterMultiple: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      rowGroupNode: _vm.rowGroupNode,
      treeNode: _vm.treeNode,
      dragSort: _vm.dragSort,
      rowResize: _vm.rowResize,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      aggFunc: _vm.aggFunc,
      // 自定义参数
      params: _vm.params,
      // 渲染属性
      id: _vm.colId || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('col_'),
      parentId: null,
      visible,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      level: 1,
      rowSpan: 1,
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderAggFn: '',
      renderFixed: '',
      renderVisible: false,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      // 单元格插槽，只对 grid 有效
      slots: _vm.slots
    });
    if (proxyOpts && proxyOpts.beforeColumn) {
      proxyOpts.beforeColumn({
        $grid: $xeGrid,
        column: this
      });
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === 'seq' ? columnInfo_getI18n('vxe.table.seqTitle') : ''));
  }
  getKey() {
    const {
      type
    } = this;
    return this.field || (type ? `type=${type}` : null);
  }
  update(name, value) {
    // 不支持直接修改的属性
    if (name !== 'filters') {
      if (name === 'field') {
        // 兼容旧属性
        this.property = value;
      }
      this[name] = value;
    }
  }
}
;// CONCATENATED MODULE: ./packages/table/src/util.ts






const getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach(column => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some(column => column.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
const convertHeaderColumnToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xeTable, scrollLeft, scrollTop) {
  const internalData = $xeTable;
  if (scrollLeft || scrollTop) {
    internalData.intoRunScroll = false;
    internalData.inVirtualScroll = false;
    internalData.inWheelScroll = false;
    internalData.inHeaderScroll = false;
    internalData.inBodyScroll = false;
    internalData.inFooterScroll = false;
    internalData.scrollRenderType = '';
    // 还原滚动状态
    return $xeTable.scrollTo(scrollLeft, scrollTop);
  }
  return $xeTable.clearScroll();
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
}
/**
 * 生成行的唯一主键
 */
function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
function hasDeepKey(rowKey) {
  return rowKey.indexOf('.') > -1;
}
// 行主键 key
function getRowkey($xeTable) {
  const internalData = $xeTable;
  const {
    currKeyField
  } = internalData;
  return currKeyField;
}
// 行主键 value
function getRowid($xeTable, row) {
  const internalData = $xeTable;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  return row ? encodeRowid((isCurrDeepKey ? getDeepRowIdByKey : getFastRowIdByKey)(row, currKeyField)) : '';
}
function createHandleUpdateRowId($xeTable) {
  const internalData = $xeTable;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  const updateRId = isCurrDeepKey ? updateDeepRowKey : updateFastRowKey;
  return {
    rowKey: currKeyField,
    handleUpdateRowId(row) {
      return row ? updateRId(row, currKeyField) : '';
    }
  };
}
function createHandleGetRowId($xeTable) {
  const internalData = $xeTable;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  const getRId = isCurrDeepKey ? getDeepRowIdByKey : getFastRowIdByKey;
  return {
    rowKey: currKeyField,
    handleGetRowId(row) {
      return row ? encodeRowid(getRId(row, currKeyField)) : '';
    }
  };
}
// 编码行主键
function encodeRowid(rowVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rowVal) ? '' : encodeURIComponent(rowVal);
}
function getDeepRowIdByKey(row, rowKey) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowKey);
}
function updateDeepRowKey(row, rowKey) {
  let rowid = encodeRowid(getDeepRowIdByKey(row, rowKey));
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, rowKey, rowid);
  }
  return rowid;
}
function getFastRowIdByKey(row, rowKey) {
  return row[rowKey];
}
function updateFastRowKey(row, rowKey) {
  let rowid = encodeRowid(getFastRowIdByKey(row, rowKey));
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    row[rowKey] = rowid;
  }
  return rowid;
}
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingLeft);
    const paddingRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElementMarginAndWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginLeft);
    const marginRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function getCellHeight(height) {
  if (height === 'unset') {
    return 0;
  }
  return height || 0;
}
function handleFieldOrColumn($xeTable, fieldOrColumn) {
  if (fieldOrColumn) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(fieldOrColumn) ? $xeTable.getColumnByField(`${fieldOrColumn}`) : fieldOrColumn;
  }
  return null;
}
function handleRowidOrRow($xeTable, rowidOrRow) {
  if (rowidOrRow) {
    const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowidOrRow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
    return $xeTable.getRowById(rowid);
  }
  return null;
}
function getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight) {
  return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
}
// 组装列配置
function assembleColumn(_vm) {
  const $xeTable = _vm.$xeTable;
  const reactData = $xeTable;
  const {
    staticColumns
  } = reactData;
  const {
    $el,
    $xeColumn,
    columnConfig
  } = _vm;
  const groupConfig = $xeColumn ? $xeColumn.columnConfig : null;
  if (groupConfig) {
    if ($xeColumn.$options._componentTag === 'vxe-table-column') {
      errLog('vxe.error.groupTag', [`<vxe-table-colgroup title=${$xeColumn.title} ...>`, `<vxe-table-column title=${$xeColumn.title} ...>`]);
    } else if ($xeColumn.$options._componentTag === 'vxe-column') {
      warnLog('vxe.error.groupTag', [`<vxe-colgroup title=${$xeColumn.title} ...>`, `<vxe-column title=${$xeColumn.title} ...>`]);
    }
    if (!groupConfig.children) {
      groupConfig.children = [];
    }
    groupConfig.children.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf($xeColumn.$el.children, $el), 0, columnConfig);
  } else {
    staticColumns.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf($xeTable.$refs.hideColumn.children, $el), 0, columnConfig);
  }
}
// 销毁列
function destroyColumn(_vm) {
  const $xeTable = _vm.$xeTable;
  const reactData = $xeTable;
  const {
    staticColumns
  } = reactData;
  const {
    columnConfig
  } = _vm;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticColumns, column => column === columnConfig);
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
}
function getRootColumn($xeTable, column) {
  const internalData = $xeTable;
  const {
    fullColumnIdData
  } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column = fullColumnIdData[parentColId].column;
    parentColId = column.parentId;
    if (!parentColId) {
      return column;
    }
  }
  return column;
}
function toFilters(filters) {
  if (filters && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(filters)) {
    return filters.map(({
      label,
      value,
      data,
      resetValue,
      checked
    }) => {
      return {
        label,
        value,
        data,
        resetValue,
        checked: !!checked,
        _checked: !!checked
      };
    });
  }
  return filters;
}
function getColReMinWidth(params) {
  const {
    $table,
    column,
    cell
  } = params;
  const internalData = $table;
  const {
    showHeaderOverflow: allColumnHeaderOverflow,
    resizableOpts
  } = $table;
  const {
    minWidth
  } = resizableOpts;
  // 如果自定义调整宽度逻辑
  if (minWidth) {
    const customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(minWidth) ? minWidth(params) : minWidth;
    if (customMinWidth !== 'auto') {
      return Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(customMinWidth));
    }
  }
  const {
    elemStore
  } = internalData;
  const {
    showHeaderOverflow,
    minWidth: colMinWidth
  } = column;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === 'ellipsis';
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(cell).fontSize) || 14) * 1.8);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryElement(cell, '.vxe-cell'));
  let mWidth = minTitleWidth + paddingLeftRight;
  // 默认最小宽处理
  if (hasEllipsis) {
    const dragIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--drag-handle'));
    const checkboxIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--checkbox'));
    const requiredIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--required-icon'));
    const editIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--edit-icon'));
    const prefixIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell-title-prefix-icon'));
    const suffixIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell-title-suffix-icon'));
    const sortIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--sort'));
    const filterIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--filter'));
    mWidth += dragIconWidth + checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  // 如果设置最小宽
  if (colMinWidth) {
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (bodyScrollElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyScrollElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
const lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1,
  large: 0
};
function countTreeExpand(prevRow, params) {
  let count = 1;
  if (!prevRow) {
    return count;
  }
  const {
    $table
  } = params;
  const treeOpts = $table.computeTreeOpts;
  const {
    transform,
    mapChildrenField
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const rowChildren = prevRow[transform ? mapChildrenField : childrenField];
  if (rowChildren && $table.isTreeExpandByRow(prevRow)) {
    for (let index = 0; index < rowChildren.length; index++) {
      count += countTreeExpand(rowChildren[index], params);
    }
  }
  return count;
}
function getOffsetSize($xeTable) {
  const vSize = $xeTable.computeSize;
  if (vSize) {
    return lineOffsetSizes[vSize] || 0;
  }
  return 0;
}
function calcTreeLine(params, prevRow) {
  const {
    $table,
    row
  } = params;
  const tableProps = $table;
  const tableReactData = $table;
  const tableInternalData = $table;
  const {
    showOverflow
  } = tableProps;
  const {
    scrollYLoad
  } = tableReactData;
  const {
    fullAllDataRowIdData
  } = tableInternalData;
  const rowOpts = $table.computeRowOpts;
  const cellOpts = $table.computeCellOpts;
  const defaultRowHeight = $table.computeDefaultRowHeight;
  const rowid = getRowid($table, row);
  const rowRest = fullAllDataRowIdData[rowid];
  const currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
  let expandSize = 1;
  if (prevRow) {
    expandSize = countTreeExpand(prevRow, params);
  }
  let cellHeight = currCellHeight;
  const vnHeight = rowRest.height;
  if (scrollYLoad) {
    if (!showOverflow) {
      cellHeight = vnHeight || currCellHeight;
    }
  }
  return cellHeight * expandSize - (prevRow ? 1 : 12 - getOffsetSize($table));
}
function getCellValue(row, column) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
}
function setCellValue(row, column, value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
}
function getRefElem(refEl) {
  if (refEl) {
    return refEl.$el || refEl;
  }
  return null;
}
function clearTableDefaultStatus(_vm) {
  _vm.initStatus = false;
  _vm.clearSort();
  _vm.clearCurrentRow();
  _vm.clearCurrentColumn();
  _vm.clearRadioRow();
  _vm.clearRadioReserve();
  _vm.clearCheckboxRow();
  _vm.clearCheckboxReserve();
  _vm.clearRowExpand();
  _vm.clearTreeExpand();
  _vm.clearTreeExpandReserve();
  if (_vm.clearEdit) {
    _vm.clearEdit();
  }
  if (_vm.clearSelected && (_vm.keyboardConfig || _vm.mouseConfig)) {
    _vm.clearSelected();
  }
  if (_vm.clearCellAreas && _vm.mouseConfig) {
    _vm.clearCellAreas();
    _vm.clearCopyCellArea();
  }
  return _vm.clearScroll();
}
function clearTableAllStatus(_vm) {
  if (_vm.clearFilter) {
    _vm.clearFilter();
  }
  return clearTableDefaultStatus(_vm);
}
function isColumnInfo(column) {
  return column instanceof ColumnInfo;
}
function createColumn($xeTable, options, renderOptions) {
  return isColumnInfo(options) ? options : new ColumnInfo($xeTable, options, renderOptions);
}
function rowToVisible($xeTable, row) {
  const tableProps = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    showOverflow
  } = tableProps;
  const {
    scrollYLoad,
    scrollYTop
  } = reactData;
  const {
    elemStore,
    afterFullData,
    fullAllDataRowIdData,
    isResizeCellHeight
  } = internalData;
  const rowOpts = $xeTable.computeRowOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const leftFixedWidth = $xeTable.computeLeftFixedWidth;
  const rightFixedWidth = $xeTable.computeRightFixedWidth;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  const rowid = getRowid($xeTable, row);
  if (bodyScrollElem) {
    const bodyHeight = bodyScrollElem.clientHeight;
    const bodyScrollTop = bodyScrollElem.scrollTop;
    const trElem = bodyScrollElem.querySelector(`[rowid="${rowid}"]`);
    if (trElem) {
      const trOffsetTop = trElem.offsetTop + (scrollYLoad ? scrollYTop : 0);
      const trHeight = trElem.clientHeight;
      // 检测行是否在可视区中
      if (trOffsetTop < bodyScrollTop || trOffsetTop > bodyScrollTop + bodyHeight) {
        return $xeTable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodyScrollTop) {
        return $xeTable.scrollTo(null, bodyScrollTop + trHeight);
      }
    } else {
      // 如果是虚拟渲染滚动
      if (scrollYLoad) {
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          return $xeTable.scrollTo(null, ($xeTable.findRowIndexOf(afterFullData, row) - 1) * defaultRowHeight);
        }
        let scrollTop = 0;
        const rowRest = fullAllDataRowIdData[rowid];
        const rHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        for (let i = 0; i < afterFullData.length; i++) {
          const currRow = afterFullData[i];
          const currRowid = getRowid($xeTable, currRow);
          if (currRow === row || currRowid === rowid) {
            break;
          }
          const currRowRest = fullAllDataRowIdData[currRowid];
          scrollTop += currRowRest.resizeHeight || cellOpts.height || rowOpts.height || currRowRest.height || defaultRowHeight;
        }
        if (scrollTop < bodyScrollTop) {
          return $xeTable.scrollTo(null, scrollTop - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(null, scrollTop + rHeight - (bodyHeight - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xeTable, column, row) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    scrollXLoad,
    scrollXLeft
  } = reactData;
  const {
    elemStore,
    visibleColumn
  } = internalData;
  const leftFixedWidth = $xeTable.computeLeftFixedWidth;
  const rightFixedWidth = $xeTable.computeRightFixedWidth;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (column.fixed) {
    return Promise.resolve();
  }
  if (bodyScrollElem) {
    const bodyWidth = bodyScrollElem.clientWidth;
    const bodyScrollLeft = bodyScrollElem.scrollLeft;
    let tdElem = null;
    if (row) {
      const rowid = getRowid($xeTable, row);
      tdElem = bodyScrollElem.querySelector(`[rowid="${rowid}"] .${column.id}`);
    }
    if (!tdElem) {
      tdElem = bodyScrollElem.querySelector(`.${column.id}`);
    }
    if (tdElem) {
      const tdOffsetLeft = tdElem.offsetLeft + (scrollXLoad ? scrollXLeft : 0);
      const cellWidth = tdElem.clientWidth;
      // 检测是否在可视区中
      if (tdOffsetLeft < bodyScrollLeft + leftFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft - leftFixedWidth - 1);
      } else if (tdOffsetLeft + cellWidth - bodyScrollLeft > bodyWidth - rightFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    } else {
      // 检测是否在虚拟渲染可视区中
      if (scrollXLoad) {
        let scrollLeft = 0;
        const cellWidth = column.renderWidth;
        for (let i = 0; i < visibleColumn.length; i++) {
          const currCol = visibleColumn[i];
          if (currCol === column || currCol.id === column.id) {
            break;
          }
          scrollLeft += currCol.renderWidth;
        }
        if (scrollLeft < bodyScrollLeft) {
          return $xeTable.scrollTo(scrollLeft - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(scrollLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
;// CONCATENATED MODULE: ./packages/ui/src/vn.ts

function getOnName(type) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().kebabCase(type);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
      return 'input';
    case 'select':
      return 'change';
  }
  return 'modelValue';
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeNumberInput':
    case 'VxeTextarea':
    case '$input':
    case '$textarea':
      return 'input';
  }
  return 'change';
}
function getSlotVNs(vns) {
  if (vns === null || vns === undefined) {
    return [];
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return [vns];
}
;// CONCATENATED MODULE: ./packages/table/src/cell.ts







const {
  getI18n: cell_getI18n,
  getIcon: cell_getIcon,
  renderer: cell_renderer,
  formats: cell_formats,
  renderEmptyElement
} = core_.VxeUI;
function renderTitlePrefixIcon(h, params) {
  const {
    $table,
    column
  } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  if (titlePrefix) {
    return h('i', {
      class: ['vxe-cell-title-prefix-icon', titlePrefix.iconStatus ? `theme--${titlePrefix.iconStatus}` : ''],
      on: {
        mouseenter(evnt) {
          $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
        },
        mouseleave(evnt) {
          $table.handleTargetLeaveEvent(evnt);
        }
      }
    }, [h('i', {
      class: titlePrefix.icon || cell_getIcon().TABLE_TITLE_PREFIX
    })]);
  }
  return renderEmptyElement($table);
}
function renderTitleSuffixIcon(h, params) {
  const {
    $table,
    column
  } = params;
  const titleSuffix = column.titleSuffix;
  if (titleSuffix) {
    return h('i', {
      class: ['vxe-cell-title-suffix-icon', titleSuffix.iconStatus ? `theme--${titleSuffix.iconStatus}` : ''],
      on: {
        mouseenter(evnt) {
          $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
        },
        mouseleave(evnt) {
          $table.handleTargetLeaveEvent(evnt);
        }
      }
    }, [h('i', {
      class: titleSuffix.icon || cell_getIcon().TABLE_TITLE_SUFFIX
    })]);
  }
  return renderEmptyElement($table);
}
function renderCellDragIcon(h, params) {
  const {
    $table
  } = params;
  const tableSlots = $table.$scopedSlots;
  const tableProps = $table;
  const {
    dragConfig
  } = tableProps;
  const rowDragOpts = $table.computeRowDragOpts;
  const {
    icon,
    trigger,
    disabledMethod
  } = rowDragOpts;
  const rDisabledMethod = disabledMethod || (dragConfig ? dragConfig.rowDisabledMethod : null);
  const isDisabled = rDisabledMethod && rDisabledMethod(params);
  const rowDragIconSlot = tableSlots.rowDragIcon || tableSlots['row-drag-icon'];
  const ons = {};
  if (trigger !== 'cell') {
    ons.mousedown = evnt => {
      if (!isDisabled) {
        $table.handleCellDragMousedownEvent(evnt, params);
      }
    };
    ons.mouseup = $table.handleCellDragMouseupEvent;
  }
  return h('span', {
    key: 'dg',
    class: ['vxe-cell--drag-handle', {
      'is--disabled': isDisabled
    }],
    on: ons
  }, rowDragIconSlot ? $table.callSlot(rowDragIconSlot, params, h) : [h('i', {
    class: icon || (dragConfig ? dragConfig.rowIcon : '') || cell_getIcon().TABLE_DRAG_ROW
  })]);
}
function renderCellBaseVNs(h, params, content) {
  const {
    $table,
    column,
    level
  } = params;
  const {
    dragSort
  } = column;
  const tableProps = $table;
  const {
    treeConfig,
    dragConfig
  } = tableProps;
  const rowOpts = $table.computeRowOpts;
  const rowDragOpts = $table.computeRowDragOpts;
  const treeOpts = $table.computeTreeOpts;
  const {
    showIcon,
    isPeerDrag,
    isCrossDrag,
    visibleMethod
  } = rowDragOpts;
  const rVisibleMethod = visibleMethod || (dragConfig ? dragConfig.rowVisibleMethod : null);
  const vns = [];
  if (dragSort && rowOpts.drag && (showIcon || (dragConfig ? dragConfig.showRowIcon : false)) && (!rVisibleMethod || rVisibleMethod(params))) {
    if (treeConfig) {
      if (treeOpts.transform && (isPeerDrag || isCrossDrag || !level)) {
        vns.unshift(renderCellDragIcon(h, params));
      }
    } else {
      vns.unshift(renderCellDragIcon(h, params));
    }
  }
  return vns.concat(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]);
}
function renderHeaderCellDragIcon(h, params) {
  const {
    $table,
    column
  } = params;
  const tableSlots = $table.$scopedSlots;
  const {
    slots
  } = column;
  const columnOpts = $table.computeColumnOpts;
  const columnDragOpts = $table.computeColumnDragOpts;
  const {
    showIcon,
    icon,
    trigger,
    isPeerDrag,
    isCrossDrag,
    visibleMethod,
    disabledMethod
  } = columnDragOpts;
  if (columnOpts.drag && showIcon && (!visibleMethod || visibleMethod(params))) {
    if (!column.fixed && (isPeerDrag || isCrossDrag || !column.parentId)) {
      const isDisabled = disabledMethod && disabledMethod(params);
      const columnDragIconSlot = (slots ? slots.columnDragIcon || slots['column-drag-icon'] : null) || tableSlots.columnDragIcon || tableSlots['column-drag-icon'];
      const ons = {};
      if (trigger !== 'cell') {
        ons.mousedown = evnt => {
          if (!isDisabled) {
            $table.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        };
        ons.mouseup = $table.handleHeaderCellDragMouseupEvent;
      }
      return h('span', {
        key: 'dg',
        class: ['vxe-cell--drag-handle', {
          'is--disabled': isDisabled
        }],
        on: ons
      }, columnDragIconSlot ? $table.callSlot(columnDragIconSlot, params, h) : [h('i', {
        class: icon || cell_getIcon().TABLE_DRAG_COLUMN
      })]);
    }
  }
  return renderEmptyElement($table);
}
function renderHeaderCellBaseVNs(h, params, content) {
  const vns = [renderTitlePrefixIcon(h, params), renderHeaderCellDragIcon(h, params), ...(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]), renderTitleSuffixIcon(h, params)];
  return vns;
}
function renderTitleContent(h, params, content) {
  const {
    $table,
    column
  } = params;
  const {
    type,
    showHeaderOverflow
  } = column;
  const tableProps = $table;
  const tableReactData = $table;
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const tooltipOpts = $table.computeTooltipOpts;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.mouseenter = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.mouseleave = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [type === 'html' && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(content) ? h('span', {
    class: 'vxe-cell--title',
    domProps: {
      innerHTML: content
    },
    on: ons
  }) : h('span', {
    class: 'vxe-cell--title',
    on: ons
  }, getSlotVNs(content))];
}
function getFooterContent(h, params) {
  const {
    $table,
    column,
    _columnIndex,
    row,
    items
  } = params;
  const {
    slots,
    editRender,
    cellRender,
    footerFormatter
  } = column;
  const renderOpts = editRender || cellRender;
  if (slots && slots.footer) {
    return $table.callSlot(slots.footer, params, h);
  }
  let itemValue = '';
  // 兼容老模式
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(items)) {
    itemValue = items[_columnIndex];
  } else {
    itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  }
  const footParams = Object.assign(params, {
    itemValue
  });
  if (footerFormatter) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerFormatter)) {
      return `${footerFormatter(footParams)}`;
    }
    const isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(footerFormatter);
    const gFormatOpts = isArr ? cell_formats.get(footerFormatter[0]) : cell_formats.get(footerFormatter);
    const footerFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
    if (footerFormatMethod) {
      return `${isArr ? footerFormatMethod(footParams, ...footerFormatter.slice(1)) : footerFormatMethod(footParams)}`;
    }
    return '';
  }
  if (renderOpts) {
    const compConf = cell_renderer.get(renderOpts.name);
    const rtFooter = compConf ? compConf.renderTableFooter || compConf.renderFooter : null;
    if (rtFooter) {
      return getSlotVNs(rtFooter.call($table, h, renderOpts, footParams));
    }
  }
  return [formatText(itemValue, 1)];
}
function getDefaultCellLabel(params) {
  const {
    $table,
    row,
    column
  } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
function renderCellHandle(h, params) {
  const {
    column,
    row,
    $table
  } = params;
  const tableProps = $table;
  const tableReactData = $table;
  const {
    editConfig
  } = tableProps;
  const {
    isRowGroupStatus
  } = tableReactData;
  const {
    type,
    treeNode,
    rowGroupNode,
    editRender
  } = column;
  const aggregateOpts = $table.computeAggregateOpts;
  const {
    mode
  } = aggregateOpts;
  const checkboxOpts = $table.computeCheckboxOpts;
  const editOpts = $table.computeEditOpts;
  const isDeepCell = treeNode || isRowGroupStatus && (mode === 'column' ? column.field === row.groupField : rowGroupNode);
  switch (type) {
    case 'seq':
      return isDeepCell ? Cell.renderDeepIndexCell(h, params) : Cell.renderSeqCell(h, params);
    case 'radio':
      return isDeepCell ? Cell.renderDeepRadioCell(h, params) : Cell.renderRadioCell(h, params);
    case 'checkbox':
      return checkboxOpts.checkField ? isDeepCell ? Cell.renderDeepSelectionCellByProp(h, params) : Cell.renderCheckboxCellByProp(h, params) : isDeepCell ? Cell.renderDeepSelectionCell(h, params) : Cell.renderCheckboxCell(h, params);
    case 'expand':
      return Cell.renderExpandCell(h, params);
    case 'html':
      return isDeepCell ? Cell.renderDeepHTMLCell(h, params) : Cell.renderHTMLCell(h, params);
  }
  if (isEnableConf(editConfig) && editRender) {
    return editOpts.mode === 'cell' ? isDeepCell ? Cell.renderDeepCellEdit(h, params) : Cell.renderCellEdit(h, params) : isDeepCell ? Cell.renderDeepRowEdit(h, params) : Cell.renderRowEdit(h, params);
  }
  return isDeepCell ? Cell.renderDeepCell(h, params) : Cell.renderDefaultCell(h, params);
}
function renderHeaderHandle(h, params) {
  const {
    column,
    $table
  } = params;
  const tableProps = $table;
  const {
    editConfig
  } = tableProps;
  const {
    type,
    filters,
    sortable,
    editRender
  } = column;
  switch (type) {
    case 'seq':
      return Cell.renderSeqHeader(h, params);
    case 'radio':
      return Cell.renderRadioHeader(h, params);
    case 'checkbox':
      return Cell.renderCheckboxHeader(h, params);
    case 'html':
      if (filters && sortable) {
        return Cell.renderSortAndFilterHeader(h, params);
      } else if (sortable) {
        return Cell.renderSortHeader(h, params);
      } else if (filters) {
        return Cell.renderFilterHeader(h, params);
      }
      break;
  }
  if (editConfig && editRender) {
    return Cell.renderEditHeader(h, params);
  } else if (filters && sortable) {
    return Cell.renderSortAndFilterHeader(h, params);
  } else if (sortable) {
    return Cell.renderSortHeader(h, params);
  } else if (filters) {
    return Cell.renderFilterHeader(h, params);
  }
  return Cell.renderDefaultHeader(h, params);
}
function renderFooterHandle(h, params) {
  return Cell.renderDefaultFooter(h, params);
}
const Cell = {
  createColumn($xeTable, _vm) {
    const {
      type
    } = _vm;
    const renConfs = {
      renderHeader: renderHeaderHandle,
      renderCell: renderCellHandle,
      renderFooter: renderFooterHandle
    };
    if (type === 'expand') {
      renConfs.renderData = Cell.renderExpandData;
    }
    return createColumn($xeTable, _vm, renConfs);
  },
  /**
   * 列头标题
   */
  renderHeaderTitle(h, params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      cellRender
    } = column;
    const renderOpts = editRender || cellRender;
    if (slots && slots.header) {
      return renderTitleContent(h, params, $table.callSlot(slots.header, params, h));
    }
    if (renderOpts) {
      const compConf = cell_renderer.get(renderOpts.name);
      const rtHeader = compConf ? compConf.renderTableHeader || compConf.renderHeader : null;
      if (rtHeader) {
        return getSlotVNs(renderTitleContent(h, params, rtHeader.call($table, h, renderOpts, params)));
      }
    }
    return renderTitleContent(h, params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(h, params) {
    return renderHeaderCellBaseVNs(h, params, Cell.renderHeaderTitle(h, params));
  },
  renderDefaultCell(h, params) {
    const {
      $table,
      row,
      column
    } = params;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      field,
      slots,
      editRender,
      cellRender,
      rowGroupNode,
      aggFunc
    } = column;
    const renderOpts = editRender || cellRender;
    if (slots && slots.default) {
      return renderCellBaseVNs(h, params, $table.callSlot(slots.default, params, h));
    }
    if (renderOpts) {
      const compConf = cell_renderer.get(renderOpts.name);
      const rtDefault = compConf ? compConf.renderTableDefault || compConf.renderDefault : null;
      const rtCell = compConf ? compConf.renderTableCell || compConf.renderCell : null;
      const renderFn = editRender ? rtCell : rtDefault;
      if (renderFn) {
        return renderCellBaseVNs(h, params, getSlotVNs(renderFn.call($table, h, renderOpts, Object.assign({
          $type: editRender ? 'edit' : 'cell'
        }, params))));
      }
    }
    let cellValue = '';
    if (isRowGroupStatus && field && row.isAggregate) {
      const aggRow = row;
      const {
        fullColumnFieldData
      } = tableInternalData;
      const aggregateOpts = $table.computeAggregateOpts;
      const {
        mode,
        showTotal,
        totalMethod,
        countFields,
        contentMethod,
        mapChildrenField
      } = aggregateOpts;
      const aggMethod = aggregateOpts.aggregateMethod || aggregateOpts.countMethod;
      const groupField = aggRow.groupField;
      const groupContent = aggRow.groupContent;
      const childList = mapChildrenField ? aggRow[mapChildrenField] || [] : [];
      const childCount = aggRow.childCount;
      const colRest = fullColumnFieldData[groupField] || {};
      const ctParams = {
        $table,
        groupField,
        groupColumn: colRest ? colRest.column : null,
        column,
        groupValue: groupContent,
        children: childList,
        childCount,
        aggValue: null,
        /**
         * 已废弃
         * @deprecated
         */
        totalValue: childCount
      };
      if (mode === 'column' ? field === aggRow.groupField : rowGroupNode) {
        cellValue = groupContent;
        if (contentMethod) {
          cellValue = `${contentMethod(ctParams)}`;
        }
        if (showTotal) {
          cellValue = cell_getI18n('vxe.table.rowGroupContentTotal', [cellValue, totalMethod ? totalMethod(ctParams) : childCount, childCount]);
        }
      } else if ($table.getPivotTableAggregateCellAggValue) {
        cellValue = $table.getPivotTableAggregateCellAggValue(params);
      } else if (aggFunc === true || countFields && countFields.includes(field)) {
        if (aggMethod) {
          ctParams.aggValue = childCount;
          cellValue = `${aggMethod(ctParams)}`;
        }
      }
    } else {
      cellValue = $table.getCellLabel(row, column);
    }
    const cellPlaceholder = editRender ? editRender.placeholder : '';
    return renderCellBaseVNs(h, params, [h('span', {
      class: 'vxe-cell--label'
    }, [
    // 如果设置占位符
    editRender && eqEmptyValue(cellValue) ? h('span', {
      class: 'vxe-cell--placeholder'
    }, formatText(getFuncText(cellPlaceholder), 1)) : h('span', formatText(cellValue, 1))])]);
  },
  renderDeepCell(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderDefaultCell.call(this, h, params));
  },
  renderDefaultFooter(h, params) {
    return getFooterContent(h, params);
  },
  /**
   * 行分组
   */
  renderRowGroupBtn(h, params, cellVNodes) {
    const {
      $table
    } = params;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      row,
      level
    } = params;
    const {
      rowGroupExpandedFlag
    } = tableReactData;
    const {
      rowGroupExpandedMaps
    } = tableInternalData;
    const aggregateOpts = $table.computeAggregateOpts;
    const {
      padding,
      indent
    } = aggregateOpts;
    const rowid = getRowid($table, row);
    const isExpand = !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[rowid];
    return h('div', {
      class: ['vxe-row-group--tree-node', {
        'is--expanded': isExpand
      }],
      style: padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [row.isAggregate ? h('span', {
      class: 'vxe-row-group--node-btn',
      on: {
        click(evnt) {
          $table.triggerRowGroupExpandEvent(evnt, params);
        }
      }
    }, [h('i', {
      class: isExpand ? cell_getIcon().TABLE_ROW_GROUP_OPEN : cell_getIcon().TABLE_ROW_GROUP_CLOSE
    })]) : renderEmptyElement($table), h('div', {
      class: 'vxe-row-group-cell'
    }, cellVNodes)]);
  },
  /**
   * 树
   */
  renderTreeNodeBtn(h, params, cellVNodes) {
    const {
      $table,
      isHidden
    } = params;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      treeExpandedFlag
    } = tableReactData;
    const {
      fullAllDataRowIdData,
      treeExpandedMaps,
      treeExpandLazyLoadedMaps
    } = tableInternalData;
    const treeOpts = $table.computeTreeOpts;
    const {
      row,
      column,
      level
    } = params;
    const {
      slots
    } = column;
    const {
      padding,
      indent,
      lazy,
      trigger,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const hasChild = rowChilds && rowChilds.length;
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isActive = false;
    let isLazyLoading = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params, h);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!treeExpandedFlag && !!treeExpandedMaps[rowid];
      if (lazy) {
        const rest = fullAllDataRowIdData[rowid];
        isLazyLoading = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
        isLazyLoaded = !!rest.treeLoaded;
      }
    }
    if (!trigger || trigger === 'default') {
      ons.click = evnt => {
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [h('div', {
      class: ['vxe-cell--tree-node', {
        'is--active': isActive
      }],
      style: padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [showIcon && (lazy ? isLazyLoaded ? hasChild : hasChild || hasLazyChilds : hasChild) ? [h('div', {
      class: 'vxe-cell--tree-btn',
      on: ons
    }, [h('i', {
      class: isLazyLoading ? iconLoaded || cell_getIcon().TABLE_TREE_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_TREE_OPEN : iconClose || cell_getIcon().TABLE_TREE_CLOSE
    })])] : null, h('div', {
      class: 'vxe-tree-cell'
    }, cellVNodes)])];
  },
  /**
   * 层级节点。
   * 行分组、树结构
   */
  renderDeepNodeBtn(h, params, cellVNodes) {
    const {
      $table,
      row,
      column
    } = params;
    const {
      rowGroupNode
    } = column;
    const tableReactData = $table;
    const {
      rowGroupList
    } = tableReactData;
    if (rowGroupList.length) {
      const aggregateOpts = $table.computeAggregateOpts;
      const {
        mode
      } = aggregateOpts;
      if (mode === 'column' ? column.field === row.groupField : rowGroupNode) {
        return [Cell.renderRowGroupBtn(h, params, cellVNodes)];
      }
    }
    return [Cell.renderTreeNodeBtn(h, params, cellVNodes)];
  },
  /**
   * 序号
   */
  renderSeqHeader(h, params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    return renderHeaderCellBaseVNs(h, params, renderTitleContent(h, params, slots && slots.header ? $table.callSlot(slots.header, params, h) : formatText(column.getTitle(), 1)));
  },
  renderSeqCell(h, params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table;
    const {
      treeConfig
    } = tableProps;
    const seqOpts = $table.computeSeqOpts;
    const {
      slots
    } = column;
    if (slots && slots.default) {
      return renderCellBaseVNs(h, params, $table.callSlot(slots.default, params, h));
    }
    const {
      seq
    } = params;
    const seqMethod = seqOpts.seqMethod;
    return renderCellBaseVNs(h, params, [h('span', `${formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)}`)]);
  },
  renderDeepIndexCell(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderSeqCell(h, params));
  },
  /**
   * 单选
   */
  renderRadioHeader(h, params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderHeaderCellBaseVNs(h, params, renderTitleContent(h, params, headerSlot ? $table.callSlot(headerSlot, params, h) : [h('span', {
      class: 'vxe-radio--label'
    }, titleSlot ? $table.callSlot(titleSlot, params, h) : formatText(column.getTitle(), 1))]));
  },
  renderRadioCell(h, params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table;
    const {
      selectRadioRow
    } = tableReactData;
    const radioOpts = $table.computeRadioOpts;
    const {
      slots
    } = column;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = radioOpts;
    const {
      row
    } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = row === selectRadioRow;
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    let on;
    if (!isHidden) {
      on = {
        click(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
    }
    const radioParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible
    };
    if (radioSlot) {
      return renderCellBaseVNs(h, params, $table.callSlot(radioSlot, radioParams, h));
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push(h('span', {
        class: ['vxe-radio--icon', isChecked ? cell_getIcon().TABLE_RADIO_CHECKED : cell_getIcon().TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h('span', {
        class: 'vxe-radio--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams, h) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(h, params, [h('span', {
      class: ['vxe-cell--radio', {
        'is--checked': isChecked,
        'is--disabled': isDisabled
      }],
      on
    }, radioVNs)]);
  },
  renderDeepRadioCell(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderRadioCell(h, params));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(h, params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table;
    const {
      isAllSelected: isAllCheckboxSelected,
      isIndeterminate: isAllCheckboxIndeterminate
    } = tableReactData;
    const isAllCheckboxDisabled = $table.computeIsAllCheckboxDisabled;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = $table.computeCheckboxOpts;
    const {
      checkStrictly,
      showHeader,
      headerTitle
    } = checkboxOpts;
    const colTitle = column.getTitle();
    const ons = {};
    if (!isHidden) {
      ons.click = evnt => {
        if (!isAllCheckboxDisabled) {
          $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isAllCheckboxSelected,
      disabled: isAllCheckboxDisabled,
      indeterminate: isAllCheckboxIndeterminate
    };
    if (headerSlot) {
      return renderHeaderCellBaseVNs(h, params, renderTitleContent(h, checkboxParams, $table.callSlot(headerSlot, checkboxParams, h)));
    }
    if (checkStrictly ? !showHeader : showHeader === false) {
      return renderHeaderCellBaseVNs(h, params, renderTitleContent(h, checkboxParams, [h('span', {
        class: 'vxe-checkbox--label'
      }, titleSlot ? $table.callSlot(titleSlot, checkboxParams, h) : colTitle)]));
    }
    return renderHeaderCellBaseVNs(h, params, renderTitleContent(h, checkboxParams, [h('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isAllCheckboxSelected,
        'is--disabled': isAllCheckboxDisabled,
        'is--indeterminate': isAllCheckboxIndeterminate
      }],
      attrs: {
        title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(headerTitle) ? cell_getI18n('vxe.table.allTitle') : `${headerTitle || ''}`
      },
      on: ons
    }, [h('span', {
      class: ['vxe-checkbox--icon', isAllCheckboxIndeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
    })].concat(titleSlot || colTitle ? [h('span', {
      class: 'vxe-checkbox--label'
    }, titleSlot ? $table.callSlot(titleSlot, checkboxParams, h) : colTitle)] : []))]));
  },
  renderCheckboxCell(h, params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      selectCheckboxMaps,
      treeIndeterminateRowMaps
    } = tableInternalData;
    const checkboxOpts = $table.computeCheckboxOpts;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      ons.click = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
      if (treeConfig || isRowGroupStatus) {
        indeterminate = !!treeIndeterminateRowMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(h, params, $table.callSlot(checkboxSlot, checkboxParams, h));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h('span', {
        class: ['vxe-checkbox--icon', indeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h('span', {
        class: 'vxe-checkbox--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams, h) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(h, params, [h('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminate,
        'is--hidden': !isVisible
      }],
      on: ons
    }, checkVNs)]);
  },
  renderDeepSelectionCell(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderCheckboxCell(h, params));
  },
  renderCheckboxCellByProp(h, params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      treeIndeterminateRowMaps
    } = tableInternalData;
    const checkboxOpts = $table.computeCheckboxOpts;
    const {
      labelField,
      checkField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
      ons.click = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
      if (treeConfig || isRowGroupStatus) {
        isIndeterminate = !!treeIndeterminateRowMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate: isIndeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(h, params, $table.callSlot(checkboxSlot, checkboxParams, h));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h('span', {
        class: ['vxe-checkbox--icon', isIndeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h('span', {
        class: 'vxe-checkbox--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams, h) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(h, params, [h('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        'is--hidden': !isVisible
      }],
      on: ons
    }, checkVNs)]);
  },
  renderDeepSelectionCellByProp(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderCheckboxCellByProp(h, params));
  },
  /**
   * 展开行
   */
  renderExpandCell(h, params) {
    const {
      $table,
      isHidden,
      row,
      column
    } = params;
    const tableReactData = $table;
    const tableInternalData = $table;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      rowExpandedMaps,
      rowExpandLazyLoadedMaps
    } = tableInternalData;
    const expandOpts = $table.computeExpandOpts;
    const {
      lazy,
      labelField,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose,
      visibleMethod
    } = expandOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isActive = false;
    let isLazyLoading = false;
    if (isRowGroupStatus && row.isAggregate) {
      return renderCellBaseVNs(h, params, []);
    }
    if (iconSlot) {
      return renderCellBaseVNs(h, params, $table.callSlot(iconSlot, params, h));
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoading = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return renderCellBaseVNs(h, params, [showIcon && (!visibleMethod || visibleMethod(params)) ? h('span', {
      class: ['vxe-table--expanded', {
        'is--active': isActive
      }],
      on: {
        mousedown(evnt) {
          evnt.stopPropagation();
        },
        click(evnt) {
          $table.triggerRowExpandEvent(evnt, params);
        }
      }
    }, [h('i', {
      class: ['vxe-table--expand-btn', isLazyLoading ? iconLoaded || cell_getIcon().TABLE_EXPAND_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_EXPAND_OPEN : iconClose || cell_getIcon().TABLE_EXPAND_CLOSE]
    })]) : renderEmptyElement($table), defaultSlot || labelField ? h('span', {
      class: 'vxe-table--expand-label'
    }, defaultSlot ? $table.callSlot(defaultSlot, params, h) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)) : renderEmptyElement($table)]);
  },
  renderExpandData(h, params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      contentRender
    } = column;
    if (slots && slots.content) {
      return $table.callSlot(slots.content, params, h);
    }
    if (contentRender) {
      const compConf = cell_renderer.get(contentRender.name);
      const rtExpand = compConf ? compConf.renderTableExpand || compConf.renderExpand : null;
      if (rtExpand) {
        return getSlotVNs(rtExpand.call($table, h, contentRender, params));
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(h, params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    if (slots && slots.default) {
      return renderCellBaseVNs(h, params, $table.callSlot(slots.default, params, h));
    }
    return renderCellBaseVNs(h, params, [h('span', {
      class: 'vxe-cell--html',
      domProps: {
        innerHTML: getDefaultCellLabel(params)
      }
    })]);
  },
  renderDeepHTMLCell(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderHTMLCell(h, params));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(h, params) {
    return renderHeaderCellBaseVNs(h, params, Cell.renderHeaderTitle(h, params).concat(Cell.renderSortIcon(h, params).concat(Cell.renderFilterIcon(h, params))));
  },
  /**
   * 排序
   */
  renderSortHeader(h, params) {
    return renderHeaderCellBaseVNs(h, params, Cell.renderHeaderTitle(h, params).concat(Cell.renderSortIcon(h, params)));
  },
  renderSortIcon(h, params) {
    const {
      $table,
      column
    } = params;
    const sortOpts = $table.computeSortOpts;
    const {
      showIcon,
      allowBtn,
      ascTitle,
      descTitle,
      iconLayout,
      iconAsc,
      iconDesc,
      iconVisibleMethod
    } = sortOpts;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      return [h('span', {
        class: ['vxe-cell--sort', `vxe-cell--sort-${iconLayout}-layout`]
      }, [h('i', {
        class: ['vxe-sort--asc-btn', iconAsc || cell_getIcon().TABLE_SORT_ASC, {
          'sort--active': column.order === 'asc'
        }],
        attrs: {
          title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(ascTitle) ? cell_getI18n('vxe.table.sortAsc') : `${ascTitle || ''}`
        },
        on: allowBtn ? {
          click(evnt) {
            evnt.stopPropagation();
            $table.triggerSortEvent(evnt, column, 'asc');
          }
        } : undefined
      }), h('i', {
        class: ['vxe-sort--desc-btn', iconDesc || cell_getIcon().TABLE_SORT_DESC, {
          'sort--active': column.order === 'desc'
        }],
        attrs: {
          title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(descTitle) ? cell_getI18n('vxe.table.sortDesc') : `${descTitle || ''}`
        },
        on: allowBtn ? {
          click(evnt) {
            evnt.stopPropagation();
            $table.triggerSortEvent(evnt, column, 'desc');
          }
        } : undefined
      })])];
    }
    return [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(h, params) {
    return renderHeaderCellBaseVNs(h, params, Cell.renderHeaderTitle(h, params).concat(Cell.renderFilterIcon(h, params)));
  },
  renderFilterIcon(h, params) {
    const {
      $table,
      column,
      hasFilter
    } = params;
    const tableReactData = $table;
    const {
      filterStore
    } = tableReactData;
    const filterOpts = $table.computeFilterOpts;
    const {
      showIcon,
      iconNone,
      iconMatch,
      iconVisibleMethod
    } = filterOpts;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      return [h('span', {
        class: ['vxe-cell--filter', {
          'is--active': filterStore.visible && filterStore.column === column
        }],
        on: {
          click(evnt) {
            if ($table.triggerFilterEvent) {
              $table.triggerFilterEvent(evnt, params.column, params);
            }
          }
        }
      }, [h('i', {
        class: ['vxe-filter--btn', hasFilter ? iconMatch || cell_getIcon().TABLE_FILTER_MATCH : iconNone || cell_getIcon().TABLE_FILTER_NONE],
        attrs: {
          title: cell_getI18n('vxe.table.filter')
        }
      })])];
    }
    return [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(h, params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table;
    const {
      editConfig,
      editRules
    } = tableProps;
    const editOpts = $table.computeEditOpts;
    const {
      sortable,
      filters,
      editRender
    } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some(rule => rule.required);
      }
    }
    let editIconVNs = [];
    if (isEnableConf(editConfig)) {
      editIconVNs = [isRequired && editOpts.showAsterisk ? h('i', {
        class: 'vxe-cell--required-icon'
      }, [h('i', {
        class: 'vxe-cell--required-icon'
      })]) : renderEmptyElement($table), isEnableConf(editRender) && editOpts.showIcon ? h('i', {
        class: 'vxe-cell--edit-icon'
      }, [h('i', {
        class: editOpts.icon || cell_getIcon().TABLE_EDIT
      })]) : renderEmptyElement($table)];
    }
    return renderHeaderCellBaseVNs(h, params, editIconVNs.concat(Cell.renderHeaderTitle(h, params)).concat(sortable ? Cell.renderSortIcon(h, params) : []).concat(filters ? Cell.renderFilterIcon(h, params) : []));
  },
  // 行格编辑模式
  renderRowEdit(h, params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(h, params, this, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderDeepRowEdit(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderRowEdit(h, params));
  },
  // 单元格编辑模式
  renderCellEdit(h, params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(h, params, this, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderDeepCellEdit(h, params) {
    return Cell.renderDeepNodeBtn(h, params, Cell.renderCellEdit(h, params));
  },
  runRenderer(h, params, _vm, isEdit) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      formatter
    } = column;
    const compConf = cell_renderer.get(editRender.name);
    const rtEdit = compConf ? compConf.renderTableEdit || compConf.renderEdit : null;
    const cellParams = Object.assign({
      $type: '',
      isEdit
    }, params);
    if (isEdit) {
      if (slots && slots.edit) {
        return $table.callSlot(slots.edit, cellParams, h);
      }
      if (rtEdit) {
        return getSlotVNs(rtEdit.call($table, h, editRender, cellParams));
      }
      return [];
    }
    if (slots && slots.default) {
      return renderCellBaseVNs(h, params, $table.callSlot(slots.default, cellParams, h));
    }
    if (formatter) {
      return renderCellBaseVNs(h, params, [h('span', {
        class: 'vxe-cell--label'
      }, [getDefaultCellLabel(cellParams)])]);
    }
    return Cell.renderDefaultCell.call(_vm, h, cellParams);
  }
};
/* harmony default export */ var cell = (Cell);
;// CONCATENATED MODULE: ./packages/ui/src/comp.ts
const defineVxeComponent = options => options;
;// CONCATENATED MODULE: ./packages/table/src/column.ts



const columnProps = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 seq,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: {
    type: Boolean,
    default: null
  },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 格式化表尾显示内容
  footerFormatter: [Function, Array, String],
  // 是否显示间距
  padding: {
    type: Boolean,
    default: null
  },
  // 垂直对齐方式
  verticalAlign: {
    type: String,
    default: null
  },
  // 是否允许排序
  sortable: Boolean,
  // 在 v3 中废弃
  remoteSort: {
    type: Boolean,
    default: null
  },
  // 在 v3 中只支持字符串类型
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 在 v3 中废弃
  sortMethod: Function,
  // 配置筛选条件数组
  filters: {
    type: Array,
    default: null
  },
  // 筛选是否允许多选
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 设置为分组节点
  rowGroupNode: Boolean,
  // 设置为树节点
  treeNode: Boolean,
  // 设置为拖拽排序
  dragSort: Boolean,
  // 设置为行高拖拽
  rowResize: Boolean,
  // 是否可视
  visible: {
    type: Boolean,
    default: null
  },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 聚合函数
  aggFunc: [String, Boolean],
  // 额外的参数
  params: Object
};
const columnWatch = {};
Object.keys(columnProps).forEach(name => {
  columnWatch[name] = function (value) {
    const $xeTable = this.$xeTable;
    this.columnConfig.update(name, value);
    if ($xeTable) {
      if (name === 'filters') {
        $xeTable.setFilter(this.columnConfig, value);
        $xeTable.handleUpdateDataQueue();
      } else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {
        $xeTable.handleRefreshColumnQueue();
      }
    }
  };
});
/* harmony default export */ var column = (/* define-vxe-component start */defineVxeComponent({
  name: 'VxeColumn',
  props: columnProps,
  provide() {
    return {
      $xeColumn: this,
      $xeGrid: null
    };
  },
  inject: {
    $xeTable: {
      default: null
    },
    $xeColumn: {
      default: null
    }
  },
  watch: columnWatch,
  created() {
    const $xeTable = this.$xeTable;
    this.columnConfig = this.createColumn($xeTable, this);
  },
  mounted() {
    this.columnConfig.slots = this.$scopedSlots;
    assembleColumn(this);
  },
  destroyed() {
    destroyColumn(this);
  },
  render(h) {
    return h('div', this.$slots.default);
  },
  methods: cell
})); /* define-vxe-component end */
;// CONCATENATED MODULE: ./packages/column/index.ts


const VxeColumn = Object.assign({}, column, {
  install(app) {
    app.component(column.name, column);
    // 兼容旧用法
    app.component('VxeTableColumn', column);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(column.name, column);
  // 兼容旧用法
  core_.VxeUI.dynamicApp.component('VxeTableColumn', column);
}
core_.VxeUI.component(column);
const Column = VxeColumn;
/* harmony default export */ var packages_column = ((/* unused pure expression or super */ null && (VxeColumn)));
;// CONCATENATED MODULE: ./packages/table/src/group.ts




/* harmony default export */ var group = (/* define-vxe-component start */defineVxeComponent({
  name: 'VxeColgroup',
  props: columnProps,
  provide() {
    return {
      $xeColumn: this,
      $xeGrid: null
    };
  },
  inject: {
    $xeTable: {
      default: null
    },
    $xeColumn: {
      default: null
    }
  },
  watch: columnWatch,
  created() {
    const $xeTable = this.$xeTable;
    this.columnConfig = this.createColumn($xeTable, this);
  },
  mounted() {
    const {
      $scopedSlots
    } = this;
    const columnSlots = {};
    if ($scopedSlots.header) {
      columnSlots.header = $scopedSlots.header;
    }
    this.columnConfig.slots = columnSlots;
    assembleColumn(this);
  },
  destroyed() {
    destroyColumn(this);
  },
  render(h) {
    return h('div', this.$slots.default);
  },
  methods: cell
})); /* define-vxe-component end */
;// CONCATENATED MODULE: ./packages/colgroup/index.ts


const VxeColgroup = Object.assign({}, group, {
  install(app) {
    app.component(group.name, group);
    // 兼容旧用法
    app.component('VxeTableColgroup', group);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(group.name, group);
  // 兼容旧用法
  core_.VxeUI.dynamicApp.component('VxeTableColgroup', group);
}
core_.VxeUI.component(group);
const Colgroup = VxeColgroup;
/* harmony default export */ var colgroup = ((/* unused pure expression or super */ null && (VxeColgroup)));
;// CONCATENATED MODULE: ./packages/table/src/methods.ts









const {
  getConfig: methods_getConfig,
  getI18n: methods_getI18n,
  renderer: methods_renderer,
  formats: methods_formats,
  interceptor: methods_interceptor,
  createEvent
} = core_.VxeUI;
const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
const supportMaxRow = 5e6;
const customStorageKey = 'VXE_CUSTOM_STORE';
const maxYHeight = 5e6;
const maxXWidth = 5e6;
function eqCellValue(row1, row2, field) {
  const val1 = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row1, field);
  const val2 = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row2, field);
  if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
    return true;
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val1) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val1)) {
    return '' + val1 === '' + val2;
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val1, val2);
}
function getNextSortOrder($xeTable, column) {
  const sortOpts = $xeTable.computeSortOpts;
  const {
    orders = []
  } = sortOpts;
  const currOrder = column.order || null;
  const oIndex = orders.indexOf(currOrder) + 1;
  return orders[oIndex < orders.length ? oIndex : 0];
}
const getCustomStorageMap = id => {
  const version = methods_getConfig().version;
  const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(customStorageKey) || '');
  const maps = rest && rest._v === version ? rest : {
    _v: version
  };
  return (id ? maps[id] : maps) || {};
};
const setCustomStorageMap = (id, data) => {
  const version = methods_getConfig().version;
  const maps = getCustomStorageMap();
  maps[id] = data || undefined;
  maps._v = version;
  localStorage.setItem(customStorageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(maps));
};
const getRecoverRowMaps = ($xeTable, keyMaps) => {
  const internalData = $xeTable;
  const {
    fullAllDataRowIdData
  } = internalData;
  const restKeys = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(keyMaps, (row, rowid) => {
    if (fullAllDataRowIdData[rowid]) {
      restKeys[rowid] = row;
    }
  });
  return restKeys;
};
function handleReserveRow($xeTable, reserveRowMap) {
  const internalData = $xeTable;
  const {
    fullDataRowIdData
  } = internalData;
  const reserveList = [];
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reserveRowMap, (item, rowid) => {
    if (fullDataRowIdData[rowid] && reserveList.indexOf(fullDataRowIdData[rowid].row) === -1) {
      reserveList.push(fullDataRowIdData[rowid].row);
    }
  });
  return reserveList;
}
function handleVirtualXVisible($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    isScrollXBig,
    scrollXWidth
  } = reactData;
  const {
    elemStore,
    visibleColumn,
    fullColumnIdData
  } = internalData;
  const leftFixedWidth = $xeTable.computeLeftFixedWidth;
  const rightFixedWidth = $xeTable.computeRightFixedWidth;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (bodyScrollElem) {
    const clientWidth = bodyScrollElem.clientWidth;
    let scrollLeft = bodyScrollElem.scrollLeft;
    if (isScrollXBig) {
      scrollLeft = Math.ceil((scrollXWidth - clientWidth) * Math.min(1, scrollLeft / (maxXWidth - clientWidth)));
    }
    const startLeft = scrollLeft + leftFixedWidth;
    const endLeft = scrollLeft + clientWidth - rightFixedWidth;
    let leftIndex = 0;
    let rightIndex = visibleColumn.length;
    while (leftIndex < rightIndex) {
      const cIndex = Math.floor((leftIndex + rightIndex) / 2);
      const column = visibleColumn[cIndex];
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      if (colRest.oLeft <= startLeft) {
        leftIndex = cIndex + 1;
      } else {
        rightIndex = cIndex;
      }
    }
    let visibleSize = 0;
    const toVisibleIndex = leftIndex === visibleColumn.length ? leftIndex : Math.max(0, leftIndex < visibleColumn.length ? leftIndex - 2 : 0);
    for (let cIndex = toVisibleIndex, cLen = visibleColumn.length; cIndex < cLen; cIndex++) {
      const column = visibleColumn[cIndex];
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      visibleSize++;
      if (colRest.oLeft > endLeft || visibleSize >= 60) {
        break;
      }
    }
    return {
      toVisibleIndex: Math.max(0, toVisibleIndex),
      visibleSize: Math.max(1, visibleSize)
    };
  }
  return {
    toVisibleIndex: 0,
    visibleSize: 6
  };
}
function handleCustomRestore($xeTable, storeData) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  let {
    collectColumn
  } = internalData;
  const {
    resizableData,
    sortData,
    visibleData,
    fixedData
  } = storeData;
  let hasCustomSort = false;
  // 处理还原
  if (resizableData || sortData || visibleData || fixedData) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parentColumn) => {
      const colKey = column.getKey();
      // 支持一级
      if (!parentColumn) {
        if (fixedData && fixedData[colKey] !== undefined) {
          column.fixed = fixedData[colKey];
        }
        if (sortData && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(sortData[colKey])) {
          hasCustomSort = true;
          column.renderSortNumber = sortData[colKey];
        }
      }
      if (resizableData && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(resizableData[colKey])) {
        column.resizeWidth = resizableData[colKey];
      }
      if (visibleData && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(visibleData[colKey])) {
        column.visible = visibleData[colKey];
      }
    });
    // 如果自定义了顺序
    if (hasCustomSort) {
      collectColumn = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(collectColumn, 'renderSortNumber');
      internalData.collectColumn = collectColumn;
      internalData.tableFullColumn = getColumnList(collectColumn);
    }
    reactData.isCustomStatus = true;
  } else {
    reactData.isCustomStatus = false;
  }
}
/**
 * 还原自定义列操作状态
 */
function restoreCustomStorage($xeTable) {
  const props = $xeTable;
  const {
    customConfig
  } = props;
  const tableId = $xeTable.computeTableId;
  const customOpts = $xeTable.computeCustomOpts;
  const {
    storage,
    restoreStore
  } = customOpts;
  const isAllCustom = storage === true;
  const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
  const isCustomResizable = isAllCustom || storageOpts.resizable;
  const isCustomVisible = isAllCustom || storageOpts.visible;
  const isCustomFixed = isAllCustom || storageOpts.fixed;
  const isCustomSort = isAllCustom || storageOpts.sort;
  if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
    if (!tableId) {
      errLog('vxe.error.reqProp', ['id']);
      return;
    }
    const storeData = getCustomStorageMap(tableId);
    if (restoreStore) {
      return Promise.resolve(restoreStore({
        $table: $xeTable,
        id: tableId,
        type: 'restore',
        storeData
      })).then(storeData => {
        if (!storeData) {
          return;
        }
        return handleCustomRestore($xeTable, storeData);
      }).catch(e => e);
    } else {
      return handleCustomRestore($xeTable, storeData);
    }
  }
}
/**
 * 更新数据列的 Map
 * 牺牲数据组装的耗时，用来换取使用过程中的流畅
 */
function cacheColumnMap($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    tableFullColumn,
    collectColumn
  } = internalData;
  const fullColumnIdData = internalData.fullColumnIdData = {};
  const fullColumnFieldData = internalData.fullColumnFieldData = {};
  const mouseOpts = $xeTable.computeMouseOpts;
  const expandOpts = $xeTable.computeExpandOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    isCrossDrag,
    isSelfToChildDrag
  } = columnDragOpts;
  const customOpts = $xeTable.computeCustomOpts;
  const {
    storage
  } = customOpts;
  const rowOpts = $xeTable.computeRowOpts;
  const isGroup = collectColumn.some(hasChildrenList);
  let isAllOverflow = !!props.showOverflow;
  let rowGroupColumn;
  let expandColumn;
  let treeNodeColumn;
  let checkboxColumn;
  let radioColumn;
  let htmlColumn;
  let hasFixed;
  const handleFunc = (column, index, items, path, parentColumn) => {
    const {
      id: colid,
      field,
      fixed,
      type,
      treeNode,
      rowGroupNode
    } = column;
    const rest = {
      $index: -1,
      _index: -1,
      column,
      colid,
      index,
      items,
      parent: parentColumn || null,
      width: 0,
      oLeft: 0
    };
    if (field) {
      if (fullColumnFieldData[field]) {
        errLog('vxe.error.colRepet', ['field', field]);
      }
      fullColumnFieldData[field] = rest;
    } else {
      if (storage && !type || columnOpts.drag && (isCrossDrag || isSelfToChildDrag)) {
        errLog('vxe.error.reqProp', [`${column.getTitle() || type || ''} -> column.field=?`]);
      }
    }
    if (!hasFixed && fixed) {
      hasFixed = fixed;
    }
    if (!htmlColumn && type === 'html') {
      htmlColumn = column;
    }
    if (treeNode) {
      if (treeNodeColumn) {
        warnLog('vxe.error.colRepet', ['tree-node', treeNode]);
      }
      if (!treeNodeColumn) {
        treeNodeColumn = column;
      }
    }
    if (rowGroupNode) {
      if (treeNodeColumn) {
        warnLog('vxe.error.colRepet', ['row-group-node', rowGroupNode]);
      }
      if (!rowGroupColumn) {
        rowGroupColumn = column;
      }
    }
    if (type === 'expand') {
      if (expandColumn) {
        warnLog('vxe.error.colRepet', ['type', type]);
      }
      if (!expandColumn) {
        expandColumn = column;
      }
    }
    if (type === 'checkbox') {
      if (checkboxColumn) {
        warnLog('vxe.error.colRepet', ['type', type]);
      }
      if (!checkboxColumn) {
        checkboxColumn = column;
      }
    } else if (type === 'radio') {
      if (radioColumn) {
        warnLog('vxe.error.colRepet', ['type', type]);
      }
      if (!radioColumn) {
        radioColumn = column;
      }
    }
    if (isAllOverflow && column.showOverflow === false) {
      isAllOverflow = false;
    }
    if (fullColumnIdData[colid]) {
      errLog('vxe.error.colRepet', ['colId', colid]);
    }
    fullColumnIdData[colid] = rest;
  };
  if (isGroup) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parentColumn, nodes) => {
      column.level = nodes.length;
      handleFunc(column, index, items, path, parentColumn);
    });
  } else {
    tableFullColumn.forEach(handleFunc);
  }
  if (expandColumn && expandOpts.mode !== 'fixed' && mouseOpts.area) {
    errLog('vxe.error.errConflicts', ['mouse-config.area', 'column.type=expand']);
  }
  if (htmlColumn) {
    if (!columnOpts.useKey) {
      errLog('vxe.error.reqProp', ['column-config.useKey & column.type=html']);
    }
    if (!rowOpts.useKey) {
      errLog('vxe.error.reqProp', ['row-config.useKey & column.type=html']);
    }
  }
  reactData.isGroup = isGroup;
  reactData.rowGroupColumn = rowGroupColumn;
  reactData.treeNodeColumn = treeNodeColumn;
  reactData.expandColumn = expandColumn;
  reactData.isAllOverflow = isAllOverflow;
}
function updateScrollXStatus($xeTable, fullColumn) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const virtualXOpts = $xeTable.computeVirtualXOpts;
  const allCols = fullColumn || internalData.tableFullColumn;
  // 如果gt为0，则总是启用
  const scrollXLoad = !!virtualXOpts.enabled && virtualXOpts.gt > -1 && (virtualXOpts.gt === 0 || virtualXOpts.gt < allCols.length);
  reactData.scrollXLoad = scrollXLoad;
  return scrollXLoad;
}
function updateScrollYStatus($xeTable, fullData) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const virtualYOpts = $xeTable.computeVirtualYOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    transform
  } = treeOpts;
  const allList = fullData || internalData.tableFullData;
  // 如果gt为0，则总是启用
  const scrollYLoad = (transform || !treeConfig) && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
  reactData.scrollYLoad = scrollYLoad;
  return scrollYLoad;
}
/**
 * 展开与收起树节点
 * @param rows
 * @param expanded
 * @returns
 */
function handleBaseTreeExpand($xeTable, rows, expanded) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeNodeColumn
  } = reactData;
  const {
    fullAllDataRowIdData,
    tableFullTreeData,
    treeExpandedMaps,
    treeExpandLazyLoadedMaps
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    reserve,
    lazy,
    accordion,
    toggleMethod
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
  const result = [];
  const columnIndex = $xeTable.getColumnIndex(treeNodeColumn);
  const $columnIndex = $xeTable.getVMColumnIndex(treeNodeColumn);
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  let validRows = toggleMethod ? rows.filter(row => toggleMethod({
    $table: $xeTable,
    expanded,
    column: treeNodeColumn,
    columnIndex,
    $columnIndex,
    row
  })) : rows;
  if (accordion) {
    validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
    // 同一级只能展开一个
    const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => item === validRows[0], {
      children: childrenField
    });
    if (matchObj) {
      matchObj.items.forEach(item => {
        const rowid = handleGetRowId(item);
        if (treeExpandedMaps[rowid]) {
          delete treeExpandedMaps[rowid];
        }
      });
    }
  }
  if (expanded) {
    validRows.forEach(row => {
      const rowid = handleGetRowId(row);
      if (!treeExpandedMaps[rowid]) {
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
          // 是否使用懒加载
          if (isLoad) {
            result.push(handleAsyncTreeExpandChilds($xeTable, row));
          } else {
            if (row[childrenField] && row[childrenField].length) {
              treeExpandedMaps[rowid] = row;
            }
          }
        }
      }
    });
  } else {
    validRows.forEach(item => {
      const rowid = handleGetRowId(item);
      if (treeExpandedMaps[rowid]) {
        delete treeExpandedMaps[rowid];
      }
    });
  }
  if (reserve) {
    validRows.forEach(row => handleTreeExpandReserve($xeTable, row, expanded));
  }
  reactData.treeExpandedFlag++;
  return Promise.all(result).then(() => {
    return $xeTable.recalculate();
  });
}
/**
 * 虚拟树的展开与收起
 * @param rows
 * @param expanded
 * @returns
 */
function handleVirtualTreeExpand($xeTable, rows, expanded) {
  const reactData = $xeTable;
  return handleBaseTreeExpand($xeTable, rows, expanded).then(() => {
    handleVirtualTreeToList($xeTable);
    $xeTable.handleTableData();
    reactData.treeExpandedFlag++;
    updateAfterDataIndex($xeTable);
    return $xeTable.$nextTick();
  }).then(() => {
    return $xeTable.recalculate(true);
  }).then(() => {
    setTimeout(() => {
      $xeTable.updateCellAreas();
    }, 30);
  });
}
/**
 * 展开与收起行分组节点
 * @param rows
 * @param expanded
 * @returns
 */
function handleRowGroupBaseExpand($xeTable, rows, expanded) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    fullAllDataRowIdData,
    tableFullGroupData,
    rowGroupExpandedMaps
  } = internalData;
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const {
    mapChildrenField,
    accordion
  } = aggregateOpts;
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  let validRows = rows;
  if (mapChildrenField) {
    if (accordion) {
      validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
      // 同一级只能展开一个
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullGroupData, item => getRowid($xeTable, item) === getRowid($xeTable, validRows[0]), {
        children: mapChildrenField
      });
      if (matchObj) {
        matchObj.items.forEach(item => {
          const rowid = handleGetRowId(item);
          if (rowGroupExpandedMaps[rowid]) {
            delete rowGroupExpandedMaps[rowid];
          }
        });
      }
    }
    if (expanded) {
      validRows.forEach(row => {
        const rowid = handleGetRowId(row);
        if (!rowGroupExpandedMaps[rowid]) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            if (row[mapChildrenField] && row[mapChildrenField].length) {
              rowGroupExpandedMaps[rowid] = row;
            }
          }
        }
      });
    } else {
      validRows.forEach(item => {
        const rowid = handleGetRowId(item);
        if (rowGroupExpandedMaps[rowid]) {
          delete rowGroupExpandedMaps[rowid];
        }
      });
    }
  }
  reactData.rowGroupExpandedFlag++;
  return $xeTable.recalculate();
}
/**
 * 行分组的展开与收起
 * @param rows
 * @param expanded
 * @returns
 */
function handleRowGroupVirtualExpand($xeTable, rows, expanded) {
  const reactData = $xeTable;
  return handleRowGroupBaseExpand($xeTable, rows, expanded).then(() => {
    handleVirtualTreeToList($xeTable);
    $xeTable.handleTableData();
    reactData.rowGroupExpandedFlag++;
    updateAfterDataIndex($xeTable);
    return $xeTable.$nextTick();
  }).then(() => {
    return $xeTable.recalculate(true);
  }).then(() => {
    setTimeout(() => {
      $xeTable.updateCellAreas();
    }, 30);
  });
}
function updateAfterListIndex($xeTable) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    afterFullData,
    fullDataRowIdData,
    fullAllDataRowIdData
  } = internalData;
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  const fullMaps = {};
  afterFullData.forEach((row, index) => {
    const rowid = handleGetRowId(row);
    const rowRest = fullAllDataRowIdData[rowid];
    const seq = index + 1;
    if (rowRest) {
      if (!treeConfig) {
        rowRest.seq = seq;
      }
      rowRest._index = index;
    } else {
      const rest = {
        row,
        rowid,
        seq,
        index: -1,
        $index: -1,
        _index: index,
        treeIndex: -1,
        items: [],
        parent: null,
        level: 0,
        height: 0,
        resizeHeight: 0,
        oTop: 0,
        expandHeight: 0
      };
      fullAllDataRowIdData[rowid] = rest;
      fullDataRowIdData[rowid] = rest;
    }
    fullMaps[rowid] = row;
  });
  internalData.afterFullRowMaps = fullMaps;
}
/**
 * 预编译
 * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅
 */
function updateAfterDataIndex($xeTable) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    fullDataRowIdData,
    fullAllDataRowIdData,
    afterFullData,
    afterTreeFullData
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    transform
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const fullMaps = {};
  if (treeConfig) {
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData, (row, index, items, path) => {
      const rowid = handleGetRowId(row);
      const rowRest = fullAllDataRowIdData[rowid];
      const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
      if (rowRest) {
        rowRest.seq = seq;
        rowRest.treeIndex = index;
      } else {
        const rest = {
          row,
          rowid,
          seq,
          index: -1,
          $index: -1,
          _index: -1,
          treeIndex: -1,
          items: [],
          parent: null,
          level: 0,
          height: 0,
          resizeHeight: 0,
          oTop: 0,
          expandHeight: 0
        };
        fullAllDataRowIdData[rowid] = rest;
        fullDataRowIdData[rowid] = rest;
      }
      fullMaps[rowid] = row;
    }, {
      children: transform ? treeOpts.mapChildrenField : childrenField
    });
    if (transform) {
      afterFullData.forEach((row, index) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid];
        const seq = index + 1;
        if (rowRest) {
          if (!treeConfig) {
            rowRest.seq = seq;
          }
          rowRest._index = index;
        }
      });
    }
    internalData.afterFullRowMaps = fullMaps;
  } else {
    updateAfterListIndex($xeTable);
  }
}
/**
 * 如果为虚拟树、行分组、则将树结构拍平
 * @returns
 */
function handleVirtualTreeToList($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    isRowGroupStatus
  } = reactData;
  const {
    fullAllDataRowIdData,
    treeExpandedMaps,
    rowGroupExpandedMaps
  } = internalData;
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  const fullData = [];
  const expandMaps = {};
  if (treeConfig && treeOpts.transform) {
    const childrenField = treeOpts.children || treeOpts.childrenField;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeFullData, (row, index, items, path, parentRow) => {
      const rowid = handleGetRowId(row);
      const parentRowid = handleGetRowId(parentRow);
      if (!parentRow || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          rowRest._index = fullData.length;
        }
        expandMaps[rowid] = 1;
        fullData.push(row);
      }
    }, {
      children: childrenField
    });
    internalData.afterFullData = fullData;
    updateScrollYStatus($xeTable, fullData);
    return fullData;
  } else if (isRowGroupStatus) {
    const {
      childrenField
    } = aggregateOpts;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterGroupFullData, (row, index, items, path, parentRow) => {
      const rowid = handleGetRowId(row);
      const parentRowid = handleGetRowId(parentRow);
      if (!parentRow || expandMaps[parentRowid] && rowGroupExpandedMaps[parentRowid]) {
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          rowRest._index = fullData.length;
        }
        expandMaps[rowid] = 1;
        fullData.push(row);
      }
    }, {
      children: childrenField
    });
    internalData.afterFullData = fullData;
    updateScrollYStatus($xeTable, fullData);
    return fullData;
  }
  return internalData.afterFullData;
}
/**
 * 编译处理后全量的表格数据
 * 如果存在筛选条件，继续处理
 */
function updateAfterFullData($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    isRowGroupStatus
  } = reactData;
  const {
    tableFullColumn,
    tableFullData,
    tableFullTreeData,
    tableFullGroupData
  } = internalData;
  const filterOpts = $xeTable.computeFilterOpts;
  const sortOpts = $xeTable.computeSortOpts;
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const {
    transform,
    rowField,
    parentField,
    mapChildrenField
  } = treeOpts;
  const {
    isEvery,
    remote: allRemoteFilter,
    filterMethod: allFilterMethod
  } = filterOpts;
  const {
    remote: allRemoteSort,
    sortMethod: allSortMethod,
    multiple: sortMultiple,
    chronological
  } = sortOpts;
  let tableData = [];
  let tableTree = [];
  // 处理数据
  if (!allRemoteFilter || !allRemoteSort) {
    const filterColumns = [];
    let orderColumns = [];
    tableFullColumn.forEach(column => {
      const {
        field,
        sortable,
        order,
        filters
      } = column;
      if (!allRemoteFilter && filters && filters.length) {
        const valueList = [];
        const itemList = [];
        filters.forEach(item => {
          if (item.checked) {
            itemList.push(item);
            valueList.push(item.value);
          }
        });
        if (itemList.length) {
          filterColumns.push({
            column,
            valueList,
            itemList
          });
        }
      }
      if (!allRemoteSort && sortable && order) {
        orderColumns.push({
          column,
          field,
          property: field,
          order: order,
          sortTime: column.sortTime
        });
      }
    });
    if (sortMultiple && chronological && orderColumns.length > 1) {
      orderColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(orderColumns, 'sortTime');
    }
    // 处理筛选
    // 支持单列、多列、组合筛选
    if (!allRemoteFilter && filterColumns.length) {
      const handleFilter = row => {
        return filterColumns.every(({
          column,
          valueList,
          itemList
        }) => {
          const {
            filterMethod,
            filterRender
          } = column;
          const compConf = isEnableConf(filterRender) ? methods_renderer.get(filterRender.name) : null;
          const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
          const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
          const cellValue = getCellValue(row, column);
          if (filterMethod) {
            return itemList.some(item => filterMethod({
              value: item.value,
              option: item,
              cellValue,
              row,
              column,
              $table: $xeTable
            }));
          } else if (compFilterMethod) {
            return itemList.some(item => compFilterMethod({
              value: item.value,
              option: item,
              cellValue,
              row,
              column,
              $table: $xeTable
            }));
          } else if (allFilterMethod) {
            return allFilterMethod({
              $table: $xeTable,
              options: itemList,
              values: valueList,
              cellValue,
              row,
              column
            });
          } else if (tdFilterMethod) {
            return itemList.some(item => tdFilterMethod({
              value: item.value,
              option: item,
              cellValue,
              row,
              column,
              $table: $xeTable
            }));
          }
          return valueList.indexOf(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field)) > -1;
        });
      };
      if (isRowGroupStatus) {
        // 行分组
        tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData, handleFilter, {
          original: true,
          isEvery: true,
          children: aggregateOpts.mapChildrenField,
          mapChildren: aggregateOpts.childrenField
        });
        tableData = tableTree;
      } else if (treeConfig && transform) {
        // 筛选虚拟树
        tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, handleFilter, {
          original: true,
          isEvery,
          children: mapChildrenField,
          mapChildren: childrenField
        });
        tableData = tableTree;
      } else {
        tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
        tableTree = tableData;
      }
    } else {
      if (isRowGroupStatus) {
        // 还原行分组
        tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData, () => true, {
          original: true,
          isEvery: true,
          children: aggregateOpts.mapChildrenField,
          mapChildren: aggregateOpts.childrenField
        });
        tableData = tableTree;
      } else if (treeConfig && transform) {
        // 还原虚拟树
        tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, () => true, {
          original: true,
          isEvery,
          children: mapChildrenField,
          mapChildren: childrenField
        });
        tableData = tableTree;
      } else {
        tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
        tableTree = tableData;
      }
    }
    // 处理排序
    // 支持单列、多列、组合排序
    if (!allRemoteSort && orderColumns.length) {
      if (isRowGroupStatus) {
        // 行分组的排序
        if (allSortMethod) {
          const sortRests = allSortMethod({
            data: tableTree,
            sortList: orderColumns,
            $table: $xeTable
          });
          tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests) ? sortRests : tableTree;
        } else {
          const treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree, {
            key: aggregateOpts.rowField,
            parentKey: aggregateOpts.parentField,
            children: aggregateOpts.mapChildrenField
          });
          tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList, orderColumns.map(({
            column,
            order
          }) => [getOrderField($xeTable, column), order])), {
            key: aggregateOpts.rowField,
            parentKey: aggregateOpts.parentField,
            children: aggregateOpts.childrenField,
            mapChildren: aggregateOpts.mapChildrenField
          });
        }
        tableData = tableTree;
      } else if (treeConfig && transform) {
        // 虚拟树的排序
        if (allSortMethod) {
          const sortRests = allSortMethod({
            data: tableTree,
            sortList: orderColumns,
            $table: $xeTable
          });
          tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests) ? sortRests : tableTree;
        } else {
          const treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree, {
            children: mapChildrenField
          });
          tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList, orderColumns.map(({
            column,
            order
          }) => [getOrderField($xeTable, column), order])), {
            key: rowField,
            parentKey: parentField,
            children: childrenField,
            mapChildren: mapChildrenField
          });
        }
        tableData = tableTree;
      } else {
        if (allSortMethod) {
          const sortRests = allSortMethod({
            data: tableData,
            sortList: orderColumns,
            $table: $xeTable
          });
          tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests) ? sortRests : tableData;
        } else {
          // 兼容 v4
          if (sortMultiple) {
            tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData, orderColumns.map(({
              column,
              order
            }) => [getOrderField($xeTable, column), order]));
          } else {
            const firstOrderColumn = orderColumns[0];
            let sortByConfs;
            // 已废弃，兼容 v2，在 v4 中废弃， sortBy 不能为数组
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(firstOrderColumn.sortBy)) {
              sortByConfs = firstOrderColumn.sortBy.map(item => [item, firstOrderColumn.order]);
            }
            tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData, sortByConfs || [firstOrderColumn].map(({
              column,
              order
            }) => [getOrderField($xeTable, column), order]));
          }
          tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData, orderColumns.map(({
            column,
            order
          }) => [getOrderField($xeTable, column), order]));
        }
        tableTree = tableData;
      }
    }
  } else {
    if (isRowGroupStatus) {
      // 还原行分组
      // 还原虚拟树
      tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData, () => true, {
        original: true,
        isEvery: true,
        children: aggregateOpts.mapChildrenField,
        mapChildren: aggregateOpts.childrenField
      });
      tableData = tableTree;
    } else if (treeConfig && transform) {
      // 还原虚拟树
      tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, () => true, {
        original: true,
        isEvery,
        children: mapChildrenField,
        mapChildren: childrenField
      });
      tableData = tableTree;
    } else {
      tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
      tableTree = tableData;
    }
  }
  internalData.afterFullData = tableData;
  internalData.afterTreeFullData = tableTree;
  internalData.afterGroupFullData = tableTree;
  updateAfterDataIndex($xeTable);
}
function updateStyle($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    showHeaderOverflow: allColumnHeaderOverflow,
    showFooterOverflow: allColumnFooterOverflow,
    mouseConfig,
    spanMethod,
    footerSpanMethod
  } = props;
  const {
    isGroup,
    currentRow,
    tableColumn,
    scrollXLoad,
    scrollYLoad,
    overflowX,
    scrollbarWidth,
    overflowY,
    scrollbarHeight,
    scrollXWidth,
    columnStore,
    editStore,
    isAllOverflow,
    expandColumn,
    isColLoading
  } = reactData;
  const {
    visibleColumn,
    tableHeight,
    headerHeight,
    footerHeight,
    elemStore,
    customHeight,
    customMinHeight,
    customMaxHeight
  } = internalData;
  const el = $xeTable.$refs.refElem;
  if (!el) {
    return;
  }
  const containerList = ['main', 'left', 'right'];
  const osbWidth = overflowY ? scrollbarWidth : 0;
  const osbHeight = overflowX ? scrollbarHeight : 0;
  const emptyPlaceholderElem = $xeTable.$refs.refEmptyPlaceholder;
  const mouseOpts = $xeTable.computeMouseOpts;
  const expandOpts = $xeTable.computeExpandOpts;
  const bodyWrapperElem = getRefElem(elemStore['main-body-wrapper']);
  const bodyTableElem = getRefElem(elemStore['main-body-table']);
  if (emptyPlaceholderElem) {
    emptyPlaceholderElem.style.top = `${headerHeight}px`;
    emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - osbHeight}px` : '';
  }
  let bodyHeight = 0;
  let bodyMaxHeight = 0;
  const bodyMinHeight = customMinHeight - headerHeight - footerHeight - osbHeight;
  if (customMaxHeight) {
    bodyMaxHeight = Math.max(bodyMinHeight, customMaxHeight - headerHeight - footerHeight - osbHeight);
  }
  if (customHeight) {
    bodyHeight = customHeight - headerHeight - footerHeight - osbHeight;
  }
  if (!bodyHeight) {
    if (bodyTableElem) {
      bodyHeight = bodyTableElem.clientHeight;
    }
  }
  if (bodyHeight) {
    if (bodyMaxHeight) {
      bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
    }
    bodyHeight = Math.max(bodyMinHeight, bodyHeight);
  }
  const scrollbarXToTop = $xeTable.$refs.computeScrollbarXToTop;
  const xLeftCornerEl = $xeTable.$refs.refScrollXLeftCornerElem;
  const xRightCornerEl = $xeTable.$refs.refScrollXRightCornerElem;
  const scrollXVirtualEl = $xeTable.$refs.refScrollXVirtualElem;
  if (scrollXVirtualEl) {
    scrollXVirtualEl.style.height = `${osbHeight}px`;
    scrollXVirtualEl.style.visibility = overflowX ? 'visible' : 'hidden';
  }
  const xWrapperEl = $xeTable.$refs.refScrollXWrapperElem;
  if (xWrapperEl) {
    xWrapperEl.style.left = scrollbarXToTop ? `${osbWidth}px` : '';
    xWrapperEl.style.width = `${el.clientWidth - osbWidth}px`;
  }
  if (xLeftCornerEl) {
    xLeftCornerEl.style.width = scrollbarXToTop ? `${osbWidth}px` : '';
    xLeftCornerEl.style.display = scrollbarXToTop ? overflowX && osbHeight ? 'block' : '' : '';
  }
  if (xRightCornerEl) {
    xRightCornerEl.style.width = scrollbarXToTop ? '' : `${osbWidth}px`;
    xRightCornerEl.style.display = scrollbarXToTop ? '' : overflowX && osbHeight ? 'block' : '';
  }
  const scrollYVirtualEl = $xeTable.$refs.refScrollYVirtualElem;
  if (scrollYVirtualEl) {
    scrollYVirtualEl.style.width = `${osbWidth}px`;
    scrollYVirtualEl.style.height = `${bodyHeight + headerHeight + footerHeight}px`;
    scrollYVirtualEl.style.visibility = overflowY ? 'visible' : 'hidden';
  }
  const yTopCornerEl = $xeTable.$refs.refScrollYTopCornerElem;
  if (yTopCornerEl) {
    yTopCornerEl.style.height = `${headerHeight}px`;
    yTopCornerEl.style.display = overflowY && headerHeight ? 'block' : '';
  }
  const yWrapperEl = $xeTable.$refs.refScrollYWrapperElem;
  if (yWrapperEl) {
    yWrapperEl.style.height = `${bodyHeight}px`;
    yWrapperEl.style.top = `${headerHeight}px`;
  }
  const yBottomCornerEl = $xeTable.$refs.refScrollYBottomCornerElem;
  if (yBottomCornerEl) {
    yBottomCornerEl.style.height = `${footerHeight}px`;
    yBottomCornerEl.style.top = `${headerHeight + bodyHeight}px`;
    yBottomCornerEl.style.display = overflowY && footerHeight ? 'block' : '';
  }
  const rowExpandEl = $xeTable.$refs.refRowExpandElem;
  if (rowExpandEl) {
    rowExpandEl.style.height = `${bodyHeight}px`;
    rowExpandEl.style.top = `${headerHeight}px`;
  }
  containerList.forEach((name, index) => {
    const fixedType = index > 0 ? name : '';
    const layoutList = ['header', 'body', 'footer'];
    const isFixedLeft = fixedType === 'left';
    let fixedColumn = [];
    let fixedWrapperElem;
    if (fixedType) {
      fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      fixedWrapperElem = isFixedLeft ? $xeTable.$refs.refLeftContainer : $xeTable.$refs.refRightContainer;
    }
    layoutList.forEach(layout => {
      const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
      const currScrollElem = getRefElem(elemStore[`${name}-${layout}-scroll`]);
      const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
      if (layout === 'header') {
        // 表头体样式处理
        // 横向滚动渲染
        let renderColumnList = tableColumn;
        let isOptimizeMode = false;
        if (isGroup) {
          renderColumnList = visibleColumn;
        } else {
          // 如果是使用优化模式
          if (scrollXLoad && allColumnHeaderOverflow) {
            if (spanMethod || footerSpanMethod) {
              // 如果不支持优化模式
            } else {
              isOptimizeMode = true;
            }
          }
          if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
            renderColumnList = visibleColumn;
          }
          if (fixedType) {
            // 如果是使用优化模式
            if (isOptimizeMode) {
              renderColumnList = fixedColumn || [];
            }
          }
        }
        const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
        if (fixedType) {
          if (isGroup) {
            if (wrapperElem) {
              wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : '';
            }
          } else {
            if (isOptimizeMode) {
              if (wrapperElem) {
                wrapperElem.style.width = tWidth ? `${tWidth}px` : '';
              }
            } else {
              if (wrapperElem) {
                wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : '';
              }
            }
          }
        }
        if (currScrollElem) {
          currScrollElem.style.height = `${headerHeight}px`;
        }
        if (tableElem) {
          tableElem.style.width = tWidth ? `${tWidth}px` : '';
        }
      } else if (layout === 'body') {
        if (currScrollElem) {
          currScrollElem.style.maxHeight = customMaxHeight ? `${bodyMaxHeight}px` : '';
          currScrollElem.style.height = customHeight ? `${bodyHeight}px` : '';
          currScrollElem.style.minHeight = `${bodyMinHeight}px`;
        }
        // 如果是固定列
        if (fixedWrapperElem) {
          if (wrapperElem) {
            wrapperElem.style.top = `${headerHeight}px`;
          }
          fixedWrapperElem.style.height = `${customHeight > 0 ? customHeight : tableHeight + headerHeight + footerHeight + osbHeight}px`;
          fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, 0)}px`;
        }
        let renderColumnList = tableColumn;
        let isOptimizeMode = false;
        // 如果是使用优化模式
        if (scrollXLoad || scrollYLoad || isAllOverflow) {
          if (expandColumn && expandOpts.mode !== 'fixed' || spanMethod || footerSpanMethod) {
            // 如果不支持优化模式
          } else {
            isOptimizeMode = true;
          }
        }
        if (fixedType) {
          renderColumnList = visibleColumn;
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
        if (fixedType) {
          if (isOptimizeMode) {
            if (wrapperElem) {
              wrapperElem.style.width = tWidth ? `${tWidth}px` : '';
            }
          } else {
            if (wrapperElem) {
              wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : '';
            }
          }
        }
        if (tableElem) {
          tableElem.style.width = tWidth ? `${tWidth}px` : '';
          // 兼容性处理
          tableElem.style.paddingRight = osbWidth && fixedType && (browseObj.firefox || browseObj.safari) ? `${osbWidth}px` : '';
        }
        const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
        if (emptyBlockElem) {
          emptyBlockElem.style.width = tWidth ? `${tWidth}px` : '';
        }
      } else if (layout === 'footer') {
        let renderColumnList = tableColumn;
        let isOptimizeMode = false;
        // 如果是使用优化模式
        if (scrollXLoad && allColumnFooterOverflow) {
          if (spanMethod || footerSpanMethod) {
            // 如果不支持优化模式
          } else {
            isOptimizeMode = true;
          }
        }
        if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
        if (fixedType) {
          if (isOptimizeMode) {
            if (wrapperElem) {
              wrapperElem.style.width = tWidth ? `${tWidth}px` : '';
            }
          } else {
            if (wrapperElem) {
              wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : '';
            }
          }
        }
        if (currScrollElem) {
          currScrollElem.style.height = `${footerHeight}px`;
          // 如果是固定列
          if (fixedWrapperElem) {
            if (wrapperElem) {
              wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight - osbHeight : tableHeight + headerHeight}px`;
            }
          }
        }
        if (tableElem) {
          tableElem.style.width = tWidth ? `${tWidth}px` : '';
        }
      }
    });
  });
  if (currentRow) {
    $xeTable.setCurrentRow(currentRow);
  }
  if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
    $xeTable.addCellSelectedClass();
  }
  return $xeTable.$nextTick();
}
function checkValidate($xeTable, type) {
  if ($xeTable.triggerValidate) {
    return $xeTable.triggerValidate(type);
  }
  return $xeTable.$nextTick();
}
/**
 * 当单元格发生改变时
 * 如果存在规则，则校验
 */
function handleChangeCell($xeTable, evnt, params) {
  checkValidate($xeTable, 'blur').catch(e => e).then(() => {
    $xeTable.handleEdit(params, evnt).then(() => checkValidate($xeTable, 'change')).catch(e => e);
  });
}
function handleDefaultSort($xeTable) {
  const props = $xeTable;
  const {
    sortConfig
  } = props;
  if (sortConfig) {
    const sortOpts = $xeTable.computeSortOpts;
    let {
      defaultSort
    } = sortOpts;
    if (defaultSort) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
        defaultSort = [defaultSort];
      }
      if (defaultSort.length) {
        (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
          const {
            field,
            order
          } = item;
          if (field && order) {
            const column = $xeTable.getColumnByField(field);
            if (column && column.sortable) {
              column.order = order;
              column.sortTime = Date.now() + index;
            }
          }
        });
        if (!sortOpts.remote) {
          $xeTable.handleTableData(true).then(updateStyle);
        }
      }
    }
  }
}
/**
 * 处理默认勾选
 */
function handleDefaultSelectionChecked($xeTable) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    checkboxConfig
  } = props;
  if (checkboxConfig) {
    const {
      fullDataRowIdData
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkAll,
      checkRowKeys
    } = checkboxOpts;
    if (checkAll) {
      handleCheckedAllCheckboxRow($xeTable, true, true);
    } else if (checkRowKeys) {
      const defSelection = [];
      checkRowKeys.forEach(rowid => {
        if (fullDataRowIdData[rowid]) {
          defSelection.push(fullDataRowIdData[rowid].row);
        }
      });
      handleCheckedCheckboxRow($xeTable, defSelection, true, true);
    }
  }
}
/**
 * 处理单选框默认勾选
 */
function handleDefaultRadioChecked($xeTable) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    radioConfig
  } = props;
  if (radioConfig) {
    const {
      fullDataRowIdData
    } = internalData;
    const radioOpts = $xeTable.computeRadioOpts;
    const {
      checkRowKey: rowid,
      reserve
    } = radioOpts;
    if (rowid) {
      if (fullDataRowIdData[rowid]) {
        handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
      }
      if (reserve) {
        const rowkey = getRowkey($xeTable);
        internalData.radioReserveRow = {
          [rowkey]: rowid
        };
      }
    }
  }
}
/**
 * 处理默认展开行
 */
function handleDefaultRowExpand($xeTable) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    expandConfig
  } = props;
  if (expandConfig) {
    const {
      fullDataRowIdData
    } = internalData;
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      expandAll,
      expandRowKeys
    } = expandOpts;
    if (expandAll) {
      $xeTable.setAllRowExpand(true);
    } else if (expandRowKeys) {
      const defExpandeds = [];
      expandRowKeys.forEach(rowid => {
        if (fullDataRowIdData[rowid]) {
          defExpandeds.push(fullDataRowIdData[rowid].row);
        }
      });
      $xeTable.setRowExpand(defExpandeds, true);
    }
  }
}
function handleRadioReserveRow($xeTable, row) {
  const internalData = $xeTable;
  const radioOpts = $xeTable.computeRadioOpts;
  if (radioOpts.reserve) {
    internalData.radioReserveRow = row;
  }
}
function handleCheckboxReserveRow($xeTable, row, checked) {
  const internalData = $xeTable;
  const {
    checkboxReserveRowMap
  } = internalData;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  if (checkboxOpts.reserve) {
    const rowid = getRowid($xeTable, row);
    if (checked) {
      checkboxReserveRowMap[rowid] = row;
    } else if (checkboxReserveRowMap[rowid]) {
      delete checkboxReserveRowMap[rowid];
    }
  }
}
function handleCheckedRadioRow($xeTable, row, isForce) {
  const reactData = $xeTable;
  const radioOpts = $xeTable.computeRadioOpts;
  const {
    checkMethod
  } = radioOpts;
  if (row && (isForce || !checkMethod || checkMethod({
    $table: $xeTable,
    row
  }))) {
    reactData.selectRadioRow = row;
    handleRadioReserveRow($xeTable, row);
  }
  return $xeTable.$nextTick();
}
function handleCheckedCheckboxRow($xeTable, rows, value, isForce) {
  if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
    rows = [rows];
  }
  $xeTable.handleBatchSelectRows(rows, !!value, isForce);
  $xeTable.checkSelectionStatus();
  return $xeTable.$nextTick();
}
function handleCheckedAllCheckboxRow($xeTable, checked, isForce) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    isRowGroupStatus
  } = reactData;
  const {
    afterFullData,
    afterTreeFullData,
    afterGroupFullData,
    checkboxReserveRowMap,
    selectCheckboxMaps
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  const {
    checkField,
    reserve,
    checkMethod
  } = checkboxOpts;
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  // indeterminateField 仅支持读取
  const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
  const selectRowMaps = {};
  /**
   * 绑定属性方式（有污染）
   * 必须在行数据存在对应的属性，否则将不响应
   */
  if (checkField) {
    const checkValFn = row => {
      if (isForce || !checkMethod || checkMethod({
        $table: $xeTable,
        row
      })) {
        if (checked) {
          selectRowMaps[handleGetRowId(row)] = row;
        }
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, checked);
      }
      if ((treeConfig || isRowGroupStatus) && indeterminateField) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, false);
      }
    };
    // 如果存在选中方法
    // 如果方法成立，则更新值，否则忽略该数据
    if (treeConfig || isRowGroupStatus) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, checkValFn, {
        children: childrenField
      });
    } else {
      afterFullData.forEach(checkValFn);
    }
  } else {
    /**
     * 默认方式（无污染）
     * 无需任何属性，直接绑定
     */
    if (isRowGroupStatus) {
      if (checked) {
        /**
         * 如果是行分组勾选
         * 如果方法成立，则添加到临时集合中
         */
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData, row => {
          if (isForce || !checkMethod || checkMethod({
            $table: $xeTable,
            row
          })) {
            const rowid = handleGetRowId(row);
            selectRowMaps[rowid] = row;
          }
        }, {
          children: aggregateOpts.mapChildrenField
        });
      } else {
        /**
         * 如果是树取消
         * 如果方法成立，则不添加到临时集合中
         */
        if (!isForce && checkMethod) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData, row => {
            const rowid = handleGetRowId(row);
            if (checkMethod({
              $table: $xeTable,
              row
            }) ? false : selectCheckboxMaps[rowid]) {
              selectRowMaps[rowid] = row;
            }
          }, {
            children: aggregateOpts.mapChildrenField
          });
        }
      }
    } else if (treeConfig) {
      if (checked) {
        /**
         * 如果是树勾选
         * 如果方法成立，则添加到临时集合中
         */
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData, row => {
          if (isForce || !checkMethod || checkMethod({
            $table: $xeTable,
            row
          })) {
            const rowid = handleGetRowId(row);
            selectRowMaps[rowid] = row;
          }
        }, {
          children: childrenField
        });
      } else {
        /**
         * 如果是树取消
         * 如果方法成立，则不添加到临时集合中
         */
        if (!isForce && checkMethod) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData, row => {
            const rowid = handleGetRowId(row);
            if (checkMethod({
              $table: $xeTable,
              row
            }) ? false : selectCheckboxMaps[rowid]) {
              selectRowMaps[rowid] = row;
            }
          }, {
            children: childrenField
          });
        }
      }
    } else {
      if (checked) {
        /**
         * 如果是行勾选
         * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中
         * 如果不存在选中方法，则添加所有数据到临时集合中
         */
        if (!isForce && checkMethod) {
          afterFullData.forEach(row => {
            const rowid = handleGetRowId(row);
            if (selectCheckboxMaps[rowid] || checkMethod({
              $table: $xeTable,
              row
            })) {
              selectRowMaps[rowid] = row;
            }
          });
        } else {
          afterFullData.forEach(row => {
            const rowid = handleGetRowId(row);
            selectRowMaps[rowid] = row;
          });
        }
      } else {
        /**
         * 如果是行取消
         * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中
         * 如果不存在选中方法，无需处理，临时集合默认为空
         */
        if (!isForce && checkMethod) {
          afterFullData.forEach(row => {
            const rowid = handleGetRowId(row);
            if (checkMethod({
              $table: $xeTable,
              row
            }) ? false : selectCheckboxMaps[rowid]) {
              selectRowMaps[rowid] = row;
            }
          });
        }
      }
    }
  }
  if (reserve) {
    if (checked) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectRowMaps, (row, rowid) => {
        checkboxReserveRowMap[rowid] = row;
      });
    } else {
      afterFullData.forEach(row => handleCheckboxReserveRow($xeTable, row, false));
    }
  }
  reactData.updateCheckboxFlag++;
  internalData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
  reactData.isAllSelected = checked;
  reactData.isIndeterminate = false;
  internalData.treeIndeterminateRowMaps = {};
  $xeTable.checkSelectionStatus();
  return $xeTable.$nextTick();
}
// 还原展开、选中等相关状态
function handleReserveStatus($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    expandColumn,
    currentRow,
    selectRadioRow
  } = reactData;
  const {
    fullDataRowIdData,
    fullAllDataRowIdData,
    radioReserveRow,
    selectCheckboxMaps,
    treeExpandedMaps,
    rowExpandedMaps
  } = internalData;
  const expandOpts = $xeTable.computeExpandOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const radioOpts = $xeTable.computeRadioOpts;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  // 单选框
  if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
    reactData.selectRadioRow = null; // 刷新单选行状态
  }
  // 还原保留选中状态
  if (radioOpts.reserve && radioReserveRow) {
    const rowid = getRowid($xeTable, radioReserveRow);
    if (fullDataRowIdData[rowid]) {
      handleCheckedRadioRow($xeTable, fullDataRowIdData[rowid].row, true);
    }
  }
  // 复选框
  internalData.selectCheckboxMaps = getRecoverRowMaps($xeTable, selectCheckboxMaps); // 刷新多选行状态
  reactData.updateCheckboxFlag++;
  // 还原保留选中状态
  if (checkboxOpts.reserve) {
    handleCheckedCheckboxRow($xeTable, handleReserveRow($xeTable, internalData.checkboxReserveRowMap), true, true);
  }
  if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
    reactData.currentRow = null; // 刷新当前行状态
  }
  // 行展开
  internalData.rowExpandedMaps = expandColumn ? getRecoverRowMaps($xeTable, rowExpandedMaps) : {}; // 刷新行展开状态
  reactData.rowExpandedFlag++;
  // 还原保留状态
  if (expandColumn && expandOpts.reserve) {
    $xeTable.setRowExpand(handleReserveRow($xeTable, internalData.rowExpandedReserveRowMap), true);
  }
  // 树展开
  internalData.treeExpandedMaps = treeConfig ? getRecoverRowMaps($xeTable, treeExpandedMaps) : {}; // 刷新树展开状态
  reactData.treeExpandedFlag++;
  if (treeConfig && treeOpts.reserve) {
    $xeTable.setTreeExpand(handleReserveRow($xeTable, internalData.treeExpandedReserveRowMap), true);
  }
}
/**
 * 处理默认展开树节点
 */
const handleDefaultTreeExpand = $xeTable => {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  if (treeConfig) {
    const {
      tableFullData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      expandAll,
      expandRowKeys
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    if (expandAll) {
      $xeTable.setAllTreeExpand(true);
    } else if (expandRowKeys) {
      const defExpandeds = [];
      const rowkey = getRowkey($xeTable);
      expandRowKeys.forEach(rowid => {
        const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData, item => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, rowkey), {
          children: childrenField
        });
        if (matchObj) {
          defExpandeds.push(matchObj.item);
        }
      });
      $xeTable.setTreeExpand(defExpandeds, true);
    }
  }
};
const handleAsyncTreeExpandChilds = ($xeTable, row) => {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const treeOpts = $xeTable.computeTreeOpts;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  const {
    transform,
    loadMethod
  } = treeOpts;
  const {
    checkStrictly
  } = checkboxOpts;
  return new Promise(resolve => {
    if (loadMethod) {
      const {
        fullAllDataRowIdData,
        treeExpandLazyLoadedMaps
      } = internalData;
      const rowid = getRowid($xeTable, row);
      const rowRest = fullAllDataRowIdData[rowid];
      treeExpandLazyLoadedMaps[rowid] = row;
      Promise.resolve(loadMethod({
        $table: $xeTable,
        row
      })).then(childRecords => {
        if (rowRest) {
          rowRest.treeLoaded = true;
        }
        if (treeExpandLazyLoadedMaps[rowid]) {
          delete treeExpandLazyLoadedMaps[rowid];
        }
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)) {
          childRecords = [];
        }
        if (childRecords) {
          return $xeTable.loadTreeChildren(row, childRecords).then(childRows => {
            const {
              treeExpandedMaps
            } = internalData;
            if (childRows.length && !treeExpandedMaps[rowid]) {
              treeExpandedMaps[rowid] = row;
            }
            reactData.treeExpandedFlag++;
            // 如果当前节点已选中，则展开后子节点也被选中
            if (!checkStrictly && $xeTable.isCheckedByCheckboxRow(row)) {
              handleCheckedCheckboxRow($xeTable, childRows, true);
            }
            return $xeTable.$nextTick().then(() => {
              if (transform) {
                $xeTable.handleTableData();
                updateAfterDataIndex($xeTable);
                return $xeTable.$nextTick();
              }
            });
          });
        }
      }).catch(() => {
        const {
          treeExpandLazyLoadedMaps
        } = internalData;
        if (rowRest) {
          rowRest.treeLoaded = false;
        }
        if (treeExpandLazyLoadedMaps[rowid]) {
          delete treeExpandLazyLoadedMaps[rowid];
        }
      }).finally(() => {
        reactData.treeExpandedFlag++;
        $xeTable.$nextTick().then(() => $xeTable.recalculate()).then(() => resolve());
      });
    } else {
      resolve();
    }
  });
};
const handleTreeExpandReserve = ($xeTable, row, expanded) => {
  const internalData = $xeTable;
  const {
    treeExpandedReserveRowMap
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  if (treeOpts.reserve) {
    const rowid = getRowid($xeTable, row);
    if (expanded) {
      treeExpandedReserveRowMap[rowid] = row;
    } else if (treeExpandedReserveRowMap[rowid]) {
      delete treeExpandedReserveRowMap[rowid];
    }
  }
};
const handleAsyncRowExpand = ($xeTable, row) => {
  const reactData = $xeTable;
  const internalData = $xeTable;
  return new Promise(resolve => {
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      loadMethod
    } = expandOpts;
    if (loadMethod) {
      const {
        fullAllDataRowIdData,
        rowExpandLazyLoadedMaps
      } = internalData;
      const rowid = getRowid($xeTable, row);
      const rowRest = fullAllDataRowIdData[rowid];
      rowExpandLazyLoadedMaps[rowid] = row;
      loadMethod({
        $table: $xeTable,
        row,
        rowIndex: $xeTable.getRowIndex(row),
        $rowIndex: $xeTable.getVMRowIndex(row)
      }).then(() => {
        const {
          rowExpandedMaps
        } = internalData;
        if (rowRest) {
          rowRest.expandLoaded = true;
        }
        rowExpandedMaps[rowid] = row;
        reactData.rowExpandedFlag++;
      }).catch(() => {
        if (rowRest) {
          rowRest.expandLoaded = false;
        }
      }).finally(() => {
        const {
          rowExpandLazyLoadedMaps
        } = internalData;
        if (rowExpandLazyLoadedMaps[rowid]) {
          delete rowExpandLazyLoadedMaps[rowid];
        }
        reactData.rowExpandedFlag++;
        $xeTable.$nextTick().then(() => $xeTable.recalculate()).then(() => $xeTable.updateCellAreas()).then(() => resolve());
      });
    } else {
      resolve();
    }
  });
};
function calcVarRowHeightConfig($xeTable, sizeKey, sizeEl) {
  const reactData = $xeTable;
  const {
    rowHeightStore
  } = reactData;
  if (sizeEl && sizeEl.clientHeight) {
    rowHeightStore[sizeKey] = sizeEl.clientHeight;
  }
}
function computeRowHeight($xeTable) {
  const reactData = $xeTable;
  const {
    isAllOverflow
  } = reactData;
  const tableHeader = $xeTable.$refs.refTableHeader;
  const tableBody = $xeTable.$refs.refTableBody;
  const tableBodyElem = tableBody ? tableBody.$el : null;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  let rowHeight = 0;
  if (isAllOverflow) {
    if (tableBodyElem) {
      const tableHeaderElem = tableHeader ? tableHeader.$el : null;
      let firstTrElem;
      firstTrElem = tableBodyElem.querySelector('tr');
      if (!firstTrElem && tableHeaderElem) {
        firstTrElem = tableHeaderElem.querySelector('tr');
      }
      if (firstTrElem) {
        rowHeight = firstTrElem.clientHeight;
      }
    }
    if (!rowHeight) {
      rowHeight = defaultRowHeight;
    }
  } else {
    rowHeight = defaultRowHeight;
  }
  // 最低支持 18px 行高
  return Math.max(18, rowHeight);
}
function handleVirtualYVisible($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    isAllOverflow,
    expandColumn,
    isScrollYBig,
    scrollYHeight
  } = reactData;
  const {
    elemStore,
    isResizeCellHeight,
    afterFullData,
    fullAllDataRowIdData
  } = internalData;
  const rowOpts = $xeTable.computeRowOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (bodyScrollElem) {
    const clientHeight = bodyScrollElem.clientHeight;
    let scrollTop = bodyScrollElem.scrollTop;
    if (isScrollYBig) {
      scrollTop = Math.ceil((scrollYHeight - clientHeight) * Math.min(1, scrollTop / (maxYHeight - clientHeight)));
    }
    const startTop = scrollTop;
    const endTop = scrollTop + clientHeight;
    let toVisibleIndex = -1;
    let visibleSize = 0;
    const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
    if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
      toVisibleIndex = Math.floor(startTop / defaultRowHeight) - 1;
      visibleSize = Math.ceil(clientHeight / defaultRowHeight) + 1;
    } else {
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      let leftIndex = 0;
      let rightIndex = afterFullData.length;
      while (leftIndex < rightIndex) {
        const rIndex = Math.floor((leftIndex + rightIndex) / 2);
        const row = afterFullData[rIndex];
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        if (rowRest.oTop <= startTop) {
          leftIndex = rIndex + 1;
        } else {
          rightIndex = rIndex;
        }
      }
      toVisibleIndex = leftIndex === afterFullData.length ? leftIndex : Math.max(0, leftIndex < afterFullData.length ? leftIndex - 2 : 0);
      for (let rIndex = toVisibleIndex, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
        const row = afterFullData[rIndex];
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        visibleSize++;
        if (rowRest.oTop > endTop || visibleSize >= 100) {
          break;
        }
      }
    }
    return {
      toVisibleIndex: Math.max(0, toVisibleIndex),
      visibleSize: Math.max(6, visibleSize)
    };
  }
  return {
    toVisibleIndex: 0,
    visibleSize: 6
  };
}
function calculateMergerOffsetIndex(list, offsetItem, type) {
  for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
    const mergeItem = list[mcIndex];
    const {
      startIndex,
      endIndex
    } = offsetItem;
    const mergeStartIndex = mergeItem[type];
    const mergeSpanNumber = mergeItem[type + 'span'];
    const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
    if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
      offsetItem.startIndex = mergeStartIndex;
    }
    if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
      offsetItem.endIndex = mergeEndIndex;
    }
    if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
      mcIndex = -1;
    }
  }
}
function buildMergeData(mergeConfigs) {
  const mergeMaps = {};
  if (mergeConfigs && mergeConfigs.length) {
    for (let mIndex = 0; mIndex < mergeConfigs.length; mIndex++) {
      const {
        row: _rowIndex,
        col: _columnIndex,
        rowspan: mergeRowspan,
        colspan: mergeColspan
      } = mergeConfigs[mIndex];
      for (let i = 0; i < mergeRowspan; i++) {
        for (let j = 0; j < mergeColspan; j++) {
          mergeMaps[`${_rowIndex + i}:${_columnIndex + j}`] = !i && !j ? {
            rowspan: mergeRowspan,
            colspan: mergeColspan
          } : {
            rowspan: 0,
            colspan: 0
          };
        }
      }
    }
  }
  return mergeMaps;
}
const handleBodyMerge = ($xeTable, merges) => {
  const internalData = $xeTable;
  const {
    fullAllDataRowIdData,
    fullColumnIdData,
    visibleColumn,
    afterFullData,
    mergeBodyList,
    mergeBodyMaps
  } = internalData;
  if (merges) {
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
      merges = [merges];
    }
    merges.forEach(item => {
      let {
        row,
        col,
        rowspan,
        colspan
      } = item;
      let mergeRowIndex = -1;
      let mergeColumnIndex = -1;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)) {
        mergeRowIndex = row;
      } else {
        const rowid = row ? handleGetRowId(row) : null;
        const rowRest = rowid ? fullAllDataRowIdData[rowid] : null;
        if (rowRest) {
          mergeRowIndex = rowRest._index;
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(col)) {
        mergeColumnIndex = col;
      } else {
        const colid = col ? col.id : null;
        const colRest = colid ? fullColumnIdData[colid] : null;
        if (colRest) {
          mergeColumnIndex = colRest._index;
        }
      }
      if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
        rowspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan) || 1;
        colspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan) || 1;
        if (rowspan > 1 || colspan > 1) {
          const row = afterFullData[mergeRowIndex];
          const column = visibleColumn[mergeColumnIndex];
          let mergeItem = mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
          if (mergeItem) {
            mergeItem.rowspan = rowspan;
            mergeItem.colspan = colspan;
            mergeItem._rowspan = rowspan;
            mergeItem._colspan = colspan;
          } else {
            mergeItem = {
              row: mergeRowIndex,
              col: mergeColumnIndex,
              rowspan,
              colspan,
              _row: row,
              _col: column,
              _rowspan: rowspan,
              _colspan: colspan
            };
            mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
            mergeBodyList.push(mergeItem);
          }
        }
      }
    });
  }
};
const handleFooterMerge = ($xeTable, merges) => {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    footerTableData
  } = reactData;
  const {
    mergeFooterList,
    mergeFooterMaps,
    fullColumnIdData
  } = internalData;
  if (merges) {
    const {
      visibleColumn
    } = internalData;
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
      merges = [merges];
    }
    merges.forEach(item => {
      let {
        row: margeRow,
        col: margeCol,
        rowspan,
        colspan
      } = item;
      const mergeRowIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow) ? margeRow : -1;
      let mergeColumnIndex = -1;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)) {
        mergeColumnIndex = margeCol;
      } else {
        const colid = margeCol ? margeCol.id : null;
        const colRest = colid ? fullColumnIdData[colid] : null;
        if (colRest) {
          mergeColumnIndex = colRest._index;
        }
      }
      if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
        rowspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan) || 1;
        colspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan) || 1;
        if (rowspan > 1 || colspan > 1) {
          const row = footerTableData[mergeRowIndex];
          const column = visibleColumn[mergeColumnIndex];
          let mergeItem = mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
          if (mergeItem) {
            mergeItem.rowspan = rowspan;
            mergeItem.colspan = colspan;
            mergeItem._rowspan = rowspan;
            mergeItem._colspan = colspan;
          } else {
            mergeItem = {
              row: mergeRowIndex,
              col: mergeColumnIndex,
              rowspan,
              colspan,
              _row: row,
              _col: column,
              _rowspan: rowspan,
              _colspan: colspan
            };
            mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
            mergeFooterList.push(mergeItem);
          }
        }
      }
    });
  }
};
function removeBodyMerges($xeTable, merges) {
  const internalData = $xeTable;
  const {
    mergeBodyList,
    fullColumnIdData,
    fullAllDataRowIdData,
    mergeBodyMaps
  } = internalData;
  const rest = [];
  if (merges) {
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
      merges = [merges];
    }
    merges.forEach(item => {
      const {
        row: margeRow,
        col: margeCol
      } = item;
      let mergeRowIndex = -1;
      let mergeColumnIndex = -1;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)) {
        mergeRowIndex = margeRow;
      } else {
        const rowid = margeRow ? handleGetRowId(margeRow) : null;
        const rowRest = rowid ? fullAllDataRowIdData[rowid] : null;
        if (rowRest) {
          mergeRowIndex = rowRest._index;
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)) {
        mergeColumnIndex = margeCol;
      } else {
        const colid = margeCol ? margeCol.id : null;
        const colRest = colid ? fullColumnIdData[colid] : null;
        if (colRest) {
          mergeColumnIndex = colRest._index;
        }
      }
      const mcIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mergeBodyList, item => item.row === mergeRowIndex && item.col === mergeColumnIndex);
      if (mcIndex > -1) {
        const rItems = mergeBodyList.splice(mcIndex, 1);
        const item = rItems[0];
        if (item) {
          rest.push(rItems[0]);
          if (mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`]) {
            delete mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
          }
        }
      }
    });
  }
  return rest;
}
function removeFooterMerges($xeTable, merges) {
  const internalData = $xeTable;
  const {
    mergeFooterList,
    fullColumnIdData,
    mergeFooterMaps
  } = internalData;
  const rest = [];
  if (merges) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
      merges = [merges];
    }
    merges.forEach(item => {
      const {
        row: margeRow,
        col: margeCol
      } = item;
      const mergeRowIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow) ? margeRow : -1;
      let mergeColumnIndex = -1;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)) {
        mergeColumnIndex = margeCol;
      } else {
        const colid = margeCol ? margeCol.id : null;
        const colRest = colid ? fullColumnIdData[colid] : null;
        if (colRest) {
          mergeColumnIndex = colRest._index;
        }
      }
      const mcIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mergeFooterList, item => item.row === mergeRowIndex && item.col === mergeColumnIndex);
      if (mcIndex > -1) {
        const rItems = mergeFooterList.splice(mcIndex, 1);
        const item = rItems[0];
        if (item) {
          rest.push(item);
          if (mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`]) {
            delete mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
          }
        }
      }
    });
  }
  return rest;
}
function handleSortEvent($xeTable, evnt, sortConfs, isUpdate) {
  const sortOpts = $xeTable.computeSortOpts;
  const {
    multiple,
    remote,
    orders
  } = sortOpts;
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)) {
    sortConfs = [sortConfs];
  }
  if (sortConfs && sortConfs.length) {
    if (!multiple) {
      sortConfs = [sortConfs[0]];
      clearAllSort($xeTable);
    }
    let firstColumn = null;
    sortConfs.forEach((confs, index) => {
      let {
        field,
        order
      } = confs;
      let column = field;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)) {
        column = $xeTable.getColumnByField(field);
      }
      if (!firstColumn) {
        firstColumn = column;
      }
      if (column && column.sortable) {
        if (orders && orders.indexOf(order) === -1) {
          order = getNextSortOrder($xeTable, column);
        }
        if (column.order !== order) {
          column.order = order;
        }
        column.sortTime = Date.now() + index;
      }
    });
    if (isUpdate) {
      if (!remote) {
        $xeTable.handleTableData(true);
      }
    }
    if (evnt) {
      $xeTable.handleColumnSortEvent(evnt, firstColumn);
    }
    return $xeTable.$nextTick().then(() => {
      updateRowOffsetTop($xeTable);
      $xeTable.updateCellAreas();
      return updateStyle($xeTable);
    });
  }
  return $xeTable.$nextTick();
}
function clearAllSort($xeTable) {
  const internalData = $xeTable;
  const {
    tableFullColumn
  } = internalData;
  tableFullColumn.forEach(column => {
    column.order = null;
  });
}
function calcTableHeight($xeTable, key) {
  const props = $xeTable;
  const reactData = $xeTable;
  const {
    parentHeight
  } = reactData;
  const val = props[key];
  let num = 0;
  if (val) {
    if (val === '100%' || val === 'auto') {
      num = parentHeight;
    } else {
      const excludeHeight = $xeTable.getExcludeHeight();
      if (isScale(val)) {
        num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
      } else {
        num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
      }
      num = Math.max(40, num - excludeHeight);
    }
  }
  return num;
}
/**
 * 列宽算法，计算单元格列宽，动态分配可用剩余空间
 * 支持 px、%、固定 混合分配
 * 支持动态列表调整分配
 * 支持自动分配偏移量
 * 支持 width=60 width=60px width=10% min-width=60 min-width=60px min-width=10%
 */
function autoCellWidth($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    elemStore
  } = internalData;
  const bodyWrapperElem = getRefElem(elemStore['main-body-wrapper']);
  if (!bodyWrapperElem) {
    return;
  }
  const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
  if (!yHandleEl) {
    return;
  }
  const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
  if (!xHandleEl) {
    return;
  }
  let tWidth = 0;
  const minCellWidth = 40; // 列宽最少限制 40px
  const bodyWidth = bodyWrapperElem.clientWidth;
  let remainWidth = bodyWidth;
  let meanWidth = remainWidth / 100;
  const {
    fit
  } = props;
  const {
    columnStore
  } = reactData;
  const {
    resizeList,
    pxMinList,
    autoMinList,
    pxList,
    scaleList,
    scaleMinList,
    autoList,
    remainList
  } = columnStore;
  // 最小宽
  pxMinList.forEach(column => {
    const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth);
    tWidth += minWidth;
    column.renderWidth = minWidth;
  });
  // 最小自适应
  autoMinList.forEach(column => {
    const scaleWidth = Math.max(60, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));
    tWidth += scaleWidth;
    column.renderWidth = scaleWidth;
  });
  // 最小百分比
  scaleMinList.forEach(column => {
    const scaleWidth = Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth) * meanWidth);
    tWidth += scaleWidth;
    column.renderWidth = scaleWidth;
  });
  // 固定百分比
  scaleList.forEach(column => {
    const scaleWidth = Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width) * meanWidth);
    tWidth += scaleWidth;
    column.renderWidth = scaleWidth;
  });
  // 固定宽
  pxList.forEach(column => {
    const width = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width);
    tWidth += width;
    column.renderWidth = width;
  });
  // 自适应宽
  autoList.forEach(column => {
    const width = Math.max(60, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));
    tWidth += width;
    column.renderWidth = width;
  });
  // 调整了列宽
  resizeList.forEach(column => {
    const width = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.resizeWidth);
    tWidth += width;
    column.renderWidth = width;
  });
  remainWidth -= tWidth;
  meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
  if (fit) {
    if (remainWidth > 0) {
      scaleMinList.concat(pxMinList).concat(autoMinList).forEach(column => {
        tWidth += meanWidth;
        column.renderWidth += meanWidth;
      });
    }
  } else {
    meanWidth = minCellWidth;
  }
  // 剩余均分
  remainList.forEach(column => {
    const width = Math.max(meanWidth, minCellWidth);
    column.renderWidth = width;
    tWidth += width;
  });
  if (fit) {
    /**
     * 偏移量算法
     * 如果所有列足够放的情况下，从最后动态列开始分配
     */
    const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
    let dynamicSize = dynamicList.length - 1;
    if (dynamicSize > 0) {
      let i = bodyWidth - tWidth;
      if (i > 0) {
        while (i > 0 && dynamicSize >= 0) {
          i--;
          dynamicList[dynamicSize--].renderWidth++;
        }
        tWidth = bodyWidth;
      }
    }
  }
  reactData.scrollXWidth = tWidth;
  reactData.resizeWidthFlag++;
  updateColumnOffsetLeft($xeTable);
  updateHeight($xeTable);
}
const calcCellAutoHeight = (rowRest, wrapperEl) => {
  const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);
  let colHeight = rowRest.height;
  for (let i = 0; i < cellElemList.length; i++) {
    const cellElem = cellElemList[i];
    const tdEl = cellElem.parentElement;
    const topBottomPadding = Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(tdEl.style.paddingTop) + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(tdEl.style.paddingBottom));
    const cellHeight = cellElem ? cellElem.clientHeight : 0;
    colHeight = Math.max(colHeight - topBottomPadding, Math.ceil(cellHeight));
  }
  return colHeight;
};
const calcCellHeight = $xeTable => {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    tableData,
    isAllOverflow,
    scrollYLoad,
    scrollXLoad
  } = reactData;
  const {
    fullAllDataRowIdData
  } = internalData;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const el = $xeTable.$refs.refElem;
  if (!isAllOverflow && scrollYLoad && el) {
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    tableData.forEach(row => {
      const rowid = handleGetRowId(row);
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        const height = calcCellAutoHeight(rowRest, el);
        rowRest.height = Math.max(defaultRowHeight, scrollXLoad ? Math.max(rowRest.height, height) : height);
      }
    });
    reactData.calcCellHeightFlag++;
  }
};
function getOrderField($xeTable, column) {
  const {
    sortBy,
    sortType
  } = column;
  return row => {
    let cellValue;
    if (sortBy) {
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sortBy) ? sortBy({
        row,
        column
      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, sortBy);
    } else {
      cellValue = $xeTable.getCellLabel(row, column);
    }
    if (!sortType || sortType === 'auto') {
      return isNaN(cellValue) ? cellValue : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
    } else if (sortType === 'number') {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
    } else if (sortType === 'string') {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);
    }
    return cellValue;
  };
}
function handleTargetEnterEvent($xeTable, isClear) {
  const internalData = $xeTable;
  const $tooltip = $xeTable.$refs.refTooltip;
  clearTimeout(internalData.tooltipTimeout);
  if (isClear) {
    $xeTable.closeTooltip();
  } else {
    if ($tooltip && $tooltip.setActived) {
      $tooltip.setActived(true);
    }
  }
}
function clearDragStatus($xeTable) {
  const reactData = $xeTable;
  const {
    dragRow,
    dragCol
  } = reactData;
  if (dragRow || dragCol) {
    clearColDropOrigin($xeTable);
    clearRowDropOrigin($xeTable);
    hideDropTip($xeTable);
    reactData.dragRow = null;
    reactData.dragCol = null;
    reactData.isDragColMove = false;
    reactData.isDragRowMove = false;
  }
}
function clearRowDropOrigin($xeTable) {
  const el = $xeTable.$el;
  if (el) {
    const clss = 'row--drag-origin';
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`), elem => {
      elem.draggable = false;
      removeClass(elem, clss);
    });
  }
}
function updateRowDropOrigin($xeTable, row) {
  const el = $xeTable.$el;
  if (el) {
    const clss = 'row--drag-origin';
    const rowid = getRowid($xeTable, row);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), elem => {
      addClass(elem, clss);
    });
  }
}
function updateRowDropTipContent($xeTable, tdEl) {
  const reactData = $xeTable;
  const props = $xeTable;
  const {
    dragConfig
  } = props;
  const {
    dragRow
  } = reactData;
  const rowDragOpts = $xeTable.computeRowDragOpts;
  const {
    tooltipMethod
  } = rowDragOpts;
  const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
  let tipContent = '';
  if (rTooltipMethod) {
    const rtParams = {
      $table: $xeTable,
      row: dragRow
    };
    tipContent = `${rTooltipMethod(rtParams) || ''}`;
  } else {
    tipContent = methods_getI18n('vxe.table.dragTip', [tdEl.textContent || '']);
  }
  reactData.dragTipText = tipContent;
}
function updateColDropOrigin($xeTable, column) {
  const el = $xeTable.$el;
  if (el) {
    const colQuerys = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
      colQuerys.push(`[colid="${item.id}"]`);
    });
    const clss = 'col--drag-origin';
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(colQuerys.join(',')), elem => {
      addClass(elem, clss);
    });
  }
}
function clearColDropOrigin($xeTable) {
  const el = $xeTable.$el;
  if (el) {
    const clss = 'col--drag-origin';
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`), elem => {
      elem.draggable = false;
      removeClass(elem, clss);
    });
  }
}
function updateColDropTipContent($xeTable, tdEl) {
  const reactData = $xeTable;
  const {
    dragCol
  } = reactData;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    tooltipMethod
  } = columnDragOpts;
  let tipContent = '';
  if (tooltipMethod) {
    const dtParams = {
      $table: $xeTable,
      column: dragCol
    };
    tipContent = `${tooltipMethod(dtParams) || ''}`;
  } else {
    tipContent = methods_getI18n('vxe.table.dragTip', [tdEl.textContent || '']);
  }
  reactData.dragTipText = tipContent;
}
function showDropTip($xeTable, evnt, trEl, thEl, showLine, dragPos) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const el = $xeTable.$refs.refElem;
  if (!el) {
    return;
  }
  const {
    overflowX,
    scrollbarWidth,
    overflowY,
    scrollbarHeight
  } = reactData;
  const {
    prevDragToChild
  } = internalData;
  const wrapperRect = el.getBoundingClientRect();
  const osbWidth = overflowY ? scrollbarWidth : 0;
  const osbHeight = overflowX ? scrollbarHeight : 0;
  const tableWrapperWidth = el.clientWidth;
  const tableWrapperHeight = el.clientHeight;
  if (trEl) {
    const rdLineEl = $xeTable.$refs.refDragRowLineElem;
    if (rdLineEl) {
      if (showLine) {
        const scrollbarYToLeft = $xeTable.computeScrollbarYToLeft;
        const trRect = trEl.getBoundingClientRect();
        let trHeight = trEl.clientHeight;
        const offsetTop = Math.max(1, trRect.y - wrapperRect.y);
        if (offsetTop + trHeight > tableWrapperHeight - osbHeight) {
          trHeight = tableWrapperHeight - offsetTop - osbHeight;
        }
        rdLineEl.style.display = 'block';
        rdLineEl.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
        rdLineEl.style.top = `${offsetTop}px`;
        rdLineEl.style.height = `${trHeight}px`;
        rdLineEl.style.width = `${tableWrapperWidth - osbWidth}px`;
        rdLineEl.setAttribute('drag-pos', dragPos);
        rdLineEl.setAttribute('drag-to-child', prevDragToChild ? 'y' : 'n');
      } else {
        rdLineEl.style.display = '';
      }
    }
  } else if (thEl) {
    const cdLineEl = $xeTable.$refs.refDragColLineElem;
    if (cdLineEl) {
      if (showLine) {
        const scrollbarXToTop = $xeTable.computeScrollbarXToTop;
        const leftContainerElem = $xeTable.$refs.refLeftContainer;
        const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
        const rightContainerElem = $xeTable.$refs.refRightContainer;
        const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
        const thRect = thEl.getBoundingClientRect();
        let thWidth = thEl.clientWidth;
        const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
        const startX = leftContainerWidth;
        let offsetLeft = thRect.x - wrapperRect.x;
        if (offsetLeft < startX) {
          thWidth -= startX - offsetLeft;
          offsetLeft = startX;
        }
        const endX = tableWrapperWidth - rightContainerWidth - (rightContainerWidth ? 0 : osbWidth);
        if (offsetLeft + thWidth > endX) {
          thWidth = endX - offsetLeft;
        }
        cdLineEl.style.display = 'block';
        cdLineEl.style.top = `${offsetTop}px`;
        cdLineEl.style.left = `${offsetLeft}px`;
        cdLineEl.style.width = `${thWidth}px`;
        if (prevDragToChild) {
          cdLineEl.style.height = `${thRect.height}px`;
        } else {
          cdLineEl.style.height = `${tableWrapperHeight - offsetTop - (scrollbarXToTop ? 0 : osbHeight)}px`;
        }
        cdLineEl.setAttribute('drag-pos', dragPos);
        cdLineEl.setAttribute('drag-to-child', prevDragToChild ? 'y' : 'n');
      } else {
        cdLineEl.style.display = '';
      }
    }
  }
  const rdTipEl = $xeTable.$refs.refDragTipElem;
  if (rdTipEl) {
    rdTipEl.style.display = 'block';
    rdTipEl.style.top = `${Math.min(el.clientHeight - el.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
    rdTipEl.style.left = `${Math.min(el.clientWidth - el.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
    rdTipEl.setAttribute('drag-status', showLine ? prevDragToChild ? 'sub' : 'normal' : 'disabled');
  }
}
function hideDropTip($xeTable) {
  const rdTipEl = $xeTable.$refs.refDragTipElem;
  const rdLineEl = $xeTable.$refs.refDragRowLineElem;
  const cdLineEl = $xeTable.$refs.refDragColLineElem;
  if (rdTipEl) {
    rdTipEl.style.display = '';
  }
  if (rdLineEl) {
    rdLineEl.style.display = '';
  }
  if (cdLineEl) {
    cdLineEl.style.display = '';
  }
}
/**
 * 处理显示 tooltip
 * @param {Event} evnt 事件
 * @param {Row} row 行对象
 */
function handleTooltip($xeTable, evnt, tdEl, overflowElem, tipElem, params) {
  const reactData = $xeTable;
  const tipOverEl = overflowElem || tdEl;
  if (!tipOverEl) {
    return $xeTable.$nextTick();
  }
  params.cell = tdEl;
  const {
    tooltipStore
  } = reactData;
  const tooltipOpts = $xeTable.computeTooltipOpts;
  const {
    column,
    row
  } = params;
  const {
    showAll,
    contentMethod
  } = tooltipOpts;
  const customContent = contentMethod ? contentMethod(params) : null;
  const useCustom = contentMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(customContent);
  const content = useCustom ? customContent : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(column.type === 'html' ? tipOverEl.innerText : tipOverEl.textContent).trim();
  const isOver = tipOverEl.scrollWidth > tipOverEl.clientWidth;
  if (content && (showAll || useCustom || isOver)) {
    Object.assign(tooltipStore, {
      row,
      column,
      visible: true,
      currOpts: {}
    });
    $xeTable.$nextTick(() => {
      const $tooltip = $xeTable.$refs.refTooltip;
      if ($tooltip && $tooltip.open) {
        $tooltip.open(isOver ? tipOverEl : tipElem, formatText(content));
      }
    });
  }
  return $xeTable.$nextTick();
}
function handleScrollToRowColumn($xeTable, fieldOrColumn, row) {
  const internalData = $xeTable;
  const {
    fullColumnIdData
  } = internalData;
  const column = handleFieldOrColumn($xeTable, fieldOrColumn);
  if (column && fullColumnIdData[column.id]) {
    return colToVisible($xeTable, column, row);
  }
  return $xeTable.$nextTick();
}
function handleRowExpandReserve($xeTable, row, expanded) {
  const internalData = $xeTable;
  const {
    rowExpandedReserveRowMap
  } = internalData;
  const expandOpts = $xeTable.computeExpandOpts;
  if (expandOpts.reserve) {
    const rowid = getRowid($xeTable, row);
    if (expanded) {
      rowExpandedReserveRowMap[rowid] = row;
    } else if (rowExpandedReserveRowMap[rowid]) {
      delete rowExpandedReserveRowMap[rowid];
    }
  }
}
function handleDefaultMergeCells($xeTable) {
  const props = $xeTable;
  const {
    mergeCells
  } = props;
  if (mergeCells) {
    $xeTable.setMergeCells(mergeCells);
  }
}
function handleDefaultMergeFooterItems($xeTable) {
  const props = $xeTable;
  const {
    mergeFooterItems
  } = props;
  if (mergeFooterItems) {
    $xeTable.setMergeFooterItems(mergeFooterItems);
  }
}
// 计算可视渲染相关数据
function computeScrollLoad($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  return $xeTable.$nextTick().then(() => {
    const {
      scrollXLoad,
      scrollYLoad
    } = reactData;
    const {
      scrollXStore,
      scrollYStore
    } = internalData;
    const virtualYOpts = $xeTable.computeVirtualYOpts;
    const virtualXOpts = $xeTable.computeVirtualXOpts;
    // 计算 X 逻辑
    if (scrollXLoad) {
      const {
        toVisibleIndex: toXVisibleIndex,
        visibleSize: visibleXSize
      } = handleVirtualXVisible($xeTable);
      const offsetXSize = Math.max(0, virtualXOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.oSize) : 0);
      scrollXStore.preloadSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.preSize);
      scrollXStore.offsetSize = offsetXSize;
      scrollXStore.visibleSize = visibleXSize;
      scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
      scrollXStore.visibleStartIndex = Math.max(scrollXStore.startIndex, toXVisibleIndex);
      scrollXStore.visibleEndIndex = Math.min(scrollXStore.endIndex, toXVisibleIndex + visibleXSize);
      $xeTable.updateScrollXData().then(() => {
        loadScrollXData($xeTable);
      });
    } else {
      $xeTable.updateScrollXSpace();
    }
    // 计算 Y 逻辑
    const rowHeight = computeRowHeight($xeTable);
    scrollYStore.rowHeight = rowHeight; // 已废弃
    reactData.rowHeight = rowHeight;
    const {
      toVisibleIndex: toYVisibleIndex,
      visibleSize: visibleYSize
    } = handleVirtualYVisible($xeTable);
    if (scrollYLoad) {
      const offsetYSize = Math.max(0, virtualYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize) : 0);
      scrollYStore.preloadSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.preSize);
      scrollYStore.offsetSize = offsetYSize;
      scrollYStore.visibleSize = visibleYSize;
      scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
      scrollYStore.visibleStartIndex = Math.max(scrollYStore.startIndex, toYVisibleIndex);
      scrollYStore.visibleEndIndex = Math.min(scrollYStore.endIndex, toYVisibleIndex + visibleYSize);
      $xeTable.updateScrollYData().then(() => {
        loadScrollYData($xeTable);
      });
    } else {
      $xeTable.updateScrollYSpace();
    }
  });
}
function calcScrollbar($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    scrollXWidth,
    scrollYHeight
  } = reactData;
  const {
    elemStore
  } = internalData;
  const scrollbarOpts = $xeTable.computeScrollbarOpts;
  const bodyWrapperElem = getRefElem(elemStore['main-body-wrapper']);
  const headerTableElem = getRefElem(elemStore['main-header-table']);
  const footerTableElem = getRefElem(elemStore['main-footer-table']);
  const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
  const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
  let overflowY = false;
  let overflowX = false;
  if (bodyWrapperElem) {
    overflowY = scrollYHeight > bodyWrapperElem.clientHeight;
    if (yHandleEl) {
      reactData.scrollbarWidth = scrollbarOpts.width || yHandleEl.offsetWidth - yHandleEl.clientWidth || 14;
    }
    reactData.overflowY = overflowY;
    overflowX = scrollXWidth > bodyWrapperElem.clientWidth;
    if (xHandleEl) {
      reactData.scrollbarHeight = scrollbarOpts.height || xHandleEl.offsetHeight - xHandleEl.clientHeight || 14;
    }
    reactData.overflowX = overflowX;
    const headerHeight = headerTableElem ? headerTableElem.clientHeight : 0;
    const footerHeight = footerTableElem ? footerTableElem.clientHeight : 0;
    internalData.tableHeight = bodyWrapperElem.offsetHeight;
    internalData.headerHeight = headerHeight;
    internalData.footerHeight = footerHeight;
    reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, $xeTable.getParentHeight());
  }
  if (overflowX) {
    $xeTable.checkScrolling();
  }
}
function handleRecalculateLayout($xeTable, reFull) {
  const internalData = $xeTable;
  const el = $xeTable.$refs.refElem;
  internalData.rceRunTime = Date.now();
  if (!el || !el.clientWidth) {
    return $xeTable.$nextTick();
  }
  const varEl = $xeTable.$refs.refVarElem;
  if (varEl) {
    const [defEl, mediumEl, smallEl, miniEl] = varEl.children;
    calcVarRowHeightConfig($xeTable, 'default', defEl);
    calcVarRowHeightConfig($xeTable, 'medium', mediumEl);
    calcVarRowHeightConfig($xeTable, 'small', smallEl);
    calcVarRowHeightConfig($xeTable, 'mini', miniEl);
  }
  calcCellWidth($xeTable);
  autoCellWidth($xeTable);
  calcScrollbar($xeTable);
  updateStyle($xeTable);
  updateRowExpandStyle($xeTable);
  return computeScrollLoad($xeTable).then(() => {
    // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果
    calcCellWidth($xeTable);
    if (reFull) {
      autoCellWidth($xeTable);
    }
    calcScrollbar($xeTable);
    updateStyle($xeTable);
    if (reFull) {
      updateRowOffsetTop($xeTable);
    }
    updateRowExpandStyle($xeTable);
    if (reFull) {
      return computeScrollLoad($xeTable);
    }
  });
}
const handleUpdateRowGroup = ($xeTable, groupFields) => {
  const reactData = $xeTable;
  reactData.rowGroupList = groupFields ? (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(groupFields) ? groupFields : [groupFields]).map(field => {
    return {
      field
    };
  }) : [];
};
function handleeGroupSummary($xeTable, aggList) {
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const {
    mapChildrenField
  } = aggregateOpts;
  if (mapChildrenField) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastEach(aggList, aggRow => {
      let count = 0;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(aggRow[mapChildrenField], row => {
        if (row.isAggregate) {
          count += row.childCount || 0;
        } else {
          count++;
        }
      });
      aggRow.childCount = count;
    });
    if ($xeTable.handlePivotTableAggregateData) {
      $xeTable.handlePivotTableAggregateData(aggList);
    }
  }
}
function updateGroupData($xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    aggregateConfig,
    rowGroupConfig
  } = props;
  const {
    isRowGroupStatus
  } = reactData;
  const {
    tableFullGroupData
  } = internalData;
  const aggregateOpts = $xeTable.computeAggregateOpts;
  const {
    mapChildrenField
  } = aggregateOpts;
  if ((aggregateConfig || rowGroupConfig) && isRowGroupStatus) {
    const aggList = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData, row => {
      if (row.isAggregate) {
        aggList.push(row);
      }
    }, {
      children: mapChildrenField
    });
    handleeGroupSummary($xeTable, aggList);
  }
}
function handleGroupData($xeTable, list, rowGroups) {
  let fullData = list;
  let treeData = list;
  if (rowGroups) {
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const {
      rowField,
      parentField,
      childrenField,
      mapChildrenField
    } = aggregateOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField
    } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const rgItem = rowGroups[0];
    if (rgItem && rowField && parentField && childrenField && mapChildrenField) {
      fullData = [];
      treeData = [];
      const groupField = rgItem.field;
      const groupColumn = $xeTable.getColumnByField(groupField);
      const groupMaps = {};
      const aggList = [];
      const rowkey = getRowkey($xeTable);
      list.forEach(row => {
        const cellValue = groupColumn ? $xeTable.getCellLabel(row, groupColumn) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, groupField);
        const groupValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue) ? '' : cellValue;
        let childList = groupMaps[groupValue];
        if (!childList) {
          childList = [];
          groupMaps[groupValue] = childList;
        }
        if (row.isAggregate) {
          row.isAggregate = undefined;
        }
        childList.push(row);
      });
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(groupMaps, (childList, groupValue) => {
        const {
          fullData: childFullData,
          treeData: childTreeData
        } = handleGroupData($xeTable, childList, rowGroups.slice(1));
        const aggRow = {
          isAggregate: true,
          aggData: {},
          groupContent: groupValue,
          groupField,
          childCount: 0,
          [rowField]: getRowUniqueId(),
          [parentField]: null,
          [rowkey]: getRowUniqueId(),
          [childrenField]: childTreeData,
          [mapChildrenField]: childTreeData
        };
        if (checkField) {
          aggRow[checkField] = false;
        }
        if (indeterminateField) {
          aggRow[indeterminateField] = false;
        }
        aggList.push(aggRow);
        treeData.push(aggRow);
        fullData.push(aggRow);
        if (childFullData.length) {
          fullData.push(...childFullData);
        }
      });
      handleeGroupSummary($xeTable, aggList);
    }
  }
  return {
    treeData,
    fullData
  };
}
/**
 * 加载表格数据
 * @param {Array} datas 数据
 */
function loadTableData($xeTable, datas, isReset) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    keepSource,
    treeConfig,
    aggregateConfig,
    rowGroupConfig
  } = props;
  const {
    rowGroupList,
    scrollYLoad: oldScrollYLoad
  } = reactData;
  const {
    scrollYStore,
    scrollXStore,
    lastScrollLeft,
    lastScrollTop
  } = internalData;
  const rowOpts = $xeTable.computeRowOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const expandOpts = $xeTable.computeExpandOpts;
  const {
    transform
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  let treeData = [];
  let fullData = datas ? datas.slice(0) : []; // 转为响应式数据
  if (fullData.length > supportMaxRow) {
    errLog('vxe.error.errMaxRow', [supportMaxRow]);
  }
  if (treeConfig && rowGroupList.length) {
    errLog('vxe.error.noTree', ['aggregate-config']);
    return $xeTable.$nextTick();
  }
  if (rowOpts.drag && rowGroupList.length) {
    errLog('vxe.error.errConflicts', ['row-config.drag', 'aggregate-config']);
    return $xeTable.$nextTick();
  }
  let isRGroup = false;
  if (treeConfig) {
    if (transform) {
      // 树结构自动转换
      if (!treeOpts.rowField) {
        errLog('vxe.error.reqProp', ['tree-config.rowField']);
      }
      if (!treeOpts.parentField) {
        errLog('vxe.error.reqProp', ['tree-config.parentField']);
      }
      if (!childrenField) {
        errLog('vxe.error.reqProp', ['tree-config.childrenField']);
      }
      if (!treeOpts.mapChildrenField) {
        errLog('vxe.error.reqProp', ['tree-config.mapChildrenField']);
      }
      if (childrenField === treeOpts.mapChildrenField) {
        errLog('vxe.error.errConflicts', ['tree-config.childrenField', 'tree-config.mapChildrenField']);
      }
      // fullData.forEach(row => {
      //   if (row[treeOpts.children] && row[treeOpts.children].length) {
      //     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])
      //   }
      // })
      treeData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullData, {
        key: treeOpts.rowField,
        parentKey: treeOpts.parentField,
        children: childrenField,
        mapChildren: treeOpts.mapChildrenField
      });
      fullData = treeData.slice(0);
    } else {
      treeData = fullData.slice(0);
    }
  } else if ((aggregateConfig || rowGroupConfig) && rowGroupList.length) {
    const groupRest = handleGroupData($xeTable, fullData, rowGroupList);
    treeData = groupRest.treeData;
    fullData = groupRest.fullData;
    isRGroup = true;
  }
  reactData.isRowGroupStatus = isRGroup;
  scrollYStore.startIndex = 0;
  scrollYStore.endIndex = 1;
  scrollXStore.startIndex = 0;
  scrollXStore.endIndex = 1;
  internalData.cvCacheMaps = {};
  reactData.isRowLoading = true;
  reactData.scrollVMLoading = false;
  internalData.treeExpandedMaps = {};
  reactData.treeExpandedFlag++;
  internalData.rowExpandedMaps = {};
  reactData.rowExpandedFlag++;
  internalData.insertRowMaps = {};
  reactData.insertRowFlag++;
  internalData.removeRowMaps = {};
  reactData.removeRowFlag++;
  const sYLoad = updateScrollYStatus($xeTable, fullData);
  reactData.isDragColMove = false;
  reactData.isDragRowMove = false;
  // 全量数据
  internalData.tableFullData = fullData;
  internalData.tableFullTreeData = isRGroup ? [] : treeData;
  internalData.tableFullGroupData = isRGroup ? treeData : [];
  // 缓存数据
  $xeTable.cacheRowMap(isReset);
  // 原始数据
  internalData.tableSynchData = datas;
  if (isReset) {
    internalData.isResizeCellHeight = false;
  }
  // 克隆原数据，用于显示编辑状态，与编辑值做对比
  if (keepSource) {
    $xeTable.cacheSourceMap(fullData);
  }
  if ($xeTable.clearCellAreas && props.mouseConfig) {
    $xeTable.clearCellAreas();
    $xeTable.clearCopyCellArea();
  }
  $xeTable.clearMergeCells();
  $xeTable.clearMergeFooterItems();
  $xeTable.handleTableData(true);
  $xeTable.updateFooter();
  $xeTable.handleUpdateBodyMerge();
  return $xeTable.$nextTick().then(() => {
    updateHeight($xeTable);
    updateStyle($xeTable);
  }).then(() => {
    computeScrollLoad($xeTable);
  }).then(() => {
    // 是否启用了虚拟滚动
    if (sYLoad) {
      scrollYStore.endIndex = scrollYStore.visibleSize;
    }
    if (sYLoad) {
      if (reactData.expandColumn && expandOpts.mode !== 'fixed') {
        errLog('vxe.error.notConflictProp', ['column.type="expand', 'expand-config.mode="fixed"']);
      }
      // if (showOverflow) {
      //   if (!rowOpts.height) {
      //     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
      //     if (errColumn) {
      //       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
      //     }
      //   }
      // }
      if (!(props.height || props.maxHeight)) {
        errLog('vxe.error.reqProp', ['height | max-height | virtual-y-config={enabled: false}']);
      }
      // if (!props.showOverflow) {
      //   warnLog('vxe.error.reqProp', ['table.show-overflow'])
      // }
      if (props.spanMethod) {
        errLog('vxe.error.scrollErrProp', ['table.span-method']);
      }
    }
    handleReserveStatus($xeTable);
    $xeTable.checkSelectionStatus();
    return new Promise(resolve => {
      $xeTable.$nextTick().then(() => handleRecalculateLayout($xeTable, false)).then(() => {
        calcCellHeight($xeTable);
        updateRowOffsetTop($xeTable);
        return handleRecalculateLayout($xeTable, false);
      }).then(() => {
        let targetScrollLeft = lastScrollLeft;
        let targetScrollTop = lastScrollTop;
        const virtualXOpts = $xeTable.computeVirtualXOpts;
        const virtualYOpts = $xeTable.computeVirtualYOpts;
        // 是否在更新数据之后自动滚动重置滚动条
        if (virtualXOpts.scrollToLeftOnChange) {
          targetScrollLeft = 0;
        }
        if (virtualYOpts.scrollToTopOnChange) {
          targetScrollTop = 0;
        }
        reactData.isRowLoading = false;
        handleRecalculateLayout($xeTable, false);
        // 是否变更虚拟滚动
        if (oldScrollYLoad === sYLoad) {
          restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
            calcCellHeight($xeTable);
            updateRowOffsetTop($xeTable);
            resolve();
          });
        } else {
          setTimeout(() => {
            restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
              calcCellHeight($xeTable);
              updateRowOffsetTop($xeTable);
              resolve();
            });
          });
        }
      });
    });
  });
}
/**
 * 处理数据加载默认行为
 * 默认执行一次，除非被重置
 */
function handleLoadDefaults($xeTable) {
  handleDefaultSelectionChecked($xeTable);
  handleDefaultRadioChecked($xeTable);
  handleDefaultRowExpand($xeTable);
  handleDefaultTreeExpand($xeTable);
  handleDefaultMergeCells($xeTable);
  handleDefaultMergeFooterItems($xeTable);
  $xeTable.$nextTick(() => setTimeout(() => $xeTable.recalculate()));
}
/**
 * 处理初始化的默认行为
 * 只会执行一次
 */
function handleInitDefaults($xeTable) {
  handleDefaultSort($xeTable);
}
function handleTableColumn($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    scrollXLoad
  } = reactData;
  const {
    visibleColumn,
    scrollXStore,
    fullColumnIdData
  } = internalData;
  const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
  tableColumn.forEach((column, $index) => {
    const colid = column.id;
    const colRest = fullColumnIdData[colid];
    if (colRest) {
      colRest.$index = $index;
    }
  });
  reactData.tableColumn = tableColumn;
}
function handleUpdateColumn($xeTable) {
  const internalData = $xeTable;
  const columnList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(internalData.collectColumn, 'renderSortNumber');
  internalData.collectColumn = columnList;
  const tableFullColumn = getColumnList(columnList);
  internalData.tableFullColumn = tableFullColumn;
  cacheColumnMap($xeTable);
}
function loadScrollXData($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    isScrollXBig
  } = reactData;
  const {
    mergeBodyList,
    mergeFooterList,
    scrollXStore
  } = internalData;
  const {
    preloadSize,
    startIndex,
    endIndex,
    offsetSize
  } = scrollXStore;
  const {
    toVisibleIndex,
    visibleSize
  } = handleVirtualXVisible($xeTable);
  const offsetItem = {
    startIndex: Math.max(0, isScrollXBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
    endIndex: isScrollXBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + offsetSize + preloadSize
  };
  scrollXStore.visibleStartIndex = toVisibleIndex - 1;
  scrollXStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
  calculateMergerOffsetIndex(mergeBodyList.concat(mergeFooterList), offsetItem, 'col');
  const {
    startIndex: offsetStartIndex,
    endIndex: offsetEndIndex
  } = offsetItem;
  if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
    if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
      scrollXStore.startIndex = offsetStartIndex;
      scrollXStore.endIndex = offsetEndIndex;
      $xeTable.updateScrollXData();
    }
  }
  $xeTable.closeTooltip();
}
// 获取所有的列，排除分组
function getColumnList(columns) {
  const result = [];
  columns.forEach(column => {
    result.push(...(column.children && column.children.length ? getColumnList(column.children) : [column]));
  });
  return result;
}
function parseColumns($xeTable, isReset) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  // const { showOverflow } = props
  // const rowOpts = $xeTable.computeRowOpts
  const leftList = [];
  const centerList = [];
  const rightList = [];
  const {
    isGroup,
    columnStore
  } = reactData;
  const {
    collectColumn,
    tableFullColumn,
    scrollXStore,
    fullColumnIdData
  } = internalData;
  // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏
  if (isGroup) {
    const leftGroupList = [];
    const centerGroupList = [];
    const rightGroupList = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parentColumn) => {
      const isColGroup = hasChildrenList(column);
      // 如果是分组，必须按组设置固定列，不允许给子列设置固定
      if (parentColumn && parentColumn.fixed) {
        column.fixed = parentColumn.fixed;
      }
      if (parentColumn && column.fixed !== parentColumn.fixed) {
        errLog('vxe.error.groupFixed');
      }
      if (isColGroup) {
        column.visible = !!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(column.children, subColumn => hasChildrenList(subColumn) ? false : subColumn.visible);
      } else if (column.visible) {
        if (column.fixed === 'left') {
          leftList.push(column);
        } else if (column.fixed === 'right') {
          rightList.push(column);
        } else {
          centerList.push(column);
        }
      }
    });
    collectColumn.forEach(column => {
      if (column.visible) {
        if (column.fixed === 'left') {
          leftGroupList.push(column);
        } else if (column.fixed === 'right') {
          rightGroupList.push(column);
        } else {
          centerGroupList.push(column);
        }
      }
    });
    reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
  } else {
    // 重新分配列
    tableFullColumn.forEach(column => {
      if (column.visible) {
        if (column.fixed === 'left') {
          leftList.push(column);
        } else if (column.fixed === 'right') {
          rightList.push(column);
        } else {
          centerList.push(column);
        }
      }
    });
  }
  const visibleColumn = leftList.concat(centerList).concat(rightList);
  internalData.visibleColumn = visibleColumn;
  updateColumnOffsetLeft($xeTable);
  const sXLoad = updateScrollXStatus($xeTable);
  reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
  Object.assign(columnStore, {
    leftList,
    centerList,
    rightList
  });
  if (sXLoad) {
    // if (showOverflow) {
    //   if (!rowOpts.height) {
    //     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
    //     if (errColumn) {
    //       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
    //     }
    //   }
    // }
    // if (props.showHeader && !props.showHeaderOverflow) {
    //   warnLog('vxe.error.reqProp', ['show-header-overflow'])
    // }
    // if (props.showFooter && !props.showFooterOverflow) {
    //   warnLog('vxe.error.reqProp', ['show-footer-overflow'])
    // }
    if (props.spanMethod) {
      warnLog('vxe.error.scrollErrProp', ['span-method']);
    }
    if (props.footerSpanMethod) {
      warnLog('vxe.error.scrollErrProp', ['footer-span-method']);
    }
    if (isReset) {
      const {
        visibleSize
      } = handleVirtualXVisible($xeTable);
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = visibleSize;
      scrollXStore.visibleSize = visibleSize;
      scrollXStore.visibleStartIndex = 0;
      scrollXStore.visibleEndIndex = visibleSize;
    }
  }
  // 如果列被显示/隐藏，则清除合并状态
  // 如果列被设置为固定，则清除合并状态
  if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
    $xeTable.clearMergeCells();
    $xeTable.clearMergeFooterItems();
  }
  visibleColumn.forEach((column, index) => {
    const colid = column.id;
    const colRest = fullColumnIdData[colid];
    if (colRest) {
      colRest._index = index;
    }
  });
  handleTableColumn($xeTable);
  if (isReset) {
    return $xeTable.updateFooter().then(() => {
      return $xeTable.recalculate();
    }).then(() => {
      $xeTable.updateCellAreas();
      return $xeTable.recalculate();
    });
  }
  return $xeTable.updateFooter();
}
function initColumnSort($xeTable) {
  const internalData = $xeTable;
  const {
    collectColumn
  } = internalData;
  collectColumn.forEach((column, index) => {
    const sortIndex = index + 1;
    column.sortNumber = sortIndex;
    column.renderSortNumber = sortIndex;
  });
}
function handleColumn($xeTable, collectColumn) {
  const $xeToolbar = $xeTable.$refs.$xeToolbar;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const expandOpts = $xeTable.computeExpandOpts;
  internalData.collectColumn = collectColumn;
  const tableFullColumn = getColumnList(collectColumn);
  internalData.tableFullColumn = tableFullColumn;
  reactData.isColLoading = true;
  reactData.isDragColMove = false;
  initColumnSort($xeTable);
  return Promise.resolve(restoreCustomStorage($xeTable)).then(() => {
    const {
      scrollXLoad,
      scrollYLoad,
      expandColumn
    } = reactData;
    cacheColumnMap($xeTable);
    parseColumns($xeTable, true).then(() => {
      if (reactData.scrollXLoad) {
        loadScrollXData($xeTable);
      }
    });
    $xeTable.clearMergeCells();
    $xeTable.clearMergeFooterItems();
    $xeTable.handleTableData(true);
    $xeTable.handleAggregateSummaryData();
    if ((scrollXLoad || scrollYLoad) && expandColumn && expandOpts.mode !== 'fixed') {
      warnLog('vxe.error.scrollErrProp', ['column.type=expand']);
    }
    return $xeTable.$nextTick().then(() => {
      if ($xeToolbar) {
        $xeToolbar.syncUpdate({
          collectColumn: internalData.collectColumn,
          $table: $xeTable
        });
      }
      if ($xeTable.handleUpdateCustomColumn) {
        $xeTable.handleUpdateCustomColumn();
      }
      reactData.isColLoading = false;
      return $xeTable.recalculate();
    });
  });
}
/**
 * 纵向 Y 可视渲染处理
 */
function loadScrollYData($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    isAllOverflow,
    isScrollYBig
  } = reactData;
  const {
    mergeBodyList,
    scrollYStore
  } = internalData;
  const {
    preloadSize,
    startIndex,
    endIndex,
    offsetSize
  } = scrollYStore;
  const autoOffsetYSize = isAllOverflow ? offsetSize : offsetSize + 1;
  const {
    toVisibleIndex,
    visibleSize
  } = handleVirtualYVisible($xeTable);
  const offsetItem = {
    startIndex: Math.max(0, isScrollYBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
    endIndex: isScrollYBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + autoOffsetYSize + preloadSize
  };
  scrollYStore.visibleStartIndex = toVisibleIndex - 1;
  scrollYStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
  calculateMergerOffsetIndex(mergeBodyList, offsetItem, 'row');
  const {
    startIndex: offsetStartIndex,
    endIndex: offsetEndIndex
  } = offsetItem;
  if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
    if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
      scrollYStore.startIndex = offsetStartIndex;
      scrollYStore.endIndex = offsetEndIndex;
      $xeTable.updateScrollYData();
    }
  }
}
const createGetRowCacheProp = prop => {
  return function (row) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    if (row) {
      const rowid = getRowid($xeTable, row);
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        return rowRest[prop];
      }
    }
    return -1;
  };
};
const createGetColumnCacheProp = prop => {
  return function (column) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullColumnIdData
    } = internalData;
    if (column) {
      const colRest = fullColumnIdData[column.id];
      if (colRest) {
        return colRest[prop];
      }
    }
    return -1;
  };
};
function lazyScrollXData($xeTable) {
  const internalData = $xeTable;
  const {
    lxTimeout,
    lxRunTime,
    scrollXStore
  } = internalData;
  const {
    visibleSize
  } = scrollXStore;
  const fpsTime = visibleSize > 26 ? 26 : visibleSize > 16 ? 14 : 6;
  if (lxTimeout) {
    clearTimeout(lxTimeout);
  }
  if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
    internalData.lxRunTime = Date.now();
    loadScrollXData($xeTable);
  }
  internalData.lxTimeout = setTimeout(() => {
    internalData.lxTimeout = undefined;
    internalData.lxRunTime = undefined;
    loadScrollXData($xeTable);
  }, fpsTime);
}
function lazyScrollYData($xeTable) {
  const internalData = $xeTable;
  const {
    lyTimeout,
    lyRunTime,
    scrollYStore
  } = internalData;
  const {
    visibleSize
  } = scrollYStore;
  const fpsTime = visibleSize > 30 ? 32 : visibleSize > 20 ? 18 : 8;
  if (lyTimeout) {
    clearTimeout(lyTimeout);
  }
  if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
    internalData.lyRunTime = Date.now();
    loadScrollYData($xeTable);
  }
  internalData.lyTimeout = setTimeout(() => {
    internalData.lyTimeout = undefined;
    internalData.lyRunTime = undefined;
    loadScrollYData($xeTable);
  }, fpsTime);
}
function checkLastSyncScroll($xeTable, isRollX, isRollY) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    scrollXLoad,
    scrollYLoad,
    isAllOverflow
  } = reactData;
  const {
    lcsTimeout
  } = internalData;
  if (lcsTimeout) {
    clearTimeout(lcsTimeout);
  }
  internalData.lcsTimeout = setTimeout(() => {
    internalData.lcsRunTime = Date.now();
    internalData.lcsTimeout = undefined;
    internalData.intoRunScroll = false;
    internalData.inVirtualScroll = false;
    internalData.inWheelScroll = false;
    internalData.inHeaderScroll = false;
    internalData.inBodyScroll = false;
    internalData.inFooterScroll = false;
    internalData.scrollRenderType = '';
    if (!isAllOverflow) {
      calcCellHeight($xeTable);
      updateRowOffsetTop($xeTable);
    }
    if (isRollX && scrollXLoad) {
      $xeTable.updateScrollXData();
    }
    if (isRollY && scrollYLoad) {
      $xeTable.updateScrollYData().then(() => {
        if (!isAllOverflow) {
          calcCellHeight($xeTable);
          updateRowOffsetTop($xeTable);
        }
        $xeTable.updateScrollYSpace();
      });
    }
    $xeTable.updateCellAreas();
  }, 200);
}
const getWheelSpeed = lastScrollTime => {
  let multiple = 1;
  const currTime = Date.now();
  if (lastScrollTime + 25 > currTime) {
    multiple = 1.18;
  } else if (lastScrollTime + 30 > currTime) {
    multiple = 1.15;
  } else if (lastScrollTime + 40 > currTime) {
    multiple = 1.12;
  } else if (lastScrollTime + 55 > currTime) {
    multiple = 1.09;
  } else if (lastScrollTime + 75 > currTime) {
    multiple = 1.06;
  } else if (lastScrollTime + 100 > currTime) {
    multiple = 1.03;
  }
  return multiple;
};
const wheelScrollLeftTo = (scrollLeft, cb) => {
  requestAnimationFrame(() => {
    cb(scrollLeft);
  });
};
const wheelScrollTopTo = (diffNum, cb) => {
  const duration = Math.abs(diffNum);
  const startTime = performance.now();
  let countTop = 0;
  const step = timestamp => {
    let progress = (timestamp - startTime) / duration;
    if (progress > 1) {
      progress = 1;
    }
    const easedProgress = Math.pow(progress, 2);
    const offsetTop = Math.floor(diffNum * easedProgress) - countTop;
    countTop += offsetTop;
    cb(offsetTop);
    if (progress < 1) {
      requestAnimationFrame(step);
    }
  };
  requestAnimationFrame(step);
};
function updateHeight($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  internalData.customHeight = calcTableHeight($xeTable, 'height');
  internalData.customMinHeight = calcTableHeight($xeTable, 'minHeight');
  internalData.customMaxHeight = calcTableHeight($xeTable, 'maxHeight');
  // 如果启用虚拟滚动，默认高度
  if (reactData.scrollYLoad && !(internalData.customHeight || internalData.customMinHeight)) {
    internalData.customHeight = 300;
  }
}
function calcColumnAutoWidth(column, wrapperEl) {
  const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[colid="${column.id}"]`);
  let leftRightPadding = 0;
  const firstCellEl = cellElemList[0];
  if (firstCellEl && firstCellEl.parentElement) {
    const cellStyle = getComputedStyle(firstCellEl.parentElement);
    leftRightPadding = Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingLeft) + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingRight));
  }
  let colWidth = column.renderAutoWidth - leftRightPadding;
  for (let i = 0; i < cellElemList.length; i++) {
    const celEl = cellElemList[i];
    colWidth = Math.max(colWidth, celEl ? Math.ceil(celEl.scrollWidth) + 4 : 0);
  }
  return colWidth + leftRightPadding;
}
function calcCellWidth($xeTable) {
  const internalData = $xeTable;
  const autoWidthColumnList = $xeTable.computeAutoWidthColumnList;
  const {
    fullColumnIdData
  } = internalData;
  const el = $xeTable.$refs.refElem;
  if (el) {
    el.setAttribute('data-calc-col', 'Y');
    autoWidthColumnList.forEach(column => {
      const colid = column.id;
      const colRest = fullColumnIdData[colid];
      const colWidth = calcColumnAutoWidth(column, el);
      if (colRest) {
        colRest.width = Math.max(colWidth, colRest.width);
      }
      column.renderAutoWidth = colWidth;
    });
    $xeTable.analyColumnWidth();
    el.removeAttribute('data-calc-col');
  }
}
function handleUpdateColResize($xeTable, evnt, params) {
  $xeTable.analyColumnWidth();
  $xeTable.recalculate().then(() => {
    $xeTable.saveCustomStore('update:width');
    $xeTable.updateCellAreas();
    $xeTable.dispatchEvent('column-resizable-change', params, evnt);
    // 已废弃 resizable-change
    $xeTable.dispatchEvent('resizable-change', params, evnt);
    setTimeout(() => $xeTable.recalculate(true), 300);
  });
}
function handleUpdateRowResize($xeTable, evnt, params) {
  const reactData = $xeTable;
  reactData.resizeHeightFlag++;
  $xeTable.recalculate().then(() => {
    $xeTable.updateCellAreas();
    $xeTable.dispatchEvent('row-resizable-change', params, evnt);
    setTimeout(() => $xeTable.recalculate(true), 300);
  });
}
function updateColumnOffsetLeft($xeTable) {
  const internalData = $xeTable;
  const {
    visibleColumn,
    fullColumnIdData
  } = internalData;
  let offsetLeft = 0;
  for (let cIndex = 0, rLen = visibleColumn.length; cIndex < rLen; cIndex++) {
    const column = visibleColumn[cIndex];
    const colid = column.id;
    const colRest = fullColumnIdData[colid];
    if (colRest) {
      colRest.oLeft = offsetLeft;
    }
    offsetLeft += column.renderWidth;
  }
}
function updateRowOffsetTop($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    expandColumn
  } = reactData;
  const {
    afterFullData,
    fullAllDataRowIdData,
    rowExpandedMaps
  } = internalData;
  const expandOpts = $xeTable.computeExpandOpts;
  const rowOpts = $xeTable.computeRowOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  let offsetTop = 0;
  for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
    const row = afterFullData[rIndex];
    const rowid = handleGetRowId(row);
    const rowRest = fullAllDataRowIdData[rowid] || {};
    rowRest.oTop = offsetTop;
    offsetTop += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
    // 是否展开行
    if (expandColumn && rowExpandedMaps[rowid]) {
      offsetTop += rowRest.expandHeight || expandOpts.height || 0;
    }
  }
}
function updateRowExpandStyle($xeTable) {
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    expandColumn,
    scrollYLoad,
    scrollYTop,
    isScrollYBig
  } = reactData;
  const expandOpts = $xeTable.computeExpandOpts;
  const rowOpts = $xeTable.computeRowOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const {
    mode
  } = expandOpts;
  if (expandColumn && mode === 'fixed') {
    const {
      elemStore,
      fullAllDataRowIdData
    } = internalData;
    const rowExpandEl = $xeTable.$refs.refRowExpandElem;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (rowExpandEl && bodyScrollElem) {
      let isUpdateHeight = false;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowExpandEl.children, reEl => {
        const expandEl = reEl;
        const rowid = expandEl.getAttribute('rowid') || '';
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          const expandHeight = expandEl.offsetHeight + 1;
          const trEl = bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);
          let offsetTop = 0;
          if (scrollYLoad) {
            if (isScrollYBig && trEl) {
              offsetTop = trEl.offsetTop + trEl.offsetHeight;
            } else {
              offsetTop = rowRest.oTop + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
            }
          } else {
            if (trEl) {
              offsetTop = trEl.offsetTop + trEl.offsetHeight;
            }
          }
          if (isScrollYBig) {
            offsetTop += scrollYTop;
          }
          expandEl.style.top = toCssUnit(offsetTop);
          if (!isUpdateHeight) {
            if (rowRest.expandHeight !== expandHeight) {
              isUpdateHeight = true;
            }
          }
          rowRest.expandHeight = expandHeight;
        }
      });
      if (isUpdateHeight) {
        reactData.rowExpandHeightFlag++;
        $xeTable.$nextTick(() => {
          updateRowOffsetTop($xeTable);
        });
      }
    }
  }
}
function handleRowExpandScroll($xeTable) {
  const internalData = $xeTable;
  const {
    elemStore
  } = internalData;
  const rowExpandEl = $xeTable.$refs.refRowExpandElem;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (rowExpandEl && bodyScrollElem) {
    rowExpandEl.scrollTop = bodyScrollElem.scrollTop;
  }
}
const Methods = {
  callSlot(slotFunc, params, h, vNodes) {
    const $xeTable = this;
    // const slots = $xeTable.$scopedSlots
    const $xeGrid = $xeTable.$xeGrid;
    if (slotFunc) {
      if ($xeGrid) {
        return $xeGrid.callSlot(slotFunc, params, h, vNodes);
      }
      // if (XEUtils.isString(slotFunc)) {
      //   slotFunc = slots[slotFunc] || null
      // }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
        return getSlotVNs(slotFunc.call(this, params, h, vNodes));
      }
    }
    return [];
  },
  getEl() {
    const $xeTable = this;
    return $xeTable.$refs.refElem;
  },
  /**
   * 获取父容器元素
   */
  getParentElem() {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      $el
    } = this;
    return $xeGrid ? $xeGrid.$el.parentNode : $el.parentNode;
  },
  /**
   * 获取父容器的高度
   */
  getParentHeight() {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    const props = $xeTable;
    const {
      height
    } = props;
    const el = $xeTable.$refs.refElem;
    if (el) {
      const parentElem = el.parentNode;
      const parentPaddingSize = height === '100%' || height === 'auto' ? getPaddingTopBottomSize(parentElem) : 0;
      let parentWrapperHeight = 0;
      if (parentElem) {
        if ($xeGrid && hasClass(parentElem, 'vxe-grid--table-wrapper')) {
          parentWrapperHeight = $xeGrid.getParentHeight();
        } else {
          parentWrapperHeight = parentElem.clientHeight;
        }
      }
      return Math.floor(parentWrapperHeight - parentPaddingSize);
    }
    return 0;
  },
  /**
   * 获取需要排除的高度
   * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
   * 如果存在表尾合计滚动条，则需要排除滚动条高度
   */
  getExcludeHeight() {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    return $xeGrid ? $xeGrid.getExcludeHeight() : 0;
  },
  /**
   * 重置表格的一切数据状态
   */
  clearAll() {
    return clearTableAllStatus(this);
  },
  handleUpdateRowGroup(groupFields) {
    const $xeTable = this;
    handleUpdateRowGroup($xeTable, groupFields);
  },
  /**
   * 同步 data 数据（即将废弃）
   * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
   * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
   */
  syncData() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    errLog('vxe.error.delFunc', ['syncData', 'getData']);
    return $xeTable.$nextTick().then(() => {
      reactData.tableData = [];
      return $xeTable.$nextTick().then(() => loadTableData($xeTable, internalData.tableFullData, true));
    });
  },
  /**
   * 手动处理数据，用于手动排序与筛选
   * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
   */
  updateData() {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      scrollXLoad,
      scrollYLoad
    } = reactData;
    return $xeTable.handleTableData(true).then(() => {
      $xeTable.updateFooter();
      if (scrollXLoad || scrollYLoad) {
        if (scrollXLoad) {
          $xeTable.updateScrollXSpace();
        }
        if (scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return $xeTable.refreshScroll();
      }
    }).then(() => {
      $xeTable.updateCellAreas();
      return $xeTable.recalculate(true);
    }).then(() => {
      // 存在滚动行为未结束情况
      setTimeout(() => $xeTable.recalculate(), 50);
    });
  },
  handleTableData(force) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollYLoad
    } = reactData;
    const {
      scrollYStore,
      fullDataRowIdData
    } = internalData;
    let fullList = internalData.afterFullData;
    // 是否进行数据处理
    if (force) {
      // 更新数据，处理筛选和排序
      updateAfterFullData($xeTable);
      // 如果为虚拟树，将树结构拍平
      fullList = handleVirtualTreeToList($xeTable);
    }
    const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
    const visibleDataRowIdMaps = {};
    tableData.forEach((row, $index) => {
      const rowid = getRowid($xeTable, row);
      const rest = fullDataRowIdData[rowid];
      if (rest) {
        rest.$index = $index;
      }
      visibleDataRowIdMaps[rowid] = row;
    });
    reactData.tableData = tableData;
    internalData.visibleDataRowIdData = visibleDataRowIdMaps;
    return $xeTable.$nextTick();
  },
  /**
   * 加载表格数据
   * @param {Array} datas 数据
   */
  loadTableData(datas, isReset) {
    const $xeTable = this;
    return loadTableData($xeTable, datas, isReset);
  },
  /**
   * 重新加载数据，不会清空表格状态
   * @param {Array} datas 数据
   */
  loadData(datas) {
    const $xeTable = this;
    const {
      initStatus
    } = this;
    return loadTableData($xeTable, datas, false).then(() => {
      this.inited = true;
      this.initStatus = true;
      if (!initStatus) {
        handleLoadDefaults($xeTable);
      }
      return this.recalculate();
    });
  },
  /**
   * 重新加载数据，会清空表格状态
   * @param {Array} datas 数据
   */
  reloadData(datas) {
    const $xeTable = this;
    return this.clearAll().then(() => {
      this.inited = true;
      this.initStatus = true;
      return loadTableData($xeTable, datas, true);
    }).then(() => {
      handleLoadDefaults($xeTable);
      return this.recalculate();
    });
  },
  /**
   * 修改行数据
   */
  setRow(rows, record) {
    if (record) {
      let rest = rows;
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rest = [rows];
      }
      rest.forEach(item => Object.assign(item, record));
    }
    return this.$nextTick();
  },
  /**
   * 局部加载行数据并恢复到初始状态
   * 对于行数据需要局部更改的场景中可能会用到
   * @param {Row} row 行对象
   * @param {Object} record 新数据
   * @param {String} field 字段名
   */
  reloadRow(row, record, field) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      keepSource
    } = props;
    const {
      tableData
    } = reactData;
    const {
      sourceDataRowIdData
    } = internalData;
    if (keepSource) {
      if ($xeTable.isAggregateRecord(row)) {
        return $xeTable.$nextTick();
      }
      const oRow = sourceDataRowIdData[getRowid($xeTable, row)];
      if (oRow && row) {
        if (field) {
          const newValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record || row, field), true);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, newValue);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(oRow, field, newValue);
        } else {
          const rowkey = getRowkey($xeTable);
          const rowid = getRowid($xeTable, row);
          const newRecord = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(Object.assign({}, record), true);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(newRecord, rowkey, rowid);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(oRow, Object.assign(row, newRecord));
        }
      }
      reactData.tableData = tableData.slice(0);
    } else {
      errLog('vxe.error.reqProp', ['keep-source']);
    }
    return $xeTable.$nextTick();
  },
  /**
   * 加载列配置
   * 对于表格列需要重载、局部递增场景下可能会用到
   * @param {ColumnInfo} columns 列配置
   */
  loadColumn(columns) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      lastScrollLeft,
      lastScrollTop
    } = internalData;
    const collectColumn = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(columns, column => cell.createColumn($xeTable, column), {
      children: 'children'
    });
    return handleColumn($xeTable, collectColumn).then(() => {
      let targetScrollLeft = lastScrollLeft;
      let targetScrollTop = lastScrollTop;
      const virtualXOpts = $xeTable.computeVirtualXOpts;
      const virtualYOpts = $xeTable.computeVirtualYOpts;
      // 是否在更新数据之后自动滚动重置滚动条
      if (virtualXOpts.scrollToLeftOnChange) {
        targetScrollLeft = 0;
      }
      if (virtualYOpts.scrollToTopOnChange) {
        targetScrollTop = 0;
      }
      restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop);
    });
  },
  /**
   * 加载列配置并恢复到初始状态
   * 对于表格列需要重载、局部递增场景下可能会用到
   * @param {ColumnInfo} columns 列配置
   */
  reloadColumn(columns) {
    return this.clearAll().then(() => {
      return this.loadColumn(columns);
    });
  },
  handleColumn(collectColumn) {
    const $xeTable = this;
    return handleColumn($xeTable, collectColumn);
  },
  /**
   * 更新数据行的 Map
   */
  cacheRowMap(isReset) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      fullAllDataRowIdData,
      tableFullData,
      tableFullTreeData,
      tableFullGroupData,
      treeExpandedMaps
    } = internalData;
    const fullAllDataRowIdMaps = isReset ? {} : {
      ...fullAllDataRowIdData
    }; // 存在已删除数据
    const fullDataRowIdMaps = {};
    const {
      handleUpdateRowId
    } = createHandleUpdateRowId($xeTable);
    const handleRowCache = (row, index, items, currIndex, parentRow, rowid, level, seq) => {
      let rowRest = fullAllDataRowIdMaps[rowid];
      if (!rowRest) {
        rowRest = {
          row,
          rowid,
          seq,
          index: -1,
          _index: -1,
          $index: -1,
          treeIndex: index,
          items,
          parent: parentRow,
          level,
          height: 0,
          resizeHeight: 0,
          oTop: 0,
          expandHeight: 0
        };
      }
      rowRest.treeLoaded = false;
      rowRest.expandLoaded = false;
      rowRest.row = row;
      rowRest.items = items;
      rowRest.parent = parentRow;
      rowRest.level = level;
      rowRest.index = currIndex;
      rowRest.treeIndex = index;
      fullDataRowIdMaps[rowid] = rowRest;
      fullAllDataRowIdMaps[rowid] = rowRest;
    };
    if (treeConfig) {
      const treeOpts = $xeTable.computeTreeOpts;
      const {
        lazy
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, (row, index, items, path, parentRow, nodes) => {
        const rowid = handleUpdateRowId(row);
        if (treeConfig && lazy) {
          if (row[hasChildField] && row[childrenField] === undefined) {
            row[childrenField] = null;
          }
          if (treeExpandedMaps[rowid]) {
            if (!row[childrenField] || !row[childrenField].length) {
              delete treeExpandedMaps[rowid];
            }
          }
        }
        handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
      }, {
        children: childrenField
      });
    } else if (isRowGroupStatus) {
      const aggregateOpts = $xeTable.computeAggregateOpts;
      const {
        mapChildrenField
      } = aggregateOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData, (row, index, items, path, parentRow, nodes) => {
        const rowid = handleUpdateRowId(row);
        handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
      }, {
        children: mapChildrenField
      });
    } else {
      tableFullData.forEach((row, index, items) => {
        handleRowCache(row, index, items, index, null, handleUpdateRowId(row), 0, index + 1);
      });
    }
    internalData.fullDataRowIdData = fullDataRowIdMaps;
    internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
    reactData.treeExpandedFlag++;
  },
  cacheSourceMap(fullData) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const treeOpts = $xeTable.computeTreeOpts;
    const sourceData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(fullData, true);
    const {
      handleUpdateRowId
    } = createHandleUpdateRowId($xeTable);
    const sourceRowIdData = {};
    const handleSourceRow = row => {
      const rowid = handleUpdateRowId(row);
      sourceRowIdData[rowid] = row;
    };
    // 源数据缓存
    if (treeConfig) {
      const childrenField = treeOpts.children || treeOpts.childrenField;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(sourceData, handleSourceRow, {
        children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField
      });
    } else {
      sourceData.forEach(handleSourceRow);
    }
    internalData.sourceDataRowIdData = sourceRowIdData;
    internalData.tableSourceData = sourceData;
  },
  getParams() {
    const $xeTable = this;
    const props = $xeTable;
    return props.params;
  },
  loadTreeChildren(row, childRecords) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      keepSource
    } = props;
    const {
      tableSourceData,
      fullDataRowIdData,
      fullAllDataRowIdData,
      sourceDataRowIdData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      mapChildrenField
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
    const parentLevel = parentRest ? parentRest.level : 0;
    return this.createData(childRecords).then(rows => {
      if (keepSource) {
        const rowid = getRowid(this, row);
        const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableSourceData, item => rowid === getRowid(this, item), {
          children: childrenField
        });
        if (matchObj) {
          matchObj.item[childrenField] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows, true);
        }
        rows.forEach(childRow => {
          const rowid = getRowid(this, childRow);
          sourceDataRowIdData[rowid] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(childRow, true);
        });
      }
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows, (childRow, index, items, path, parentItem, nodes) => {
        const rowid = getRowid($xeTable, childRow);
        const parentRow = parentItem || parentRest.row;
        const rest = {
          row: childRow,
          rowid,
          seq: -1,
          index,
          _index: -1,
          $index: -1,
          treeIndex: -1,
          items,
          parent: parentRow,
          level: parentLevel + nodes.length,
          height: 0,
          resizeHeight: 0,
          oTop: 0,
          expandHeight: 0
        };
        fullDataRowIdData[rowid] = rest;
        fullAllDataRowIdData[rowid] = rest;
      }, {
        children: childrenField
      });
      row[childrenField] = rows;
      if (transform) {
        row[mapChildrenField] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows, false);
      }
      updateAfterDataIndex($xeTable);
      return rows;
    });
  },
  /**
   * 根据 tr 元素获取对应的 row 信息
   * @param {Element} tr 元素
   */
  getRowNode(tr) {
    const $xeTable = this;
    const internalData = $xeTable;
    if (tr) {
      const {
        fullAllDataRowIdData
      } = internalData;
      const rowid = tr.getAttribute('rowid');
      if (rowid) {
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return {
            rowid: rowRest.rowid,
            item: rowRest.row,
            index: rowRest.index,
            items: rowRest.items,
            parent: rowRest.parent
          };
        }
      }
    }
    return null;
  },
  /**
   * 根据 th/td 元素获取对应的 column 信息
   * @param {Element} cell 元素
   */
  getColumnNode(cell) {
    const $xeTable = this;
    const internalData = $xeTable;
    if (cell) {
      const {
        fullColumnIdData
      } = internalData;
      const colid = cell.getAttribute('colid');
      if (colid) {
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          return {
            colid: colRest.colid,
            item: colRest.column,
            index: colRest.index,
            items: colRest.items,
            parent: colRest.parent
          };
        }
      }
    }
    return null;
  },
  /**
   * 根据 row 获取序号
   * @param {Row} row 行对象
   */
  getRowSeq: createGetRowCacheProp('seq'),
  /**
   * 根据 row 获取相对于 data 中的索引
   * @param {Row} row 行对象
   */
  getRowIndex: createGetRowCacheProp('index'),
  /**
   * 根据 row 获取相对于当前数据中的索引
   * @param {Row} row 行对象
   */
  getVTRowIndex: createGetRowCacheProp('_index'),
  /**
   * 根据 row 获取渲染中的虚拟索引
   * @param {Row} row 行对象
   */
  getVMRowIndex: createGetRowCacheProp('$index'),
  // 在 v3 中废弃
  _getRowIndex(row) {
    warnLog('vxe.error.delFunc', ['_getRowIndex', 'getVTRowIndex']);
    return this.getVTRowIndex(row);
  },
  // 在 v3 中废弃
  $getRowIndex(row) {
    warnLog('vxe.error.delFunc', ['$getRowIndex', 'getVMRowIndex']);
    return this.getVMRowIndex(row);
  },
  /**
   * 根据 column 获取相对于 columns 中的索引
   * @param {ColumnInfo} column 列配置
   */
  getColumnIndex: createGetColumnCacheProp('index'),
  /**
   * 根据 column 获取相对于当前表格列中的索引
   * @param {ColumnInfo} column 列配置
   */
  getVTColumnIndex: createGetColumnCacheProp('_index'),
  /**
   * 根据 column 获取渲染中的虚拟索引
   * @param {ColumnInfo} column 列配置
   */
  getVMColumnIndex: createGetColumnCacheProp('$index'),
  // 在 v3 中废弃
  _getColumnIndex(column) {
    warnLog('vxe.error.delFunc', ['_getColumnIndex', 'getVTColumnIndex']);
    return this.getVTColumnIndex(column);
  },
  // 在 v3 中废弃
  $getColumnIndex(column) {
    warnLog('vxe.error.delFunc', ['$getColumnIndex', 'getVMColumnIndex']);
    return this.getVMColumnIndex(column);
  },
  /**
   * 判断是否为索引列
   * @param {ColumnInfo} column 列配置
   */
  isSeqColumn(column) {
    return column && column.type === 'seq';
  },
  /**
   * 定义行数据中的列属性，如果不存在则定义
   * @param {Row} records 行数据
   */
  defineField(records) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const expandOpts = $xeTable.computeExpandOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const radioOpts = $xeTable.computeRadioOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const rowkey = getRowkey($xeTable);
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
      records = [records || {}];
    }
    return records.map(record => {
      internalData.tableFullColumn.forEach(column => {
        const {
          field,
          editRender
        } = column;
        if (field && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(record, field)) {
          let cellValue = null;
          if (editRender) {
            const {
              defaultValue
            } = editRender;
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
              cellValue = defaultValue({
                column
              });
            } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
              cellValue = defaultValue;
            }
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, field, cellValue);
        }
      });
      const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
      otherFields.forEach(key => {
        if (key && eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record, key))) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, key, null);
        }
      });
      if (treeConfig && treeOpts.lazy && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(record[childrenField])) {
        record[childrenField] = null;
      }
      // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数
      if (eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record, rowkey))) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, rowkey, getRowUniqueId());
      }
      return record;
    });
  },
  /**
   * 创建 data 对象
   * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
   * @param {Array} records 新数据
   */
  createData(records) {
    const $xeTable = this;
    return $xeTable.$nextTick().then(() => {
      return $xeTable.defineField(records);
    });
  },
  /**
   * 创建 Row|Rows 对象
   * 对于某些特殊场景需要对数据进行手动插入时可能会用到
   * @param {Array/Object} records 新数据
   */
  createRow(records) {
    const $xeTable = this;
    const isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records);
    if (!isArr) {
      records = [records];
    }
    return $xeTable.createData(records).then(rows => isArr ? rows : rows[0]);
  },
  /**
   * 还原数据
   * 如果不传任何参数，则还原整个表格
   * 如果传 row 则还原一行
   * 如果传 rows 则还原多行
   * 如果还额外传了 field 则还原指定的单元格数据
   */
  revertData(rows, field) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      keepSource,
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData,
      fullDataRowIdData,
      tableSourceData,
      sourceDataRowIdData,
      tableFullData,
      afterFullData,
      removeRowMaps
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform
    } = treeOpts;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    if (!keepSource) {
      errLog('vxe.error.reqProp', ['keep-source']);
      return $xeTable.$nextTick();
    }
    let targetRows = rows;
    if (rows) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        targetRows = [rows];
      }
    } else {
      targetRows = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArray($xeTable.getUpdateRecords());
    }
    let reDelFlag = false;
    if (targetRows.length) {
      targetRows.forEach(item => {
        const rowid = handleGetRowId(item);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          const row = rowRest.row;
          if (!$xeTable.isInsertByRow(row)) {
            const oRow = sourceDataRowIdData[rowid];
            if (oRow && row) {
              if (field) {
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(oRow, field), true));
              } else {
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(row, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(oRow, true));
              }
              if (!fullDataRowIdData[rowid] && $xeTable.isRemoveByRow(row)) {
                if (removeRowMaps[rowid]) {
                  delete removeRowMaps[rowid];
                }
                tableFullData.unshift(row);
                afterFullData.unshift(row);
                reDelFlag = true;
              }
            }
          }
        }
      });
    }
    if (rows) {
      if (reDelFlag) {
        reactData.removeRowFlag++;
        $xeTable.updateFooter();
        $xeTable.cacheRowMap(false);
        $xeTable.handleTableData(treeConfig && transform);
        if (!(treeConfig && transform)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
      }
      return $xeTable.$nextTick().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate();
      });
    }
    return $xeTable.reloadData(tableSourceData);
  },
  /**
   * 清空单元格内容
   * 如果不创参数，则清空整个表格内容
   * 如果传 row 则清空一行内容
   * 如果传 rows 则清空多行内容
   * 如果还额外传了 field 则清空指定单元格内容
   * @param {Array/Row} rows 行数据
   * @param {String} field 字段名
   */
  clearData(rows, field) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      tableFullData,
      visibleColumn
    } = internalData;
    if (!arguments.length) {
      rows = tableFullData;
    } else if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
      rows = [rows];
    }
    if (field) {
      rows.forEach(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, null));
    } else {
      rows.forEach(row => {
        visibleColumn.forEach(column => {
          if (column.field) {
            setCellValue(row, column, null);
          }
        });
      });
    }
    return $xeTable.$nextTick();
  },
  getCellElement(row, fieldOrColumn) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      elemStore
    } = internalData;
    const column = handleFieldOrColumn($xeTable, fieldOrColumn);
    if (!column) {
      return null;
    }
    const rowid = getRowid($xeTable, row);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    let bodyElem;
    if (column) {
      if (column.fixed) {
        if (column.fixed === 'left') {
          if (leftScrollElem) {
            bodyElem = leftScrollElem;
          }
        } else {
          if (rightScrollElem) {
            bodyElem = rightScrollElem;
          }
        }
      }
      if (!bodyElem) {
        bodyElem = bodyScrollElem;
      }
      if (bodyElem) {
        return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
      }
    }
    return null;
  },
  getCellLabel(row, fieldOrColumn) {
    const $xeTable = this;
    const internalData = $xeTable;
    const column = handleFieldOrColumn(this, fieldOrColumn);
    if (!column) {
      return null;
    }
    const formatter = column.formatter;
    const cellValue = getCellValue(row, column);
    let cellLabel = cellValue;
    if (formatter) {
      let formatData;
      const {
        fullAllDataRowIdData
      } = internalData;
      const rowid = getRowid($xeTable, row);
      const colid = column.id;
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        formatData = rowRest.formatData;
        if (!formatData) {
          formatData = fullAllDataRowIdData[rowid].formatData = {};
        }
        if (rowRest && formatData[colid]) {
          if (formatData[colid].value === cellValue) {
            return formatData[colid].label;
          }
        }
      }
      const formatParams = {
        cellValue,
        row,
        rowIndex: this.getRowIndex(row),
        column,
        columnIndex: this.getColumnIndex(column)
      };
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = methods_formats.get(formatter);
        const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
        cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : '';
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = methods_formats.get(formatter[0]);
        const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
        cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : '';
      } else {
        cellLabel = formatter(formatParams);
      }
      if (formatData) {
        formatData[colid] = {
          value: cellValue,
          label: cellLabel
        };
      }
    }
    return cellLabel;
  },
  /**
   * 检查是否为临时行数据
   */
  isInsertByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const rowid = getRowid($xeTable, row);
    return !!reactData.insertRowFlag && !!internalData.insertRowMaps[rowid];
  },
  isRemoveByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const rowid = getRowid($xeTable, row);
    return !!reactData.removeRowFlag && !!internalData.removeRowMaps[rowid];
  },
  /**
   * 删除所有新增的临时数据
   */
  removeInsertRow() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      insertRowMaps
    } = internalData;
    return $xeTable.remove(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().values(insertRowMaps));
  },
  /**
   * 检查行或列数据是否发生改变
   */
  isUpdateByRow(rowOrId, field) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      keepSource
    } = props;
    const {
      tableFullColumn,
      fullDataRowIdData,
      sourceDataRowIdData
    } = internalData;
    if (keepSource) {
      const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrId) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowOrId) ? rowOrId : getRowid($xeTable, rowOrId);
      const rowRest = fullDataRowIdData[rowid];
      // 新增的数据不需要检测
      if (!rowRest) {
        return false;
      }
      const row = rowRest.row;
      const oRow = sourceDataRowIdData[rowid];
      if (oRow) {
        if (arguments.length > 1) {
          return !eqCellValue(oRow, row, field);
        }
        for (let index = 0, len = tableFullColumn.length; index < len; index++) {
          const property = tableFullColumn[index].field;
          if (property && !eqCellValue(oRow, row, property)) {
            return true;
          }
        }
      }
    }
    return false;
  },
  /**
   * 获取表格的可视列，也可以指定索引获取列
   * @param {Number} columnIndex 索引
   */
  getColumns(columnIndex) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      visibleColumn
    } = internalData;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnIndex) ? visibleColumn.slice(0) : visibleColumn[columnIndex];
  },
  /**
   * 根据列获取列的唯一主键
   */
  getColid(fieldOrColumn) {
    const $xeTable = this;
    const column = handleFieldOrColumn($xeTable, fieldOrColumn);
    return column ? column.id : null;
  },
  /**
   * 根据列的唯一主键获取列
   * @param {String} colid 列主键
   */
  getColumnById(colid) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullColumnIdData
    } = internalData;
    return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
  },
  /**
   * 根据列的字段名获取列
   * @param {String} field 字段名
   */
  getColumnByField(field) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullColumnFieldData
    } = internalData;
    return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
  },
  getParentColumn(fieldOrColumn) {
    const fullColumnIdData = this.fullColumnIdData;
    const column = handleFieldOrColumn(this, fieldOrColumn);
    return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
  },
  /**
   * 获取当前表格的列
   * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
   */
  getTableColumn() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    return {
      collectColumn: internalData.collectColumn.slice(0),
      fullColumn: internalData.tableFullColumn.slice(0),
      visibleColumn: internalData.visibleColumn.slice(0),
      tableColumn: reactData.tableColumn.slice(0)
    };
  },
  /**
   * 移动列到指定列的位置
   * @param fieldOrColumn
   * @param targetFieldOrColumn
   * @param options
   */
  moveColumnTo(fieldOrColumn, targetFieldOrColumn, options) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullColumnIdData,
      visibleColumn
    } = internalData;
    const {
      dragToChild,
      dragPos,
      isCrossDrag
    } = Object.assign({}, options);
    const dragCol = handleFieldOrColumn($xeTable, fieldOrColumn);
    let prevDragCol = null;
    const colRest = dragCol ? fullColumnIdData[dragCol.id] : null;
    let defPos = 'left';
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetFieldOrColumn)) {
      if (colRest && targetFieldOrColumn) {
        let currList = colRest.items;
        let offsetIndex = colRest._index + targetFieldOrColumn;
        if (isCrossDrag) {
          currList = visibleColumn;
          offsetIndex = colRest._index + targetFieldOrColumn;
        }
        if (offsetIndex > 0 && offsetIndex < currList.length - 1) {
          prevDragCol = currList[offsetIndex];
        }
        if (targetFieldOrColumn > 0) {
          defPos = 'right';
        }
      }
    } else {
      prevDragCol = handleFieldOrColumn($xeTable, targetFieldOrColumn);
      const targetColRest = prevDragCol ? fullColumnIdData[prevDragCol.id] : null;
      if (colRest && targetColRest) {
        if (targetColRest._index > colRest._index) {
          defPos = 'right';
        }
      }
    }
    return $xeTable.handleColDragSwapEvent(null, true, dragCol, prevDragCol, dragPos || defPos, dragToChild === true);
  },
  /**
   * 移动行到指定行的位置
   * @param rowidOrRow
   * @param targetRowidOrRow
   * @param options
   */
  moveRowTo(rowidOrRow, targetRowidOrRow, options) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData,
      afterFullData
    } = internalData;
    const {
      dragToChild,
      dragPos,
      isCrossDrag
    } = Object.assign({}, options);
    const treeOpts = $xeTable.computeTreeOpts;
    const dragRow = handleRowidOrRow($xeTable, rowidOrRow);
    let prevDragRow = null;
    let defPos = 'top';
    const rowRest = dragRow ? fullAllDataRowIdData[getRowid($xeTable, dragRow)] : null;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRowidOrRow)) {
      if (rowRest && targetRowidOrRow) {
        let currList = afterFullData;
        let offsetIndex = rowRest._index + targetRowidOrRow;
        if (treeConfig) {
          currList = rowRest.items;
          if (treeOpts.transform) {
            offsetIndex = rowRest.treeIndex + targetRowidOrRow;
            if (isCrossDrag) {
              currList = afterFullData;
              offsetIndex = rowRest._index + targetRowidOrRow;
            }
          }
        }
        if (offsetIndex >= 0 && offsetIndex <= currList.length - 1) {
          prevDragRow = currList[offsetIndex];
        }
        if (targetRowidOrRow > 0) {
          defPos = 'bottom';
        }
      }
    } else {
      prevDragRow = handleRowidOrRow($xeTable, targetRowidOrRow);
      const targetRowRest = prevDragRow ? fullAllDataRowIdData[getRowid($xeTable, prevDragRow)] : null;
      if (rowRest && targetRowRest) {
        if (targetRowRest._index > rowRest._index) {
          defPos = 'bottom';
        }
      }
    }
    return $xeTable.handleRowDragSwapEvent(null, true, dragRow, prevDragRow, dragPos || defPos, dragToChild === true);
  },
  /**
   * 获取表格的全量列
   */
  getFullColumns() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      collectColumn
    } = internalData;
    return collectColumn.slice(0);
  },
  /**
   * 获取数据，和 data 的行为一致，也可以指定索引获取数据
   */
  getData(rowIndex) {
    const tableSynchData = this.data || this.tableSynchData;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
  },
  /**
   * 用于多选行，获取已选中的数据
   */
  getCheckboxRecords(isFull) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      updateCheckboxFlag
    } = reactData;
    const {
      tableFullData,
      afterFullData,
      tableFullTreeData,
      fullDataRowIdData,
      afterFullRowMaps,
      selectCheckboxMaps
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      transform,
      mapChildrenField
    } = treeOpts;
    const {
      checkField
    } = checkboxOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    let rowList = [];
    if (updateCheckboxFlag) {
      if (checkField) {
        if (treeConfig) {
          const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? tableFullTreeData : afterFullData;
          rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(currTableData, row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField), {
            children: transform ? mapChildrenField : childrenField
          });
        } else {
          const currTableData = isFull ? tableFullData : afterFullData;
          rowList = currTableData.filter(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField));
        }
      } else {
        const currMaps = isFull || treeConfig && !transform ? fullDataRowIdData : afterFullRowMaps;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (row, rowid) => {
          if (currMaps[rowid]) {
            rowList.push(fullDataRowIdData[rowid].row);
          }
        });
      }
    }
    return rowList;
  },
  /**
   * 预编译
   * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅
   */
  updateAfterDataIndex() {
    const $xeTable = this;
    updateAfterDataIndex($xeTable);
  },
  /**
   * 只对 tree-config 有效，获取行的子级
   */
  getTreeRowChildren(rowOrRowid) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      mapChildrenField
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    if (rowOrRowid && treeConfig) {
      let rowid;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)) {
        rowid = rowOrRowid;
      } else {
        rowid = getRowid($xeTable, rowOrRowid);
      }
      if (rowid) {
        const rest = fullAllDataRowIdData[rowid];
        const row = rest ? rest.row : null;
        if (row) {
          return row[transform ? mapChildrenField : childrenField] || [];
        }
      }
    }
    return [];
  },
  /**
   * 只对 tree-config 有效，获取行的父级
   */
  getTreeParentRow(rowOrRowid) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData
    } = internalData;
    if (rowOrRowid && treeConfig) {
      let rowid;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)) {
        rowid = rowOrRowid;
      } else {
        rowid = getRowid($xeTable, rowOrRowid);
      }
      if (rowid) {
        const rest = fullAllDataRowIdData[rowid];
        return rest ? rest.parent : null;
      }
    }
    return null;
  },
  getParentRow(rowOrRowid) {
    const $xeTable = this;
    warnLog('vxe.error.delFunc', ['getParentRow', 'getTreeParentRow']);
    return $xeTable.getTreeParentRow(rowOrRowid);
  },
  /**
   * 根据行的唯一主键获取行
   * @param {String/Number} rowid 行主键
   */
  getRowById(cellValue) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue) ? '' : encodeURIComponent(cellValue);
    return fullAllDataRowIdData[rowid] ? fullAllDataRowIdData[rowid].row : null;
  },
  /**
   * 根据行获取行的唯一主键
   * @param {Row} row 行对象
   */
  getRowid(row) {
    const $xeTable = this;
    return getRowid($xeTable, row);
  },
  /**
   * 获取处理后的表格数据
   * 如果存在筛选条件，继续处理
   * 如果存在排序，继续处理
   */
  getTableData() {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      tableData,
      footerTableData
    } = reactData;
    const {
      tableFullData,
      afterFullData,
      tableFullTreeData
    } = internalData;
    return {
      fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
      visibleData: afterFullData.slice(0),
      tableData: tableData.slice(0),
      footerData: footerTableData.slice(0)
    };
  },
  /**
   * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
   */
  getFullData() {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      tableFullData,
      tableFullTreeData
    } = internalData;
    if (treeConfig) {
      const treeOpts = $xeTable.computeTreeOpts;
      const {
        transform,
        mapChildrenField,
        rowField,
        parentField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (transform) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableFullTreeData, {
          children: mapChildrenField
        }), {
          key: rowField,
          parentKey: parentField,
          children: childrenField,
          mapChildren: mapChildrenField
        });
      }
      return tableFullTreeData.slice(0);
    }
    return tableFullData.slice(0);
  },
  /**
   * 处理数据加载默认行为
   * 默认执行一次，除非被重置
   */
  handleLoadDefaults() {
    const $xeTable = this;
    handleLoadDefaults($xeTable);
  },
  /**
   * 处理初始化的默认行为
   * 只会执行一次
   */
  handleInitDefaults() {
    const $xeTable = this;
    handleInitDefaults($xeTable);
  },
  /**
   * 设置为固定列
   */
  setColumnFixed(fieldOrColumn, fixed) {
    const $xeTable = this;
    let status = false;
    const cols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
    const columnOpts = $xeTable.computeColumnOpts;
    const isMaxFixedColumn = $xeTable.computeIsMaxFixedColumn;
    for (let i = 0; i < cols.length; i++) {
      const item = cols[i];
      const column = handleFieldOrColumn($xeTable, item);
      const targetColumn = getRootColumn($xeTable, column);
      if (targetColumn && targetColumn.fixed !== fixed) {
        // 是否超过最大固定列数量
        if (!targetColumn.fixed && isMaxFixedColumn) {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              status: 'error',
              content: methods_getI18n('vxe.table.maxFixedCol', [columnOpts.maxFixedSize])
            });
          }
          return $xeTable.$nextTick();
        }
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn], column => {
          column.fixed = fixed;
          column.renderFixed = fixed;
        });
        $xeTable.saveCustomStore('update:fixed');
        if (!status) {
          status = true;
        }
      }
    }
    if (status) {
      return $xeTable.refreshColumn();
    }
    return $xeTable.$nextTick();
  },
  /**
   * 取消指定固定列
   */
  clearColumnFixed(fieldOrColumn) {
    const $xeTable = this;
    let status = false;
    const cols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
    cols.forEach(item => {
      const column = handleFieldOrColumn($xeTable, item);
      const targetColumn = getRootColumn($xeTable, column);
      if (targetColumn && targetColumn.fixed) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn], column => {
          column.fixed = null;
          column.renderFixed = null;
        });
        $xeTable.saveCustomStore('update:fixed');
        if (!status) {
          status = true;
        }
      }
    });
    if (status) {
      return $xeTable.refreshColumn();
    }
    return $xeTable.$nextTick();
  },
  /**
   * 隐藏指定列
   */
  hideColumn(fieldOrColumn) {
    const $xeTable = this;
    let status = false;
    const cols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
    cols.forEach(item => {
      const column = handleFieldOrColumn($xeTable, item);
      if (column && column.visible) {
        column.visible = false;
        if (!status) {
          status = true;
        }
      }
    });
    if (status) {
      return $xeTable.handleCustom();
    }
    return $xeTable.$nextTick();
  },
  /**
   * 显示指定列
   */
  showColumn(fieldOrColumn) {
    const $xeTable = this;
    let status = false;
    const cols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
    cols.forEach(item => {
      const column = handleFieldOrColumn($xeTable, item);
      if (column && !column.visible) {
        column.visible = true;
        if (!status) {
          status = true;
        }
      }
    });
    if (status) {
      return $xeTable.handleCustom();
    }
    return $xeTable.$nextTick();
  },
  setColumnWidth(fieldOrColumn, width) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      elemStore
    } = internalData;
    let status = false;
    const cols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
    let cWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(width);
    if (isScale(width)) {
      const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
      const bodyWidth = bodyScrollElem ? bodyScrollElem.clientWidth - 1 : 0;
      cWidth = Math.floor(cWidth * bodyWidth);
    }
    if (cWidth) {
      cols.forEach(item => {
        const column = handleFieldOrColumn($xeTable, item);
        if (column) {
          column.resizeWidth = cWidth;
          if (!status) {
            status = true;
          }
        }
      });
      if (status) {
        return $xeTable.refreshColumn().then(() => {
          return {
            status
          };
        });
      }
    }
    return $xeTable.$nextTick().then(() => {
      return {
        status
      };
    });
  },
  getColumnWidth(fieldOrColumn) {
    const column = handleFieldOrColumn(this, fieldOrColumn);
    if (column) {
      return column.renderWidth;
    }
    return 0;
  },
  /**
   * 手动重置列的显示隐藏、列宽拖动的状态；
   * 如果为 true 则重置所有状态
   * 如果已关联工具栏，则会同步更新
   */
  resetColumn(options) {
    warnLog('vxe.error.delFunc', ['resetColumn', 'resetCustom']);
    return this.resetCustom(options);
  },
  handleCustom() {
    const $xeTable = this;
    const props = $xeTable;
    const {
      mouseConfig
    } = props;
    if (mouseConfig) {
      if ($xeTable.clearSelected) {
        $xeTable.clearSelected();
      }
      if ($xeTable.clearCellAreas) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
    }
    $xeTable.analyColumnWidth();
    return $xeTable.refreshColumn(true);
  },
  /**
   * 还原自定义列操作状态
   */
  restoreCustomStorage() {
    const $xeTable = this;
    const props = $xeTable;
    const {
      customConfig
    } = props;
    const tableId = $xeTable.computeTableId;
    const customOpts = $xeTable.computeCustomOpts;
    const {
      storage,
      restoreStore
    } = customOpts;
    const isAllCustom = storage === true;
    const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
    const isCustomResizable = isAllCustom || storageOpts.resizable;
    const isCustomVisible = isAllCustom || storageOpts.visible;
    const isCustomFixed = isAllCustom || storageOpts.fixed;
    const isCustomSort = isAllCustom || storageOpts.sort;
    if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
      if (!tableId) {
        errLog('vxe.error.reqProp', ['id']);
        return;
      }
      const storeData = getCustomStorageMap(tableId);
      if (restoreStore) {
        return Promise.resolve(restoreStore({
          $table: $xeTable,
          id: tableId,
          type: 'restore',
          storeData
        })).then(storeData => {
          if (!storeData) {
            return;
          }
          return handleCustomRestore($xeTable, storeData);
        }).catch(e => e);
      } else {
        return handleCustomRestore($xeTable, storeData);
      }
    }
  },
  getCustomStoreData() {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      id
    } = props;
    const customOpts = $xeTable.computeCustomOpts;
    const {
      collectColumn
    } = internalData;
    const {
      storage,
      checkMethod
    } = customOpts;
    const isAllCustom = storage === true;
    const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
    const isCustomResizable = isAllCustom || storageOpts.resizable;
    const isCustomVisible = isAllCustom || storageOpts.visible;
    const isCustomFixed = isAllCustom || storageOpts.fixed;
    const isCustomSort = isAllCustom || storageOpts.sort;
    const resizableData = {};
    const sortData = {};
    const visibleData = {};
    const fixedData = {};
    const storeData = {
      resizableData: undefined,
      sortData: undefined,
      visibleData: undefined,
      fixedData: undefined
    };
    if (!id) {
      errLog('vxe.error.reqProp', ['id']);
      return storeData;
    }
    let hasResizable = 0;
    let hasSort = 0;
    let hasFixed = 0;
    let hasVisible = 0;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parentColumn) => {
      const colKey = column.getKey();
      if (!colKey) {
        errLog('vxe.error.reqProp', [`${column.getTitle() || column.type || ''} -> column.field=?`]);
        return;
      }
      // 只支持一级
      if (!parentColumn) {
        if (isCustomSort) {
          hasSort = 1;
          sortData[colKey] = column.renderSortNumber;
        }
        if (isCustomFixed && column.fixed !== column.defaultFixed) {
          hasFixed = 1;
          fixedData[colKey] = column.fixed;
        }
      }
      if (isCustomResizable && column.resizeWidth) {
        hasResizable = 1;
        resizableData[colKey] = column.renderWidth;
      }
      if (isCustomVisible && (!checkMethod || checkMethod({
        $table: $xeTable,
        column
      }))) {
        if (!column.visible && column.defaultVisible) {
          hasVisible = 1;
          visibleData[colKey] = false;
        } else if (column.visible && !column.defaultVisible) {
          hasVisible = 1;
          visibleData[colKey] = true;
        }
      }
    });
    if (hasResizable) {
      storeData.resizableData = resizableData;
    }
    if (hasSort) {
      storeData.sortData = sortData;
    }
    if (hasFixed) {
      storeData.fixedData = fixedData;
    }
    if (hasVisible) {
      storeData.visibleData = visibleData;
    }
    return storeData;
  },
  saveCustomStore(type) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      customConfig
    } = props;
    const tableId = $xeTable.computeTableId;
    const customOpts = $xeTable.computeCustomOpts;
    const {
      updateStore,
      storage
    } = customOpts;
    const isAllCustom = storage === true;
    const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
    const isCustomResizable = isAllCustom || storageOpts.resizable;
    const isCustomVisible = isAllCustom || storageOpts.visible;
    const isCustomFixed = isAllCustom || storageOpts.fixed;
    const isCustomSort = isAllCustom || storageOpts.sort;
    if (type !== 'reset') {
      reactData.isCustomStatus = true;
    }
    if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
      if (!tableId) {
        errLog('vxe.error.reqProp', ['id']);
        return this.$nextTick();
      }
      const storeData = type === 'reset' ? {
        resizableData: {},
        sortData: {},
        visibleData: {},
        fixedData: {}
      } : this.getCustomStoreData();
      if (updateStore) {
        return updateStore({
          $table: $xeTable,
          id: tableId,
          type,
          storeData
        });
      } else {
        setCustomStorageMap(tableId, type === 'reset' ? null : storeData);
      }
    }
    return this.$nextTick();
  },
  handleUpdateDataQueue() {
    this.upDataFlag++;
  },
  handleRefreshColumnQueue() {
    this.reColumnFlag++;
  },
  /**
   * 刷新列配置
   */
  refreshColumn(initSort) {
    const $xeTable = this;
    if (initSort) {
      handleUpdateColumn($xeTable);
    }
    return parseColumns($xeTable, true).then(() => {
      return this.refreshScroll();
    }).then(() => {
      return this.recalculate();
    });
  },
  /**
   * 指定列宽的列进行拆分
   */
  analyColumnWidth() {
    const {
      columnOpts
    } = this;
    const {
      width: defaultWidth,
      minWidth: defaultMinWidth
    } = columnOpts;
    const resizeList = [];
    const pxList = [];
    const pxMinList = [];
    const autoMinList = [];
    const scaleList = [];
    const scaleMinList = [];
    const autoList = [];
    const remainList = [];
    this.tableFullColumn.forEach(column => {
      if (defaultWidth && !column.width) {
        column.width = defaultWidth;
      }
      if (defaultMinWidth && !column.minWidth) {
        column.minWidth = defaultMinWidth;
      }
      if (column.visible) {
        if (column.resizeWidth) {
          resizeList.push(column);
        } else if (column.width === 'auto') {
          autoList.push(column);
        } else if (isPx(column.width)) {
          pxList.push(column);
        } else if (isScale(column.width)) {
          scaleList.push(column);
        } else if (isPx(column.minWidth)) {
          pxMinList.push(column);
        } else if (column.minWidth === 'auto') {
          autoMinList.push(column);
        } else if (isScale(column.minWidth)) {
          scaleMinList.push(column);
        } else {
          remainList.push(column);
        }
      }
    });
    Object.assign(this.columnStore, {
      resizeList,
      pxList,
      pxMinList,
      autoMinList,
      scaleList,
      scaleMinList,
      autoList,
      remainList
    });
  },
  handleColResizeMousedownEvent(evnt, fixedType, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    evnt.stopPropagation();
    evnt.preventDefault();
    const {
      column
    } = params;
    const {
      columnStore,
      overflowX,
      scrollbarHeight
    } = reactData;
    const {
      elemStore,
      visibleColumn
    } = internalData;
    const {
      leftList,
      rightList
    } = columnStore;
    const resizableOpts = $xeTable.computeResizableOpts;
    const osbHeight = overflowX ? scrollbarHeight : 0;
    const tableEl = $xeTable.$refs.refElem;
    const leftContainerElem = $xeTable.$refs.refLeftContainer;
    const rightContainerElem = $xeTable.$refs.refRightContainer;
    const resizeBarElem = $xeTable.$refs.refColResizeBar;
    if (!resizeBarElem) {
      return;
    }
    const isLeftFixed = fixedType === 'left';
    const isRightFixed = fixedType === 'right';
    const resizeTipElem = resizeBarElem.firstElementChild;
    const scrollbarXToTop = $xeTable.computeScrollbarXToTop;
    const {
      clientX: dragClientX
    } = evnt;
    const dragBtnElem = evnt.target;
    let resizeColumn = column;
    if (column.children && column.children.length) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children, childColumn => {
        resizeColumn = childColumn;
      });
    }
    const cell = dragBtnElem.parentNode;
    const cellParams = Object.assign(params, {
      cell
    });
    let dragLeft = 0;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (!bodyScrollElem) {
      return;
    }
    const tableRect = tableEl.getBoundingClientRect();
    const rightContainerRect = rightContainerElem ? rightContainerElem.getBoundingClientRect() : null;
    const cellRect = cell.getBoundingClientRect();
    const dragBtnRect = dragBtnElem.getBoundingClientRect();
    const dragBtnWidth = dragBtnElem.clientWidth;
    const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
    const dragPosLeft = dragBtnRect.x - tableRect.x + dragBtnOffsetWidth;
    const minInterval = getColReMinWidth(cellParams) - dragBtnOffsetWidth; // 列之间的最小间距
    const dragMinLeft = isRightFixed ? 0 : cellRect.x - tableRect.x + dragBtnWidth + minInterval;
    const dragMaxLeft = cellRect.x - tableRect.x + cell.clientWidth - minInterval;
    let fixedLeftRemainWidth = 0;
    let fixedRightRemainWidth = 0;
    if (isLeftFixed || isRightFixed) {
      let isMach = false;
      const fixedColumn = isLeftFixed ? leftList : rightList;
      for (let i = 0; i < fixedColumn.length; i++) {
        const item = fixedColumn[i];
        if (isMach) {
          fixedLeftRemainWidth += item.renderWidth;
        } else {
          isMach = item.id === resizeColumn.id;
          if (!isMach) {
            fixedRightRemainWidth += item.renderWidth;
          }
        }
      }
    }
    // 处理拖动事件
    const updateEvent = evnt => {
      evnt.stopPropagation();
      evnt.preventDefault();
      const tableHeight = tableEl.clientHeight;
      const offsetX = evnt.clientX - dragClientX;
      let left = dragPosLeft + offsetX;
      if (isLeftFixed) {
        if (rightContainerRect) {
          left = Math.min(left, rightContainerRect.x - tableRect.x - fixedLeftRemainWidth - minInterval);
        }
      } else if (isRightFixed) {
        if (leftContainerElem) {
          left = Math.max(left, leftContainerElem.clientWidth + fixedRightRemainWidth + minInterval);
        }
        left = Math.min(left, dragMaxLeft);
      }
      dragLeft = Math.max(left, dragMinLeft);
      const resizeBarLeft = Math.max(1, dragLeft);
      resizeBarElem.style.left = `${resizeBarLeft}px`;
      resizeBarElem.style.top = `${scrollbarXToTop ? osbHeight : 0}px`;
      resizeBarElem.style.height = `${scrollbarXToTop ? tableHeight - osbHeight : tableHeight}px`;
      if (resizableOpts.showDragTip && resizeTipElem) {
        resizeTipElem.textContent = methods_getI18n('vxe.table.resizeColTip', [Math.floor(resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft))]);
        const tableWrapperWidth = tableEl.clientWidth;
        const resizeBarWidth = resizeBarElem.clientWidth;
        const resizeTipWidth = resizeTipElem.clientWidth;
        const resizeTipHeight = resizeTipElem.clientHeight;
        let resizeTipLeft = -resizeTipWidth;
        if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
          resizeTipLeft = 0;
        } else if (resizeBarLeft > tableWrapperWidth) {
          resizeTipLeft += tableWrapperWidth - resizeBarLeft;
        }
        resizeTipElem.style.left = `${resizeTipLeft}px`;
        resizeTipElem.style.top = `${Math.min(tableHeight - resizeTipHeight, Math.max(0, evnt.clientY - tableRect.y - resizeTipHeight / 2))}px`;
      }
      reactData.isDragResize = true;
    };
    reactData.isDragResize = true;
    addClass(tableEl, 'col-drag--resize');
    resizeBarElem.style.display = 'block';
    document.onmousemove = updateEvent;
    document.onmouseup = function (evnt) {
      document.onmousemove = null;
      document.onmouseup = null;
      resizeBarElem.style.display = 'none';
      internalData._lastResizeTime = Date.now();
      setTimeout(() => {
        reactData.isDragResize = false;
      }, 50);
      const resizeWidth = resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
      const resizeParams = {
        ...params,
        resizeWidth,
        resizeColumn
      };
      if (resizableOpts.dragMode === 'fixed') {
        visibleColumn.forEach(item => {
          if (item.id !== resizeColumn.id) {
            if (!item.resizeWidth) {
              item.resizeWidth = item.renderWidth;
            }
          }
        });
      }
      if ($xeTable.handleColResizeCellAreaEvent) {
        $xeTable.handleColResizeCellAreaEvent(evnt, resizeParams);
      } else {
        resizeColumn.resizeWidth = resizeWidth;
        handleUpdateColResize($xeTable, evnt, resizeParams);
      }
      removeClass(tableEl, 'col-drag--resize');
    };
    updateEvent(evnt);
    if ($xeTable.closeMenu) {
      $xeTable.closeMenu();
    }
  },
  handleColResizeDblclickEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const resizableOpts = $xeTable.computeResizableOpts;
    const {
      isDblclickAutoWidth
    } = resizableOpts;
    const el = $xeTable.$refs.refElem;
    if (isDblclickAutoWidth && el) {
      evnt.stopPropagation();
      evnt.preventDefault();
      const {
        fullColumnIdData
      } = internalData;
      const {
        column
      } = params;
      let resizeColumn = column;
      if (column.children && column.children.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children, childColumn => {
          resizeColumn = childColumn;
        });
      }
      const colid = resizeColumn.id;
      const colRest = fullColumnIdData[colid];
      const dragBtnElem = evnt.target;
      const cell = dragBtnElem.parentNode;
      const cellParams = Object.assign(params, {
        cell
      });
      const colMinWidth = getColReMinWidth(cellParams);
      el.setAttribute('data-calc-col', 'Y');
      let resizeWidth = calcColumnAutoWidth(resizeColumn, el);
      el.removeAttribute('data-calc-col');
      if (colRest) {
        resizeWidth = Math.max(resizeWidth, colRest.width);
      }
      resizeWidth = Math.max(colMinWidth, resizeWidth);
      const resizeParams = {
        ...params,
        resizeWidth,
        resizeColumn
      };
      reactData.isDragResize = false;
      internalData._lastResizeTime = Date.now();
      if ($xeTable.handleColResizeDblclickCellAreaEvent) {
        $xeTable.handleColResizeDblclickCellAreaEvent(evnt, resizeParams);
      } else {
        resizeColumn.resizeWidth = resizeWidth;
        handleUpdateColResize($xeTable, evnt, resizeParams);
      }
    }
  },
  handleRowResizeMousedownEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    evnt.stopPropagation();
    evnt.preventDefault();
    const {
      row
    } = params;
    const {
      overflowX,
      scrollbarWidth,
      overflowY,
      scrollbarHeight
    } = reactData;
    const {
      elemStore,
      fullAllDataRowIdData
    } = internalData;
    const osbWidth = overflowY ? scrollbarWidth : 0;
    const osbHeight = overflowX ? scrollbarHeight : 0;
    const scrollbarYToLeft = $xeTable.computeScrollbarYToLeft;
    const resizableOpts = $xeTable.computeResizableOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const cellOpts = $xeTable.computeCellOpts;
    const tableEl = $xeTable.$refs.refElem;
    const resizeBarElem = $xeTable.$refs.refRowResizeBar;
    if (!resizeBarElem) {
      return;
    }
    const {
      clientY: dragClientY
    } = evnt;
    const resizeTipElem = resizeBarElem.firstElementChild;
    const dragBtnElem = evnt.currentTarget;
    const tdEl = dragBtnElem.parentNode;
    const trEl = tdEl.parentNode;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (!bodyScrollElem) {
      return;
    }
    const rowid = getRowid($xeTable, row);
    const rowRest = fullAllDataRowIdData[rowid];
    if (!rowRest) {
      return;
    }
    const defaultRowHeight = $xeTable.computeDefaultRowHeight;
    const currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
    const tableRect = tableEl.getBoundingClientRect();
    const trRect = trEl.getBoundingClientRect();
    const targetOffsetY = dragClientY - trRect.y - trEl.clientHeight;
    let resizeHeight = currCellHeight;
    const cellEl = tdEl.querySelector('.vxe-cell');
    let cellMinHeight = 0;
    if (cellEl) {
      const cellStyle = getComputedStyle(cellEl);
      cellMinHeight = Math.max(1, Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingTop) + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingBottom)));
    }
    const minTop = trRect.y - tableRect.y + cellMinHeight;
    // 处理拖动事件
    const updateEvent = evnt => {
      evnt.stopPropagation();
      evnt.preventDefault();
      const rtWidth = tableEl.clientWidth - osbWidth;
      const tableHeight = tableEl.clientHeight - osbHeight;
      let dragTop = evnt.clientY - tableRect.y - targetOffsetY;
      if (dragTop < minTop) {
        dragTop = minTop;
      } else {
        resizeHeight = Math.max(cellMinHeight, currCellHeight + evnt.clientY - dragClientY);
      }
      resizeBarElem.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
      resizeBarElem.style.top = `${dragTop}px`;
      resizeBarElem.style.width = `${rtWidth}px`;
      if (resizableOpts.showDragTip && resizeTipElem) {
        resizeTipElem.textContent = methods_getI18n('vxe.table.resizeRowTip', [resizeHeight]);
        const resizeTipWidth = resizeTipElem.clientWidth;
        const resizeTipHeight = resizeTipElem.clientHeight;
        let resizeBarLeft = Math.max(2, evnt.clientX - tableRect.x);
        let resizeBarTop = 0;
        if (resizeBarLeft + resizeTipWidth >= rtWidth - 2) {
          resizeBarLeft = rtWidth - resizeTipWidth - 2;
        }
        if (dragTop + resizeTipHeight >= tableHeight) {
          resizeBarTop = tableHeight - (dragTop + resizeTipHeight);
        }
        resizeTipElem.style.left = `${resizeBarLeft}px`;
        resizeTipElem.style.top = `${resizeBarTop}px`;
      }
      reactData.isDragResize = true;
    };
    reactData.isDragResize = true;
    addClass(tableEl, 'row-drag--resize');
    resizeBarElem.style.display = 'block';
    document.onmousemove = updateEvent;
    document.onmouseup = function (evnt) {
      document.onmousemove = null;
      document.onmouseup = null;
      resizeBarElem.style.display = 'none';
      internalData._lastResizeTime = Date.now();
      setTimeout(() => {
        reactData.isDragResize = false;
      }, 50);
      if (resizeHeight !== currCellHeight) {
        const resizeParams = {
          ...params,
          resizeHeight,
          resizeRow: row
        };
        internalData.isResizeCellHeight = true;
        if ($xeTable.handleRowResizeCellAreaEvent) {
          $xeTable.handleRowResizeCellAreaEvent(evnt, resizeParams);
        } else {
          rowRest.resizeHeight = resizeHeight;
          handleUpdateRowResize($xeTable, evnt, resizeParams);
          updateRowOffsetTop($xeTable);
        }
      }
      removeClass(tableEl, 'row-drag--resize');
    };
    updateEvent(evnt);
  },
  handleRowResizeDblclickEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const resizableOpts = $xeTable.computeResizableOpts;
    const {
      isDblclickAutoHeight
    } = resizableOpts;
    const el = $xeTable.$refs.refElem;
    if (isDblclickAutoHeight && el) {
      evnt.stopPropagation();
      evnt.preventDefault();
      const {
        editStore
      } = reactData;
      const {
        fullAllDataRowIdData
      } = internalData;
      const {
        actived
      } = editStore;
      const {
        row
      } = params;
      const rowid = getRowid($xeTable, row);
      const rowRest = fullAllDataRowIdData[rowid];
      if (!rowRest) {
        return;
      }
      const handleRsHeight = () => {
        const resizeHeight = calcCellAutoHeight(rowRest, el);
        const resizeParams = {
          ...params,
          resizeHeight,
          resizeRow: row
        };
        reactData.isDragResize = false;
        internalData._lastResizeTime = Date.now();
        if ($xeTable.handleRowResizeDblclickCellAreaEvent) {
          $xeTable.handleRowResizeDblclickCellAreaEvent(evnt, resizeParams);
        } else {
          rowRest.resizeHeight = resizeHeight;
          handleUpdateRowResize($xeTable, evnt, resizeParams);
        }
      };
      if (actived.row || actived.column) {
        $xeTable.clearEdit().then(handleRsHeight);
      } else {
        handleRsHeight();
      }
    }
  },
  setRowHeightConf(heightConf) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    let status = false;
    if (heightConf) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(heightConf, (height, rowid) => {
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          const rHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);
          if (rHeight) {
            rowRest.resizeHeight = rHeight;
            if (!status) {
              status = true;
            }
          }
        }
      });
      if (status) {
        internalData.isResizeCellHeight = true;
        reactData.resizeHeightFlag++;
      }
    }
    return $xeTable.$nextTick().then(() => {
      updateRowOffsetTop($xeTable);
      return {
        status
      };
    });
  },
  getRowHeightConf(isFull) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData,
      afterFullData
    } = internalData;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    const rowOpts = $xeTable.computeRowOpts;
    const cellOpts = $xeTable.computeCellOpts;
    const defaultRowHeight = $xeTable.computeDefaultRowHeight;
    const rest = {};
    afterFullData.forEach(row => {
      const rowid = handleGetRowId(row);
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        const resizeHeight = rowRest.resizeHeight;
        if (resizeHeight || isFull) {
          const currCellHeight = resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
          rest[rowid] = currCellHeight;
        }
      }
    });
    return rest;
  },
  setRowHeight(rowOrId, height) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    let status = false;
    const rows = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowOrId) ? rowOrId : [rowOrId];
    let rHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);
    if (isScale(height)) {
      const tableBody = $xeTable.$refs.refTableBody;
      const bodyElem = tableBody ? tableBody.$el : null;
      const bodyHeight = bodyElem ? bodyElem.clientHeight - 1 : 0;
      rHeight = Math.floor(rHeight * bodyHeight);
    }
    if (rHeight) {
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      rows.forEach(row => {
        const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(row) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row) ? row : handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          rowRest.resizeHeight = rHeight;
          if (!status) {
            status = true;
          }
        }
      });
      if (status) {
        internalData.isResizeCellHeight = true;
        reactData.resizeHeightFlag++;
      }
    }
    return $xeTable.$nextTick();
  },
  getRowHeight(rowOrId) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    const rowOpts = $xeTable.computeRowOpts;
    const cellOpts = $xeTable.computeCellOpts;
    const defaultRowHeight = $xeTable.computeDefaultRowHeight;
    const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrId) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowOrId) ? rowOrId : getRowid($xeTable, rowOrId);
    const rowRest = fullAllDataRowIdData[rowid];
    if (rowRest) {
      return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
    }
    return 0;
  },
  /**
   * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
   */
  refreshScroll() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      elemStore,
      lastScrollLeft,
      lastScrollTop
    } = internalData;
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    return new Promise(resolve => {
      // 还原滚动条位置
      if (lastScrollLeft || lastScrollTop) {
        return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then(() => {
          // 存在滚动行为未结束情况
          setTimeout(resolve, 10);
        });
      }
      internalData.intoRunScroll = true;
      // 重置
      setScrollTop(yHandleEl, lastScrollTop);
      setScrollTop(bodyScrollElem, lastScrollTop);
      setScrollTop(leftScrollElem, lastScrollTop);
      setScrollTop(rightScrollElem, lastScrollTop);
      setScrollLeft(xHandleEl, lastScrollLeft);
      setScrollLeft(bodyScrollElem, lastScrollLeft);
      setScrollLeft(headerScrollElem, lastScrollLeft);
      setScrollLeft(footerScrollElem, lastScrollLeft);
      // 存在滚动行为未结束情况
      setTimeout(() => {
        internalData.intoRunScroll = false;
        resolve();
      }, 10);
    });
  },
  /**
   * 重新渲染布局
   * 刷新布局
   */
  recalculate(reFull) {
    const $xeTable = this;
    const internalData = $xeTable;
    return new Promise(resolve => {
      const {
        rceTimeout,
        rceRunTime
      } = internalData;
      const resizeOpts = $xeTable.computeResizeOpts;
      const refreshDelay = resizeOpts.refreshDelay || 20;
      const el = $xeTable.$refs.refElem;
      if (el && el.clientWidth) {
        autoCellWidth($xeTable);
        updateRowExpandStyle($xeTable);
      }
      if (rceTimeout) {
        clearTimeout(rceTimeout);
        if (rceRunTime && rceRunTime + (refreshDelay - 5) < Date.now()) {
          resolve(handleRecalculateLayout($xeTable, !!reFull));
        } else {
          $xeTable.$nextTick(() => {
            resolve();
          });
        }
      } else {
        resolve(handleRecalculateLayout($xeTable, !!reFull));
      }
      internalData.rceTimeout = setTimeout(() => {
        internalData.rceTimeout = undefined;
        handleRecalculateLayout($xeTable, !!reFull);
      }, refreshDelay);
    });
  },
  updateStyle() {
    const $xeTable = this;
    return updateStyle($xeTable);
  },
  /**
   * 处理固定列的显示状态
   */
  checkScrolling() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      elemStore
    } = internalData;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const leftContainerElem = $xeTable.$refs.refLeftContainer;
    const rightContainerElem = $xeTable.$refs.refRightContainer;
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const bodtTargetEl = xHandleEl || bodyScrollElem;
    if (bodtTargetEl) {
      if (leftContainerElem) {
        if (bodtTargetEl.scrollLeft > 0) {
          addClass(leftContainerElem, 'scrolling--middle');
        } else {
          removeClass(leftContainerElem, 'scrolling--middle');
        }
      }
      if (rightContainerElem) {
        if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
          addClass(rightContainerElem, 'scrolling--middle');
        } else {
          removeClass(rightContainerElem, 'scrolling--middle');
        }
      }
    }
  },
  preventEvent(evnt, type, args, next, end) {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    let evntList = methods_interceptor.get(type);
    // 兼容老版本
    if (!evntList.length && type === 'event.clearEdit') {
      evntList = methods_interceptor.get('event.clearActived');
      if (evntList.length) {
        warnLog('vxe.error.delEvent', ['event.clearActived', 'event.clearEdit']);
      }
    }
    // 兼容老版本
    let rest = null;
    let isStop = false;
    for (let i = 0; i < evntList.length; i++) {
      const func = evntList[i];
      const fnRest = func(Object.assign({
        $grid: $xeGrid,
        $table: $xeTable,
        $event: evnt
      }, args));
      if (fnRest === false) {
        isStop = true;
        break;
      } else if (fnRest && fnRest.status === false) {
        rest = fnRest.result;
        isStop = true;
        break;
      }
    }
    if (!isStop) {
      if (next) {
        rest = next();
      }
    }
    if (end) {
      end();
    }
    return rest;
  },
  /**
   * 全局按下事件处理
   */
  handleGlobalMousedownEvent(evnt) {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      $el,
      $refs,
      $toolbar,
      mouseConfig,
      editStore,
      ctxMenuStore,
      editRules,
      editOpts,
      validOpts,
      areaOpts,
      filterStore,
      customStore,
      getRowNode
    } = this;
    const {
      actived
    } = editStore;
    const {
      customWrapper,
      refValidTooltip
    } = $refs;
    const tableFilter = $refs.refTableFilter;
    const tableMenu = $refs.refTableMenu;
    // 筛选
    if (tableFilter) {
      if (getEventTargetNode(evnt, $el, 'vxe-cell--filter').flag) {
        // 如果点击了筛选按钮
      } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        // 如果点击筛选容器
      } else {
        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
          this.preventEvent(evnt, 'event.clearFilter', filterStore.args, this.closeFilter);
        }
      }
    }
    // 自定义列
    if (customWrapper) {
      if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, 'vxe-toolbar-custom-target').flag) {
        // 如果点击了自定义列按钮
      } else if (getEventTargetNode(evnt, customWrapper.$el).flag) {
        // 如果点击自定义列容器
      } else {
        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
          this.preventEvent(evnt, 'event.clearCustom', {}, () => this.closeCustom());
        }
      }
    }
    // 如果已激活了编辑状态
    if (actived.row) {
      if (!(editOpts.autoClear === false)) {
        // 如果是激活状态，点击了单元格之外
        const cell = actived.args.cell;
        if (!cell || !getEventTargetNode(evnt, cell).flag) {
          if (refValidTooltip && getEventTargetNode(evnt, refValidTooltip.$el).flag) {
            // 如果是激活状态，且点击了校验提示框
          } else if (!this.lastCallTime || this.lastCallTime + 50 < Date.now()) {
            if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
              // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭
              this.preventEvent(evnt, 'event.clearEdit', actived.args, () => {
                let isClear;
                if (editOpts.mode === 'row') {
                  const rowNode = getEventTargetNode(evnt, $el, 'vxe-body--row');
                  // row 方式，如果点击了不同行
                  isClear = rowNode.flag ? getRowNode(rowNode.targetElem).item !== actived.args.row : false;
                } else {
                  // cell 方式，如果是非编辑列
                  isClear = !getEventTargetNode(evnt, $el, 'col--edit').flag;
                }
                // 如果点击表头行，则清除激活状态
                if (!isClear) {
                  isClear = getEventTargetNode(evnt, $el, 'vxe-header--row').flag;
                }
                // 如果点击表尾行，则清除激活状态
                if (!isClear) {
                  isClear = getEventTargetNode(evnt, $el, 'vxe-footer--row').flag;
                }
                // 如果固定了高度且点击了行之外的空白处，则清除激活状态
                if (!isClear && this.height && !this.overflowY) {
                  const bodyWrapperElem = evnt.target;
                  if (hasClass(bodyWrapperElem, 'vxe-table--body-wrapper')) {
                    isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                  }
                }
                if (isClear ||
                // 如果点击了当前表格之外
                !getEventTargetNode(evnt, $el).flag) {
                  setTimeout(() => {
                    this.handleClearEdit(evnt).then(() => {
                      // 如果存在校验，点击了表格之外则清除
                      if (!this.isActivated && editRules && validOpts.autoClear) {
                        this.validErrorMaps = {};
                      }
                    });
                  });
                }
              });
            }
          }
        }
      }
    } else if (mouseConfig) {
      if (!getEventTargetNode(evnt, $el).flag && !($xeGrid && getEventTargetNode(evnt, $xeGrid.$el).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.$el).flag) && !($toolbar && getEventTargetNode(evnt, $toolbar.$el).flag)) {
        if (this.clearSelected) {
          this.clearSelected();
        }
        if (areaOpts.autoClear) {
          if (this.getCellAreas) {
            const cellAreas = this.getCellAreas();
            if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, 'vxe-table--ignore-areas-clear').flag) {
              this.preventEvent(evnt, 'event.clearAreas', {}, () => {
                this.clearCellAreas();
                this.clearCopyCellArea();
                this.emitEvent('clear-cell-area-selection', {
                  cellAreas
                }, evnt);
              });
            }
          }
        }
      }
    }
    // 如果配置了快捷菜单且，点击了其他地方则关闭
    if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.$el).flag) {
      this.closeMenu();
    }
    const isActivated = getEventTargetNode(evnt, ($xeGrid || this).$el).flag;
    // 如果存在校验，点击了表格之外则清除
    if (!isActivated && editRules && validOpts.autoClear) {
      this.validErrorMaps = {};
    }
    // 最后激活的表格
    this.isActivated = isActivated;
  },
  /**
   * 窗口失焦事件处理
   */
  handleGlobalBlurEvent() {
    this.closeFilter();
    this.closeMenu();
  },
  /**
   * 全局滚动事件
   */
  handleGlobalMousewheelEvent() {
    this.closeTooltip();
    this.closeMenu();
  },
  /**
   * 表格键盘事件
   */
  keydownEvent(evnt) {
    const {
      filterStore,
      ctxMenuStore,
      editStore,
      keyboardConfig,
      mouseConfig,
      mouseOpts,
      keyboardOpts
    } = this;
    const {
      actived
    } = editStore;
    const {
      keyCode
    } = evnt;
    const isEsc = keyCode === 27;
    if (isEsc) {
      this.preventEvent(evnt, 'event.keydown', null, () => {
        this.emitEvent('keydown-start', {}, evnt);
        if (keyboardConfig && mouseConfig && mouseOpts.area && this.handleKeyboardCellAreaEvent) {
          this.handleKeyboardCellAreaEvent(evnt);
        } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
          evnt.stopPropagation();
          // 如果按下了 Esc 键，关闭快捷菜单、筛选
          this.closeFilter();
          this.closeMenu();
          if (keyboardConfig && keyboardOpts.isEsc) {
            // 如果是激活编辑状态，则取消编辑
            if (actived.row) {
              const params = actived.args;
              this.handleClearEdit(evnt);
              // 如果配置了选中功能，则为选中状态
              if (mouseConfig && mouseOpts.selected) {
                this.$nextTick(() => this.handleSelected(params, evnt));
              }
            }
          }
        }
        this.emitEvent('keydown', {}, evnt);
        this.emitEvent('keydown-end', {}, evnt);
      });
    }
  },
  /**
   * 全局键盘事件
   */
  handleGlobalKeydownEvent(evnt) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const reactData = $xeTable;
    const $xeGrid = $xeTable.$xeGrid;
    // 该行为只对当前激活的表格有效
    if (internalData.isActivated) {
      $xeTable.preventEvent(evnt, 'event.keydown', null, () => {
        const {
          mouseConfig,
          keyboardConfig,
          treeConfig,
          editConfig,
          highlightCurrentRow,
          highlightCurrentColumn
        } = props;
        const {
          ctxMenuStore,
          editStore,
          currentRow
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const isMenu = $xeTable.computeIsMenu;
        const bodyMenu = $xeTable.computeBodyMenu;
        const keyboardOpts = $xeTable.computeKeyboardOpts;
        const mouseOpts = $xeTable.computeMouseOpts;
        const editOpts = $xeTable.computeEditOpts;
        const treeOpts = $xeTable.computeTreeOpts;
        const menuList = $xeTable.computeMenuList;
        const rowOpts = $xeTable.computeRowOpts;
        const columnOpts = $xeTable.computeColumnOpts;
        const {
          selected,
          actived
        } = editStore;
        const {
          keyCode
        } = evnt;
        const hasBackspaceKey = keyCode === 8;
        const isTab = keyCode === 9;
        const isEnter = keyCode === 13;
        const isEsc = keyCode === 27;
        const isSpacebar = keyCode === 32;
        const isLeftArrow = keyCode === 37;
        const isUpArrow = keyCode === 38;
        const isRightArrow = keyCode === 39;
        const isDwArrow = keyCode === 40;
        const hasDeleteKey = keyCode === 46;
        const isF2 = keyCode === 113;
        const isContextMenu = keyCode === 93;
        const isControlKey = hasControlKey(evnt);
        const hasShiftKey = evnt.shiftKey;
        const hasAltKey = evnt.altKey;
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
        const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        if (operCtxMenu) {
          // 如果配置了右键菜单; 支持方向键操作、回车
          evnt.preventDefault();
          if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
            $xeTable.moveCtxMenu(evnt, ctxMenuStore, 'selectChild', isLeftArrow, false, ctxMenuStore.selected.children);
          } else {
            $xeTable.moveCtxMenu(evnt, ctxMenuStore, 'selected', isRightArrow, true, menuList);
          }
        } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
          $xeTable.handleKeyboardCellAreaEvent(evnt);
        } else if (isEsc) {
          // 如果按下了 Esc 键，关闭快捷菜单、筛选
          if ($xeTable.closeMenu) {
            $xeTable.closeMenu();
          }
          $xeTable.closeFilter();
          if (keyboardConfig && keyboardOpts.isEsc) {
            // 如果是激活编辑状态，则取消编辑
            if (actived.row) {
              const params = actived.args;
              $xeTable.handleClearEdit(evnt);
              // 如果配置了选中功能，则为选中状态
              if (mouseOpts.selected) {
                $xeTable.$nextTick(() => $xeTable.handleSelected(params, evnt));
              }
            }
          }
        } else if (keyboardConfig && isSpacebar && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'radio')) {
          // 空格键支持选中复选框
          evnt.preventDefault();
          if (selected.column.type === 'checkbox') {
            $xeTable.handleToggleCheckRowEvent(evnt, selected.args);
          } else {
            $xeTable.triggerRadioRowEvent(evnt, selected.args);
          }
        } else if (isF2 && isEnableConf(editConfig)) {
          if (!isEditStatus) {
            // 如果按下了 F2 键
            if (selected.row && selected.column) {
              evnt.stopPropagation();
              evnt.preventDefault();
              $xeTable.handleEdit(selected.args, evnt);
            }
          }
        } else if (isContextMenu) {
          // 如果按下上下文键
          internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
          clearTimeout(internalData.keyCtxTimeout);
          internalData.keyCtxTimeout = setTimeout(() => {
            internalData._keyCtx = false;
          }, 1000);
        } else if (isEnter && !hasAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
          const {
            isLastEnterAppendRow,
            beforeEnterMethod,
            enterMethod
          } = keyboardOpts;
          // 退出选中
          if (isControlKey) {
            // 如果是激活编辑状态，则取消编辑
            if (actived.row) {
              const params = actived.args;
              $xeTable.handleClearEdit(evnt);
              // 如果配置了选中功能，则为选中状态
              if (mouseConfig && mouseOpts.selected) {
                $xeTable.$nextTick(() => $xeTable.handleSelected(params, evnt));
              }
            }
          } else {
            // 如果是激活状态，退则出到上一行/下一行
            if (selected.row || actived.row) {
              const activeParams = selected.row ? selected.args : actived.args;
              if (hasShiftKey) {
                if (keyboardOpts.enterToTab) {
                  $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                } else {
                  $xeTable.moveEnterSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                }
              } else {
                if (keyboardOpts.enterToTab) {
                  $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                } else {
                  const activeRow = selected.row || actived.row;
                  const activeColumn = selected.column || actived.column;
                  const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                  const etrParams = {
                    row: activeRow,
                    rowIndex: $xeTable.getRowIndex(activeRow),
                    $rowIndex: $xeTable.getVMRowIndex(activeRow),
                    _rowIndex,
                    column: activeColumn,
                    columnIndex: $xeTable.getColumnIndex(activeColumn),
                    $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                    _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                    $table: $xeTable
                  };
                  if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                    // 最后一行按下回车键，自动追加一行
                    if (isLastEnterAppendRow) {
                      if (_rowIndex >= afterFullData.length - 1) {
                        $xeTable.insertAt({}, -1).then(({
                          row: newRow
                        }) => {
                          $xeTable.scrollToRow(newRow, selected.column);
                          $xeTable.handleSelected({
                            ...activeParams,
                            row: newRow
                          }, evnt);
                        });
                        $xeTable.dispatchEvent('enter-append-row', etrParams, evnt);
                        return;
                      }
                    }
                    $xeTable.moveEnterSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                    if (enterMethod) {
                      enterMethod(etrParams);
                    }
                  }
                }
              }
            } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
              // 如果是树形表格当前行回车移动到子节点
              const childrens = currentRow[childrenField];
              if (childrens && childrens.length) {
                evnt.preventDefault();
                const targetRow = childrens[0];
                const params = {
                  $table: $xeTable,
                  row: targetRow,
                  rowIndex: $xeTable.getRowIndex(targetRow),
                  $rowIndex: $xeTable.getVMRowIndex(targetRow)
                };
                $xeTable.setTreeExpand(currentRow, true).then(() => $xeTable.scrollToRow(targetRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
              }
            }
          }
        } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
          if (!isEditStatus) {
            // 如果按下了方向键
            if (mouseOpts.selected && selected.row && selected.column) {
              $xeTable.moveArrowSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
            } else {
              // 当前行按键上下移动
              if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
              // 当前行按键左右移动
              if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
                $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
              }
            }
          }
        } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
          // 如果按下了 Tab 键切换
          if (selected.row || selected.column) {
            $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
          } else if (actived.row || actived.column) {
            $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
          }
        } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
          // 如果是删除键
          if (!isEditStatus) {
            const {
              delMethod
            } = keyboardOpts;
            const params = {
              row: selected.row,
              rowIndex: $xeTable.getRowIndex(selected.row),
              column: selected.column,
              columnIndex: $xeTable.getColumnIndex(selected.column),
              $table: $xeTable,
              $grid: $xeGrid
            };
            // 是否被禁用
            if (!beforeEditMethod || beforeEditMethod(params)) {
              if (delMethod) {
                delMethod(params);
              } else {
                setCellValue(selected.row, selected.column, null);
              }
              // 如果按下 del 键，更新表尾数据
              $xeTable.updateFooter();
              $xeTable.dispatchEvent('cell-delete-value', params, evnt);
            }
          }
        } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
          if (!isEditStatus) {
            const {
              editMode,
              backMethod
            } = keyboardOpts;
            // 如果是删除键
            if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
              const params = {
                row: selected.row,
                rowIndex: $xeTable.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: $xeTable.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              // 是否被禁用
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (backMethod) {
                  backMethod(params);
                } else {
                  // 追加方式与覆盖式
                  if (editMode !== 'insert') {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
                $xeTable.dispatchEvent('cell-backspace-value', params, evnt);
              }
            }
          }
        } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
          // 如果树形表格回退键关闭当前行返回父节点
          const {
            parent: parentRow
          } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(internalData.afterTreeFullData, item => item === currentRow, {
            children: childrenField
          });
          if (parentRow) {
            evnt.preventDefault();
            const params = {
              row: parentRow,
              rowIndex: $xeTable.getRowIndex(parentRow),
              $rowIndex: $xeTable.getVMRowIndex(parentRow),
              $table: $xeTable,
              $grid: $xeGrid
            };
            $xeTable.setTreeExpand(parentRow, false).then(() => $xeTable.scrollToRow(parentRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
          }
        } else if (keyboardConfig && keyboardOpts.isEdit && !isControlKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
          const {
            editMethod
          } = keyboardOpts;
          // 启用编辑后，空格键功能将失效
          // if (isSpacebar) {
          //   evnt.preventDefault()
          // }
          // 如果是按下非功能键之外允许直接编辑
          if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
            const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
            const params = {
              row: selected.row,
              rowIndex: $xeTable.getRowIndex(selected.row),
              column: selected.column,
              columnIndex: $xeTable.getColumnIndex(selected.column),
              $table: $xeTable,
              $grid: $xeGrid
            };
            if (!beforeEditMethod || beforeEditMethod(params)) {
              if (editMethod) {
                editMethod(params);
              } else {
                setCellValue(selected.row, selected.column, null);
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          }
        }
        $xeTable.dispatchEvent('keydown', {}, evnt);
      });
    }
  },
  handleGlobalPasteEvent(evnt) {
    const {
      isActivated,
      keyboardConfig,
      keyboardOpts,
      mouseConfig,
      mouseOpts,
      editStore,
      filterStore
    } = this;
    const {
      actived
    } = editStore;
    if (isActivated && !filterStore.visible) {
      if (!(actived.row || actived.column)) {
        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handlePasteCellAreaEvent) {
          this.handlePasteCellAreaEvent(evnt);
        }
      }
      this.emitEvent('paste', {}, evnt);
    }
  },
  handleGlobalCopyEvent(evnt) {
    const {
      isActivated,
      keyboardConfig,
      keyboardOpts,
      mouseConfig,
      mouseOpts,
      editStore,
      filterStore
    } = this;
    const {
      actived
    } = editStore;
    if (isActivated && !filterStore.visible) {
      if (!(actived.row || actived.column)) {
        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handleCopyCellAreaEvent) {
          this.handleCopyCellAreaEvent(evnt);
        }
      }
      this.emitEvent('copy', {}, evnt);
    }
  },
  handleGlobalCutEvent(evnt) {
    const {
      isActivated,
      keyboardConfig,
      keyboardOpts,
      mouseConfig,
      mouseOpts,
      editStore,
      filterStore
    } = this;
    const {
      actived
    } = editStore;
    if (isActivated && !filterStore.visible) {
      if (!(actived.row || actived.column)) {
        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handleCutCellAreaEvent) {
          this.handleCutCellAreaEvent(evnt);
        }
      }
      this.emitEvent('cut', {}, evnt);
    }
  },
  handleGlobalResizeEvent() {
    this.closeMenu();
    this.updateCellAreas();
    this.recalculate(true);
  },
  /**
   * 处理合并
   */
  handleUpdateBodyMerge() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      mergeBodyList
    } = internalData;
    internalData.mergeBodyCellMaps = buildMergeData(mergeBodyList);
    reactData.mergeBodyFlag++;
  },
  handleUpdateFooterMerge() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      mergeFooterList
    } = internalData;
    internalData.mergeFooterCellMaps = buildMergeData(mergeFooterList);
    reactData.mergeFootFlag++;
  },
  handleAggregateSummaryData() {
    const $xeTable = this;
    return updateGroupData($xeTable);
  },
  handleTargetLeaveEvent() {
    const $xeTable = this;
    const internalData = $xeTable;
    const tooltipOpts = $xeTable.computeTooltipOpts;
    let $tooltip = $xeTable.$refs.refTooltip;
    if ($tooltip && $tooltip.setActived) {
      $tooltip.setActived(false);
    }
    if (tooltipOpts.enterable) {
      internalData.tooltipTimeout = setTimeout(() => {
        $tooltip = $xeTable.$refs.refTooltip;
        if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
          $xeTable.closeTooltip();
        }
      }, tooltipOpts.leaveDelay);
    } else {
      $xeTable.closeTooltip();
    }
  },
  triggerHeaderTitleEvent(evnt, iconParams, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const tipContent = iconParams.content || iconParams.message;
    if (tipContent) {
      const {
        tooltipStore
      } = reactData;
      const {
        column
      } = params;
      const content = getFuncText(tipContent);
      handleTargetEnterEvent($xeTable, true);
      tooltipStore.row = null;
      tooltipStore.column = column;
      tooltipStore.visible = true;
      tooltipStore.currOpts = iconParams;
      $xeTable.$nextTick(() => {
        const $tooltip = $xeTable.$refs.refTooltip;
        if ($tooltip && $tooltip.open) {
          $tooltip.open(evnt.currentTarget, content);
        }
      });
    }
  },
  /**
   * 触发表头 tooltip 事件
   */
  triggerHeaderTooltipEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      tooltipStore
    } = reactData;
    const {
      column
    } = params;
    handleTargetEnterEvent($xeTable, true);
    const titleElem = evnt.currentTarget;
    if (!titleElem) {
      return;
    }
    const cWrapperEl = titleElem.parentElement;
    if (!cWrapperEl) {
      return;
    }
    const cellEl = cWrapperEl.parentElement;
    if (!cellEl) {
      return;
    }
    const thEl = cellEl.parentElement;
    if (!thEl) {
      return;
    }
    if (tooltipStore.column !== column || !tooltipStore.visible) {
      const ctEl = thEl.querySelector('.vxe-cell--title');
      handleTooltip($xeTable, evnt, thEl, (hasClass(thEl, 'col--ellipsis') ? ctEl : cWrapperEl) || cWrapperEl, ctEl || cellEl, params);
    }
  },
  /**
   * 触发单元格 tooltip 事件
   */
  triggerBodyTooltipEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      editConfig
    } = props;
    const {
      editStore
    } = reactData;
    const {
      tooltipStore
    } = reactData;
    const editOpts = $xeTable.computeEditOpts;
    const {
      actived
    } = editStore;
    const {
      row,
      column
    } = params;
    const tdEl = evnt.currentTarget;
    handleTargetEnterEvent($xeTable, tooltipStore.column !== column || tooltipStore.row !== row);
    // 单元格处于编辑状态时不触发提示框
    if (column.editRender && isEnableConf(editConfig)) {
      // 如果是行编辑模式
      if (editOpts.mode === 'row' && actived.row === row) {
        return;
      }
      // 如果是单元格编辑模式
      if (actived.row === row && actived.column === column) {
        return;
      }
    }
    if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
      const ctEl = tdEl.querySelector('.vxe-cell--wrapper');
      let ovEl = null;
      let tipEl = tdEl.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');
      if (column.treeNode) {
        ovEl = tdEl.querySelector('.vxe-tree-cell');
      }
      if (!tipEl) {
        tipEl = ctEl;
      }
      handleTooltip($xeTable, evnt, tdEl, ovEl || ctEl, tipEl, params);
    }
  },
  /**
   * 触发表尾 tooltip 事件
   */
  triggerFooterTooltipEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      column
    } = params;
    const {
      tooltipStore
    } = reactData;
    const tdEl = evnt.currentTarget;
    handleTargetEnterEvent($xeTable, tooltipStore.column !== column || !!tooltipStore.row);
    if (tooltipStore.column !== column || !tooltipStore.visible) {
      const ctEl = tdEl.querySelector('.vxe-cell--wrapper');
      let ovEl = null;
      let tipEl = tdEl.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');
      if (column.type === 'html') {
        ovEl = tdEl.querySelector('.vxe-cell--html');
      }
      if (!tipEl) {
        tipEl = ctEl;
      }
      handleTooltip($xeTable, evnt, tdEl, ovEl || ctEl, tipEl, params);
    }
  },
  openTooltip(target, content) {
    const {
      $refs
    } = this;
    const commTip = $refs.refCommTooltip;
    if (commTip) {
      return commTip.open(target, content);
    }
    return this.$nextTick();
  },
  /**
   * 关闭 tooltip
   */
  closeTooltip() {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      tooltipStore
    } = reactData;
    const tooltip = $xeTable.$refs.refTooltip;
    const commTip = $xeTable.$refs.refCommTooltip;
    if (tooltipStore.visible) {
      Object.assign(tooltipStore, {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: {}
      });
      if (tooltip) {
        tooltip.close();
      }
    }
    if (commTip) {
      commTip.close();
    }
    return this.$nextTick();
  },
  /**
   * 判断列头复选框是否被选中
   */
  isAllCheckboxChecked() {
    return this.isAllSelected;
  },
  /**
   * 判断列头复选框是否被半选
   */
  isAllCheckboxIndeterminate() {
    return !this.isAllSelected && this.isIndeterminate;
  },
  isCheckboxIndeterminate() {
    warnLog('vxe.error.delFunc', ['isCheckboxIndeterminate', 'isAllCheckboxIndeterminate']);
    return this.isAllCheckboxIndeterminate();
  },
  /**
   * 获取复选框半选状态的行数据
   */
  getCheckboxIndeterminateRecords(isFull) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullDataRowIdData,
      treeIndeterminateRowMaps
    } = internalData;
    if (treeConfig) {
      const fullRest = [];
      const defRest = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeIndeterminateRowMaps, (item, rowid) => {
        if (item) {
          fullRest.push(item);
          if (fullDataRowIdData[rowid]) {
            defRest.push(item);
          }
        }
      });
      if (isFull) {
        return fullRest;
      }
      return defRest;
    }
    return [];
  },
  handleCheckedCheckboxRow(rows, value, isForce) {
    const $xeTable = this;
    return handleCheckedCheckboxRow($xeTable, rows, value, isForce);
  },
  /**
   * 用于多选行，设置行为选中状态，第二个参数为选中与否
   * @param {Array/Row} rows 行数据
   * @param {Boolean} value 是否选中
   */
  setCheckboxRow(rows, checked) {
    const $xeTable = this;
    if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
      rows = [rows];
    }
    return handleCheckedCheckboxRow($xeTable, rows, checked, true);
  },
  setCheckboxRowKey(keys, checked) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    if (keys && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(keys)) {
      keys = [keys];
    }
    const rows = [];
    keys.forEach(rowid => {
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        rows.push(rowRest.row);
      }
    });
    return handleCheckedCheckboxRow($xeTable, rows, checked, true);
  },
  isCheckedByCheckboxRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      updateCheckboxFlag
    } = reactData;
    const {
      selectCheckboxMaps
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField
    } = checkboxOpts;
    if (checkField) {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
    }
    return !!updateCheckboxFlag && !!selectCheckboxMaps[getRowid($xeTable, row)];
  },
  isCheckedByCheckboxRowKey(rowid) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      updateCheckboxFlag
    } = reactData;
    const {
      fullAllDataRowIdData,
      selectCheckboxMaps
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField
    } = checkboxOpts;
    if (checkField) {
      const rowRest = fullAllDataRowIdData[rowid];
      if (rowRest) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rowRest.row, checkField);
      }
      return false;
    }
    return !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
  },
  isIndeterminateByCheckboxRow(row) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      treeIndeterminateRowMaps
    } = internalData;
    return !!treeIndeterminateRowMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
  },
  isIndeterminateByCheckboxRowKey(rowid) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      treeIndeterminateRowMaps
    } = internalData;
    return !!treeIndeterminateRowMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
  },
  /**
   * 切换选中
   * 多选，行选中事件
   */
  handleBatchSelectRows(rows, checked, isForce) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      selectCheckboxMaps
    } = internalData;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      mapChildrenField
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField,
      checkStrictly,
      checkMethod
    } = checkboxOpts;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    // indeterminateField 仅支持读取
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    if (checkField) {
      // 树结构
      if ((treeConfig || isRowGroupStatus) && !checkStrictly) {
        // 更新子节点状态
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows, row => {
          if (isForce || !checkMethod || checkMethod({
            $table: $xeTable,
            row
          })) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, checked);
            if (indeterminateField) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, false);
            }
            handleCheckboxReserveRow($xeTable, row, checked);
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
        reactData.updateCheckboxFlag++;
        return;
      }
      // 列表
      rows.forEach(row => {
        if (isForce || !checkMethod || checkMethod({
          $table: $xeTable,
          row
        })) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, checked);
          handleCheckboxReserveRow($xeTable, row, checked);
        }
      });
      reactData.updateCheckboxFlag++;
      return;
    }
    // 树结构
    if (!checkStrictly) {
      if (isRowGroupStatus) {
        // 更新行分组节点状态
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows, row => {
          const rowid = handleGetRowId(row);
          if (isForce || !checkMethod || checkMethod({
            $table: $xeTable,
            row
          })) {
            if (checked) {
              selectCheckboxMaps[rowid] = row;
            } else {
              if (selectCheckboxMaps[rowid]) {
                delete selectCheckboxMaps[rowid];
              }
            }
            handleCheckboxReserveRow($xeTable, row, checked);
          }
        }, {
          children: aggregateOpts.mapChildrenField
        });
        reactData.updateCheckboxFlag++;
        return;
      } else if (treeConfig) {
        // 更新子节点状态
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows, row => {
          const rowid = handleGetRowId(row);
          if (isForce || !checkMethod || checkMethod({
            $table: $xeTable,
            row
          })) {
            if (checked) {
              selectCheckboxMaps[rowid] = row;
            } else {
              if (selectCheckboxMaps[rowid]) {
                delete selectCheckboxMaps[rowid];
              }
            }
            handleCheckboxReserveRow($xeTable, row, checked);
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
        reactData.updateCheckboxFlag++;
        return;
      }
    }
    // 列表
    rows.forEach(row => {
      const rowid = handleGetRowId(row);
      if (isForce || !checkMethod || checkMethod({
        $table: $xeTable,
        row
      })) {
        if (checked) {
          if (!selectCheckboxMaps[rowid]) {
            selectCheckboxMaps[rowid] = row;
          }
        } else {
          if (selectCheckboxMaps[rowid]) {
            delete selectCheckboxMaps[rowid];
          }
        }
        handleCheckboxReserveRow($xeTable, row, checked);
        reactData.updateCheckboxFlag++;
      }
    });
  },
  /**
   * 即将移除
   * @deprecated
   */
  handleSelectRow({
    row
  }, checked, isForce) {
    const $xeTable = this;
    $xeTable.handleBatchSelectRows([row], checked, isForce);
  },
  handleToggleCheckRowEvent(evnt, params) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      selectCheckboxMaps
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField,
      trigger
    } = checkboxOpts;
    const {
      row
    } = params;
    if (trigger === 'manual') {
      return;
    }
    let checked = false;
    if (checkField) {
      checked = !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
    } else {
      checked = !selectCheckboxMaps[getRowid($xeTable, row)];
    }
    if (evnt) {
      $xeTable.triggerCheckRowEvent(evnt, params, checked);
    } else {
      $xeTable.handleBatchSelectRows([row], checked);
      $xeTable.checkSelectionStatus();
    }
  },
  triggerCheckRowEvent(evnt, params, checked) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      row
    } = params;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      afterFullData
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkMethod,
      trigger
    } = checkboxOpts;
    if (trigger === 'manual') {
      return;
    }
    evnt.stopPropagation();
    if (checkboxOpts.isShiftKey && evnt.shiftKey && !(treeConfig || isRowGroupStatus)) {
      const checkboxRecords = $xeTable.getCheckboxRecords();
      if (checkboxRecords.length) {
        const firstRow = checkboxRecords[0];
        const _rowIndex = $xeTable.getVTRowIndex(row);
        const _firstRowIndex = $xeTable.getVTRowIndex(firstRow);
        if (_rowIndex !== _firstRowIndex) {
          $xeTable.setAllCheckboxRow(false);
          const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
          $xeTable.$nextTick(() => {
            handleCheckedCheckboxRow($xeTable, rangeRows, true, false);
          });
          $xeTable.dispatchEvent('checkbox-range-select', Object.assign({
            rangeRecords: rangeRows
          }, params), evnt);
          return;
        }
      }
    }
    if (!checkMethod || checkMethod({
      $table: $xeTable,
      row
    })) {
      $xeTable.handleBatchSelectRows([row], checked);
      $xeTable.checkSelectionStatus();
      $xeTable.dispatchEvent('checkbox-change', Object.assign({
        records: () => $xeTable.getCheckboxRecords(),
        reserves: () => $xeTable.getCheckboxReserveRecords(),
        indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
        checked
      }, params), evnt);
    }
  },
  /**
   * 多选，切换某一行的选中状态
   */
  toggleCheckboxRow(row) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      selectCheckboxMaps
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField
    } = checkboxOpts;
    const checked = checkField ? !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
    $xeTable.handleBatchSelectRows([row], checked, true);
    $xeTable.checkSelectionStatus();
    return $xeTable.$nextTick();
  },
  /**
   * 用于多选行，设置所有行的选中状态
   * @param {Boolean} value 是否选中
   */
  setAllCheckboxRow(value) {
    const $xeTable = this;
    return handleCheckedAllCheckboxRow($xeTable, value, true);
  },
  updateCheckboxStatus() {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      afterTreeFullData,
      afterGroupFullData,
      selectCheckboxMaps,
      treeIndeterminateRowMaps
    } = internalData;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField,
      checkStrictly,
      checkMethod
    } = checkboxOpts;
    if (checkStrictly) {
      return;
    }
    if (isRowGroupStatus || treeConfig) {
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      const childRowMaps = {};
      const childRowList = [];
      if (isRowGroupStatus) {
        // 行分组
        const mapChildrenField = aggregateOpts.mapChildrenField;
        if (mapChildrenField) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData, row => {
            const rowid = handleGetRowId(row);
            const childList = row[mapChildrenField];
            if (childList && childList.length && !childRowMaps[rowid]) {
              childRowMaps[rowid] = 1;
              childRowList.unshift([row, rowid, childList]);
            }
          }, {
            children: mapChildrenField
          });
        }
      } else if (treeConfig) {
        // 树结构
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData, row => {
          const rowid = handleGetRowId(row);
          const childList = row[transform ? mapChildrenField : childrenField];
          if (childList && childList.length && !childRowMaps[rowid]) {
            childRowMaps[rowid] = 1;
            childRowList.unshift([row, rowid, childList]);
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
      }
      childRowList.forEach(vals => {
        const row = vals[0];
        const rowid = vals[1];
        const childList = vals[2];
        let sLen = 0; // 已选
        let hLen = 0; // 半选
        let vLen = 0; // 有效行
        childList.forEach(checkMethod ? item => {
          const childRowid = handleGetRowId(item);
          const isSelect = checkField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, checkField) : selectCheckboxMaps[childRowid];
          if (checkMethod({
            $table: $xeTable,
            row: item
          })) {
            if (isSelect) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (isSelect) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
          }
        } : item => {
          const childRowid = handleGetRowId(item);
          const isSelect = checkField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, checkField) : selectCheckboxMaps[childRowid];
          if (isSelect) {
            sLen++;
          } else if (treeIndeterminateRowMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = sLen >= vLen;
        const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
        if (checkField) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, isSelected);
        }
        if (isSelected) {
          if (!checkField) {
            selectCheckboxMaps[rowid] = row;
          }
          if (treeIndeterminateRowMaps[rowid]) {
            delete treeIndeterminateRowMaps[rowid];
          }
        } else {
          if (!checkField) {
            if (selectCheckboxMaps[rowid]) {
              delete selectCheckboxMaps[rowid];
            }
          }
          if (halfSelect) {
            treeIndeterminateRowMaps[rowid] = row;
          } else {
            if (treeIndeterminateRowMaps[rowid]) {
              delete treeIndeterminateRowMaps[rowid];
            }
          }
        }
      });
    }
    reactData.updateCheckboxFlag++;
  },
  updateAllCheckboxStatus() {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      afterFullData,
      afterTreeFullData,
      afterGroupFullData,
      checkboxReserveRowMap,
      selectCheckboxMaps,
      treeIndeterminateRowMaps
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField,
      checkMethod,
      showReserveStatus
    } = checkboxOpts;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    let sLen = 0; // 已选
    let hLen = 0; // 半选
    let vLen = 0; // 有效行
    const rootList = treeConfig ? afterTreeFullData : isRowGroupStatus ? afterGroupFullData : afterFullData;
    rootList.forEach(checkMethod ? row => {
      const childRowid = handleGetRowId(row);
      const selected = checkField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) : selectCheckboxMaps[childRowid];
      if (checkMethod({
        $table: $xeTable,
        row
      })) {
        if (selected) {
          sLen++;
        } else if (treeIndeterminateRowMaps[childRowid]) {
          hLen++;
        }
        vLen++;
      } else {
        if (selected) {
          sLen++;
        } else if (treeIndeterminateRowMaps[childRowid]) {
          hLen++;
        }
      }
    } : row => {
      const childRowid = handleGetRowId(row);
      const selected = checkField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) : selectCheckboxMaps[childRowid];
      if (selected) {
        sLen++;
      } else if (treeIndeterminateRowMaps[childRowid]) {
        hLen++;
      }
      vLen++;
    });
    const isSelected = rootList.length > 0 ? vLen > 0 ? sLen >= vLen : sLen >= rootList.length : false;
    let halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
    // 如果复选框启用保留记录，当保留数据存在时显示半选
    if (!isSelected && !halfSelect && showReserveStatus) {
      halfSelect = !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(checkboxReserveRowMap);
    }
    reactData.isAllSelected = isSelected;
    reactData.isIndeterminate = halfSelect;
  },
  checkSelectionStatus() {
    const $xeTable = this;
    $xeTable.updateCheckboxStatus();
    $xeTable.updateAllCheckboxStatus();
  },
  /**
   * 获取单选框保留选中的行
   */
  getRadioReserveRecord(isFull) {
    const {
      fullDataRowIdData,
      radioReserveRow,
      radioOpts,
      afterFullData,
      treeConfig,
      treeOpts
    } = this;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    if (radioOpts.reserve && radioReserveRow) {
      const rowid = getRowid(this, radioReserveRow);
      if (isFull) {
        if (!fullDataRowIdData[rowid]) {
          return radioReserveRow;
        }
      } else {
        const rowkey = getRowkey(this);
        if (treeConfig) {
          const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, row => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowkey), {
            children: childrenField
          });
          if (matchObj) {
            return radioReserveRow;
          }
        } else {
          if (!afterFullData.some(row => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowkey))) {
            return radioReserveRow;
          }
        }
      }
    }
    return null;
  },
  clearRadioReserve() {
    this.radioReserveRow = null;
    return this.$nextTick();
  },
  /**
   * 获取复选框保留选中的行
   */
  getCheckboxReserveRecords(isFull) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      afterFullData,
      fullDataRowIdData,
      checkboxReserveRowMap
    } = internalData;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const reserveSelection = [];
    if (checkboxOpts.reserve) {
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      const afterFullIdMaps = {};
      if (treeConfig) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, row => {
          afterFullIdMaps[handleGetRowId(row)] = 1;
        }, {
          children: childrenField
        });
      } else {
        afterFullData.forEach(row => {
          afterFullIdMaps[handleGetRowId(row)] = 1;
        });
      }
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(checkboxReserveRowMap, (oldRow, oldRowid) => {
        if (oldRow) {
          if (isFull) {
            if (!fullDataRowIdData[oldRowid]) {
              reserveSelection.push(oldRow);
            }
          } else {
            if (!afterFullIdMaps[oldRowid]) {
              reserveSelection.push(oldRow);
            }
          }
        }
      });
    }
    return reserveSelection;
  },
  clearCheckboxReserve() {
    this.checkboxReserveRowMap = {};
    return this.$nextTick();
  },
  handleCheckboxReserveRow(row, checked) {
    const {
      checkboxReserveRowMap,
      checkboxOpts
    } = this;
    if (checkboxOpts.reserve) {
      const rowid = getRowid(this, row);
      if (checked) {
        checkboxReserveRowMap[rowid] = row;
      } else if (checkboxReserveRowMap[rowid]) {
        delete checkboxReserveRowMap[rowid];
      }
    }
  },
  handleCheckAllEvent(evnt, value) {
    const $xeTable = this;
    handleCheckedAllCheckboxRow($xeTable, value);
    if (evnt) {
      $xeTable.dispatchEvent('checkbox-all', {
        records: () => $xeTable.getCheckboxRecords(),
        reserves: () => $xeTable.getCheckboxReserveRecords(),
        indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
        checked: value
      }, evnt);
    }
  },
  /**
   * 多选，选中所有事件
   */
  triggerCheckAllEvent(evnt, value) {
    const $xeTable = this;
    const {
      checkboxOpts
    } = this;
    const {
      trigger
    } = checkboxOpts;
    if (trigger === 'manual') {
      return;
    }
    if (evnt) {
      evnt.stopPropagation();
    }
    $xeTable.handleCheckAllEvent(evnt, value);
  },
  /**
   * 多选，切换所有行的选中状态
   */
  toggleAllCheckboxRow() {
    this.handleCheckAllEvent(null, !this.isAllSelected);
    return this.$nextTick();
  },
  /**
   * 用于多选行，手动清空用户的选择
   * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
   */
  clearCheckboxRow() {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      tableFullData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const {
      checkField,
      reserve
    } = checkboxOpts;
    // indeterminateField 仅支持读取
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    if (checkField) {
      const handleClearChecked = item => {
        if (treeConfig && indeterminateField) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, indeterminateField, false);
        }
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, checkField, false);
      };
      if (treeConfig) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData, handleClearChecked, {
          children: childrenField
        });
      } else {
        tableFullData.forEach(handleClearChecked);
      }
    }
    if (reserve) {
      tableFullData.forEach(row => this.handleCheckboxReserveRow(row, false));
    }
    reactData.isAllSelected = false;
    reactData.isIndeterminate = false;
    internalData.selectCheckboxMaps = {};
    internalData.treeIndeterminateRowMaps = {};
    reactData.updateCheckboxFlag++;
    return this.$nextTick();
  },
  /**
   * 单选，行选中事件
   */
  triggerRadioRowEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      selectRadioRow: oldValue
    } = reactData;
    const {
      row
    } = params;
    const radioOpts = $xeTable.computeRadioOpts;
    const {
      trigger,
      checkMethod
    } = radioOpts;
    if (trigger === 'manual') {
      return;
    }
    evnt.stopPropagation();
    if (!checkMethod || checkMethod({
      $table: $xeTable,
      row
    })) {
      let newValue = row;
      let isChange = oldValue !== newValue;
      if (isChange) {
        handleCheckedRadioRow($xeTable, newValue);
      } else if (!radioOpts.strict) {
        isChange = oldValue === newValue;
        if (isChange) {
          newValue = null;
          $xeTable.clearRadioRow();
        }
      }
      if (isChange) {
        $xeTable.dispatchEvent('radio-change', {
          oldValue,
          newValue,
          ...params
        }, evnt);
      }
    }
  },
  triggerCurrentColumnEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      currentColumn: oldValue
    } = reactData;
    const columnOpts = $xeTable.computeColumnOpts;
    const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
    const beforeRowMethod = currentColumnOpts.beforeSelectMethod || columnOpts.currentMethod;
    const {
      column: newValue
    } = params;
    const {
      trigger
    } = currentColumnOpts;
    if (trigger === 'manual') {
      return;
    }
    const isChange = oldValue !== newValue;
    if (!beforeRowMethod || beforeRowMethod({
      column: newValue,
      $table: $xeTable
    })) {
      $xeTable.setCurrentColumn(newValue);
      if (isChange) {
        $xeTable.dispatchEvent('current-column-change', {
          oldValue,
          newValue,
          ...params
        }, evnt);
      }
    } else {
      $xeTable.dispatchEvent('current-column-disabled', params, evnt);
    }
  },
  triggerCurrentRowEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      currentRow: oldValue
    } = reactData;
    const rowOpts = $xeTable.computeRowOpts;
    const currentRowOpts = $xeTable.computeCurrentRowOpts;
    const beforeRowMethod = currentRowOpts.beforeSelectMethod || rowOpts.currentMethod;
    const {
      row: newValue
    } = params;
    const {
      trigger
    } = currentRowOpts;
    if (trigger === 'manual') {
      return;
    }
    const isChange = oldValue !== newValue;
    if (!beforeRowMethod || beforeRowMethod({
      row: newValue,
      $table: $xeTable
    })) {
      $xeTable.setCurrentRow(newValue);
      if (isChange) {
        $xeTable.dispatchEvent('current-row-change', {
          oldValue,
          newValue,
          ...params
        }, evnt);
        // 已废弃
        $xeTable.dispatchEvent('current-change', {
          oldValue,
          newValue,
          ...params
        }, evnt);
      }
    } else {
      $xeTable.dispatchEvent('current-row-disabled', params, evnt);
    }
  },
  /**
   * 用于当前行，设置某一行为高亮状态
   * @param {Row} row 行对象
   */
  setCurrentRow(row) {
    const {
      $el,
      rowOpts
    } = this;
    this.clearCurrentRow();
    // this.clearCurrentColumn()
    this.currentRow = row;
    if (rowOpts.isCurrent || this.highlightCurrentRow) {
      if ($el) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach($el.querySelectorAll(`[rowid="${getRowid(this, row)}"]`), elem => addClass(elem, 'row--current'));
      }
    }
    return this.$nextTick();
  },
  isCheckedByRadioRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      selectRadioRow
    } = reactData;
    if (row && selectRadioRow) {
      return $xeTable.eqRow(selectRadioRow, row);
    }
    return false;
  },
  isCheckedByRadioRowKey(key) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      selectRadioRow
    } = reactData;
    if (selectRadioRow) {
      return key === getRowid($xeTable, selectRadioRow);
    }
    return false;
  },
  /**
   * 用于单选行，设置某一行为选中状态
   * @param {Row} row 行对象
   */
  setRadioRow(row) {
    const $xeTable = this;
    return handleCheckedRadioRow($xeTable, row, true);
  },
  /**
   * 用于单选行，设置某一行为选中状态
   * @param key 行主键
   */
  setRadioRowKey(rowid) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData
    } = internalData;
    const rowRest = fullAllDataRowIdData[rowid];
    if (rowRest) {
      return handleCheckedRadioRow($xeTable, rowRest.row, true);
    }
    return $xeTable.$nextTick();
  },
  /**
   * 用于当前行，手动清空当前高亮的状态
   */
  clearCurrentRow() {
    const {
      $el
    } = this;
    this.currentRow = null;
    this.hoverRow = null;
    if ($el) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach($el.querySelectorAll('.row--current'), elem => removeClass(elem, 'row--current'));
    }
    return this.$nextTick();
  },
  /**
   * 用于单选行，手动清空用户的选择
   */
  clearRadioRow() {
    this.selectRadioRow = null;
    return this.$nextTick();
  },
  /**
   * 用于当前行，获取当前行的数据
   */
  getCurrentRecord() {
    return this.rowOpts.isCurrent || this.highlightCurrentRow ? this.currentRow : null;
  },
  /**
   * 用于单选行，获取当已选中的数据
   */
  getRadioRecord(isFull) {
    const {
      selectRadioRow,
      fullDataRowIdData,
      afterFullRowMaps
    } = this;
    if (selectRadioRow) {
      const rowid = getRowid(this, selectRadioRow);
      if (isFull) {
        if (fullDataRowIdData[rowid]) {
          return selectRadioRow;
        }
      } else {
        if (afterFullRowMaps[rowid]) {
          return selectRadioRow;
        }
      }
    }
    return null;
  },
  /**
   * 行 hover 事件
   */
  triggerHoverEvent(evnt, {
    row
  }) {
    this.setHoverRow(row);
  },
  setHoverRow(row) {
    const {
      $el
    } = this;
    const rowid = getRowid(this, row);
    this.clearHoverRow();
    if ($el) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach($el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`), elem => addClass(elem, 'row--hover'));
    }
    this.hoverRow = row;
  },
  clearHoverRow() {
    const {
      $el
    } = this;
    if ($el) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach($el.querySelectorAll('.vxe-body--row.row--hover'), elem => removeClass(elem, 'row--hover'));
    }
    this.hoverRow = null;
  },
  triggerHeaderCellClickEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      _lastResizeTime
    } = internalData;
    const sortOpts = $xeTable.computeSortOpts;
    const columnOpts = $xeTable.computeColumnOpts;
    const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
    const {
      column
    } = params;
    const cell = evnt.currentTarget;
    const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
    const triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;
    const triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;
    if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {
      $xeTable.triggerSortEvent(evnt, column, getNextSortOrder($xeTable, column));
    }
    $xeTable.dispatchEvent('header-cell-click', Object.assign({
      triggerResizable,
      triggerSort,
      triggerFilter,
      cell
    }, params), evnt);
    if ((columnOpts.isCurrent || props.highlightCurrentColumn) && (!currentColumnOpts.trigger || ['header', 'default'].includes(currentColumnOpts.trigger))) {
      $xeTable.triggerCurrentColumnEvent(evnt, params);
    }
    return $xeTable.$nextTick();
  },
  triggerHeaderCellDblclickEvent(evnt, params) {
    this.emitEvent('header-cell-dblclick', Object.assign({
      cell: evnt.currentTarget
    }, params), evnt);
  },
  getCurrentColumn() {
    return this.columnOpts.isCurrent || this.highlightCurrentColumn ? this.currentColumn : null;
  },
  /**
   * 用于当前列，设置某列行为高亮状态
   * @param {ColumnInfo} fieldOrColumn 列配置
   */
  setCurrentColumn(fieldOrColumn) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      mouseConfig
    } = props;
    const mouseOpts = $xeTable.computeMouseOpts;
    const isMouseSelected = mouseConfig && mouseOpts.selected;
    const column = handleFieldOrColumn($xeTable, fieldOrColumn);
    if (column) {
      $xeTable.clearCurrentColumn();
      reactData.currentColumn = column;
    }
    return $xeTable.$nextTick().then(() => {
      // 更新状选中态
      if (isMouseSelected) {
        $xeTable.addCellSelectedClass();
      }
    });
  },
  /**
   * 用于当前列，手动清空当前高亮的状态
   */
  clearCurrentColumn() {
    this.currentColumn = null;
    return this.$nextTick();
  },
  /**
   * 列点击事件
   * 如果是单击模式，则激活为编辑状态
   * 如果是双击模式，则单击后选中状态
   */
  triggerCellClickEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      highlightCurrentRow,
      highlightCurrentColumn,
      editConfig
    } = props;
    const {
      editStore,
      isDragResize
    } = reactData;
    if (isDragResize) {
      return;
    }
    const expandOpts = $xeTable.computeExpandOpts;
    const editOpts = $xeTable.computeEditOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const radioOpts = $xeTable.computeRadioOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const keyboardOpts = $xeTable.computeKeyboardOpts;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const columnOpts = $xeTable.computeColumnOpts;
    const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
    const {
      actived,
      focused
    } = editStore;
    const {
      row,
      column
    } = params;
    const {
      type,
      treeNode,
      rowGroupNode
    } = column;
    const isRadioType = type === 'radio';
    const isCheckboxType = type === 'checkbox';
    const isExpandType = type === 'expand';
    const cell = evnt.currentTarget;
    const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;
    const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;
    const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-cell--tree-btn').flag;
    const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;
    const triggerRowGroupNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-row-group--node-btn').flag;
    params = Object.assign({
      cell,
      triggerRadio,
      triggerCheckbox,
      triggerTreeNode,
      triggerExpandNode
    }, params);
    if (!triggerCheckbox && !triggerRadio) {
      // 如果是展开行
      if (!triggerExpandNode && (expandOpts.trigger === 'row' || isExpandType && expandOpts.trigger === 'cell')) {
        $xeTable.triggerRowExpandEvent(evnt, params);
      }
      // 如果是树形表格
      if (treeOpts.trigger === 'row' || treeNode && treeOpts.trigger === 'cell') {
        $xeTable.triggerTreeExpandEvent(evnt, params);
      }
      // 如果是行分组
      if (aggregateOpts.trigger === 'row' || rowGroupNode && aggregateOpts.trigger === 'cell') {
        $xeTable.triggerRowGroupExpandEvent(evnt, params);
      }
    }
    // 如果点击了树节点
    if (!triggerTreeNode) {
      if (!triggerExpandNode && !triggerRowGroupNode) {
        // 如果是当前行
        if (rowOpts.isCurrent || highlightCurrentRow) {
          if (!triggerCheckbox && !triggerRadio) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          }
        }
        // 如果是当前列
        if ((columnOpts.isCurrent || highlightCurrentColumn) && (!currentColumnOpts.trigger || ['cell', 'default'].includes(currentColumnOpts.trigger))) {
          if (!triggerCheckbox && !triggerRadio) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          }
        }
        // 如果是单选框
        if (!triggerRadio && (radioOpts.trigger === 'row' || isRadioType && radioOpts.trigger === 'cell')) {
          $xeTable.triggerRadioRowEvent(evnt, params);
        }
        // 如果是复选框
        if (!triggerCheckbox && (checkboxOpts.trigger === 'row' || isCheckboxType && checkboxOpts.trigger === 'cell')) {
          $xeTable.handleToggleCheckRowEvent(evnt, params);
        }
      }
      // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）
      if (isEnableConf(editConfig)) {
        // 记录点击输入框聚焦状态
        if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === 'cell' && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
          focused.column = column;
          focused.row = row;
        }
        if (editOpts.trigger === 'manual') {
          if (actived.args && actived.row === row && column !== actived.column) {
            handleChangeCell($xeTable, evnt, params);
          }
        } else if (!actived.args || row !== actived.row || column !== actived.column) {
          if (editOpts.trigger === 'click') {
            handleChangeCell($xeTable, evnt, params);
          } else if (editOpts.trigger === 'dblclick') {
            if (editOpts.mode === 'row' && actived.row === row) {
              handleChangeCell($xeTable, evnt, params);
            }
          }
        }
      }
    }
    // 如果是双击编辑模式
    if (isEnableConf(editConfig) && editOpts.trigger === 'dblclick') {
      if (actived.row && actived.column) {
        if (editOpts.mode === 'row') {
          if (!$xeTable.eqRow(actived.row, row)) {
            $xeTable.handleClearEdit(evnt);
          }
        } else if (editOpts.mode === 'cell') {
          if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
            $xeTable.handleClearEdit(evnt);
          }
        }
      }
    }
    $xeTable.dispatchEvent('cell-click', params, evnt);
  },
  /**
   * 列双击点击事件
   * 如果是双击模式，则激活为编辑状态
   */
  triggerCellDblclickEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      editConfig
    } = props;
    const {
      editStore,
      isDragResize
    } = reactData;
    if (isDragResize) {
      return;
    }
    const editOpts = $xeTable.computeEditOpts;
    const {
      actived
    } = editStore;
    const cell = evnt.currentTarget;
    params = Object.assign({
      cell
    }, params);
    if (isEnableConf(editConfig) && editOpts.trigger === 'dblclick') {
      if (!actived.args || evnt.currentTarget !== actived.args.cell) {
        if (editOpts.mode === 'row') {
          checkValidate($xeTable, 'blur').catch(e => e).then(() => {
            $xeTable.handleEdit(params, evnt).then(() => checkValidate($xeTable, 'change')).catch(e => e);
          });
        } else if (editOpts.mode === 'cell') {
          $xeTable.handleEdit(params, evnt).then(() => checkValidate($xeTable, 'change')).catch(e => e);
        }
      }
    }
    this.emitEvent('cell-dblclick', params, evnt);
  },
  handleColumnSortEvent(evnt, column) {
    const $xeTable = this;
    const props = $xeTable;
    const {
      mouseConfig
    } = props;
    const mouseOpts = $xeTable.computeMouseOpts;
    const {
      field,
      sortable,
      order
    } = column;
    if (sortable) {
      const params = {
        $table: $xeTable,
        $event: evnt,
        column,
        field,
        property: field,
        order,
        sortList: $xeTable.getSortColumns(),
        sortTime: column.sortTime
      };
      if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
        $xeTable.handleSortEvent(evnt, params);
      }
      if (!order) {
        $xeTable.dispatchEvent('clear-sort', params, evnt);
      }
      $xeTable.dispatchEvent('sort-change', params, evnt);
    }
  },
  /**
   * 点击排序事件
   */
  triggerSortEvent(evnt, column, order) {
    const $xeTable = this;
    const sortOpts = $xeTable.computeSortOpts;
    const {
      multiple,
      allowClear
    } = sortOpts;
    const {
      field,
      sortable
    } = column;
    if (sortable || column.remoteSort) {
      if (!order || column.order === order) {
        if (allowClear) {
          $xeTable.clearSort(multiple ? column : null);
        }
      } else {
        $xeTable.sort({
          field,
          order
        });
      }
      $xeTable.handleColumnSortEvent(evnt, column);
    }
  },
  handleCellRuleUpdateStatus(type, cellParams, cellValue) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      validStore
    } = reactData;
    const {
      row,
      column
    } = cellParams;
    if ($xeTable.hasCellRules) {
      if ($xeTable.hasCellRules(type, row, column)) {
        const cell = $xeTable.getCellElement(row, column);
        if (cell) {
          const customVal = !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(cellValue);
          return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
            if (customVal && validStore.visible) {
              setCellValue(row, column, cellValue);
            }
            $xeTable.clearValidate(row, column);
          }).catch(({
            rule
          }) => {
            if (customVal) {
              setCellValue(row, column, cellValue);
            }
            $xeTable.showValidTooltip({
              rule,
              row,
              column,
              cell
            });
          });
        }
      }
    }
    return $xeTable.$nextTick();
  },
  /**
   * 表头单元格按下事件
   */
  triggerHeaderCellMousedownEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const {
      mouseConfig
    } = props;
    const mouseOpts = $xeTable.computeMouseOpts;
    const columnOpts = $xeTable.computeColumnOpts;
    const columnDragOpts = $xeTable.computeColumnDragOpts;
    const {
      trigger,
      isCrossDrag,
      isPeerDrag,
      disabledMethod
    } = columnDragOpts;
    const cell = evnt.currentTarget;
    const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === 'input';
    const triggerCheckbox = getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;
    const triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;
    const triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;
    let triggerDrag = false;
    const isColDragCell = columnOpts.drag && trigger === 'cell';
    if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
      const {
        column
      } = params;
      if (isColDragCell && !column.fixed && (isCrossDrag || isPeerDrag || !column.parentId) && !(disabledMethod && disabledMethod(params))) {
        triggerDrag = true;
        $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
      }
    }
    if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaEvent) {
      $xeTable.handleHeaderCellAreaEvent(evnt, Object.assign({
        cell,
        triggerSort,
        triggerFilter
      }, params));
    }
    $xeTable.focus();
    if ($xeTable.closeMenu) {
      $xeTable.closeMenu();
    }
  },
  /**
   * 单元格按下事件
   */
  triggerCellMousedownEvent(evnt, params) {
    const $xeTable = this;
    const {
      column
    } = params;
    const {
      type,
      treeNode
    } = column;
    const isRadioType = type === 'radio';
    const isCheckboxType = type === 'checkbox';
    const isExpandType = type === 'expand';
    const rowOpts = $xeTable.computeRowOpts;
    const rowDragOpts = $xeTable.computeRowDragOpts;
    const {
      trigger,
      isCrossDrag,
      isPeerDrag,
      disabledMethod
    } = rowDragOpts;
    const cell = evnt.currentTarget;
    params.cell = cell;
    const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === 'input';
    const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;
    const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;
    const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-cell--tree-btn').flag;
    const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;
    let isColDragCell = false;
    if (rowOpts.drag) {
      isColDragCell = trigger === 'row' || column.dragSort && trigger === 'cell';
    }
    let triggerDrag = false;
    if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
      if (isColDragCell && (isCrossDrag || isPeerDrag || !params.level) && !(disabledMethod && disabledMethod(params))) {
        triggerDrag = true;
        $xeTable.handleCellDragMousedownEvent(evnt, params);
      }
    }
    if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
      $xeTable.handleCellMousedownEvent(evnt, params);
    }
    $xeTable.focus();
    $xeTable.closeFilter();
    if ($xeTable.closeMenu) {
      $xeTable.closeMenu();
    }
  },
  triggerCellMouseupEvent() {
    const $xeTable = this;
    clearDragStatus($xeTable);
  },
  /**
   * 行拖拽
   */
  handleRowDragDragstartEvent(evnt) {
    if (evnt.dataTransfer) {
      evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
    }
  },
  handleRowDragSwapEvent(evnt, isSyncRow, dragRow, prevDragRow, prevDragPos, prevDragToChild) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig,
      dragConfig
    } = props;
    const rowDragOpts = $xeTable.computeRowDragOpts;
    const {
      afterFullData,
      tableFullData,
      fullAllDataRowIdData
    } = internalData;
    const {
      isPeerDrag,
      isCrossDrag,
      isSelfToChildDrag,
      dragEndMethod,
      dragToChildMethod
    } = rowDragOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      rowField,
      mapChildrenField,
      parentField
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
    const dragOffsetIndex = prevDragPos === 'bottom' ? 1 : 0;
    const errRest = {
      status: false
    };
    if (prevDragRow && dragRow) {
      // 判断是否有拖动
      if (prevDragRow !== dragRow) {
        const dragParams = {
          oldRow: dragRow,
          newRow: prevDragRow,
          dragRow,
          dragPos: prevDragPos,
          dragToChild: !!prevDragToChild,
          offsetIndex: dragOffsetIndex
        };
        const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
        return Promise.resolve(dEndMethod ? dEndMethod(dragParams) : true).then(status => {
          if (!status) {
            return errRest;
          }
          let oafIndex = -1;
          let nafIndex = -1;
          // 如果为树结构
          if (treeConfig) {
            if (transform) {
              // 移出源位置
              const oldRowid = getRowid($xeTable, dragRow);
              const oldRest = fullAllDataRowIdData[oldRowid];
              const newRowid = getRowid($xeTable, prevDragRow);
              const newRest = fullAllDataRowIdData[newRowid];
              if (oldRest && newRest) {
                const {
                  level: oldLevel
                } = oldRest;
                const {
                  level: newLevel
                } = newRest;
                const oldAllMaps = {};
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragRow], item => {
                  oldAllMaps[getRowid($xeTable, item)] = item;
                }, {
                  children: mapChildrenField
                });
                let isSelfToChildStatus = false;
                if (oldLevel && newLevel) {
                  // 子到子
                  if (isPeerDrag && !isCrossDrag) {
                    if (oldRest.row[parentField] !== newRest.row[parentField]) {
                      // 非同级
                      return errRest;
                    }
                  } else {
                    if (!isCrossDrag) {
                      return errRest;
                    }
                    if (oldAllMaps[newRowid]) {
                      isSelfToChildStatus = true;
                      if (!(isCrossDrag && isSelfToChildDrag)) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            status: 'error',
                            content: methods_getI18n('vxe.error.treeDragChild')
                          });
                        }
                        return errRest;
                      }
                    }
                  }
                } else if (oldLevel) {
                  // 子到根
                  if (!isCrossDrag) {
                    return errRest;
                  }
                } else if (newLevel) {
                  // 根到子
                  if (!isCrossDrag) {
                    return errRest;
                  }
                  if (oldAllMaps[newRowid]) {
                    isSelfToChildStatus = true;
                    if (!(isCrossDrag && isSelfToChildDrag)) {
                      if (core_.VxeUI.modal) {
                        core_.VxeUI.modal.message({
                          status: 'error',
                          content: methods_getI18n('vxe.error.treeDragChild')
                        });
                      }
                      return errRest;
                    }
                  }
                } else {
                  // 根到根
                }
                const fullList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(internalData.afterTreeFullData, {
                  key: rowField,
                  parentKey: parentField,
                  children: mapChildrenField
                });
                // 移出
                const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                fullList.splice(otfIndex, 1);
                // 插入
                const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                const ntfIndex = ptfIndex + dragOffsetIndex;
                fullList.splice(ntfIndex, 0, dragRow);
                // 改变层级
                if (isSelfToChildStatus && isCrossDrag && isSelfToChildDrag) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(dragRow[childrenField], childRow => {
                    childRow[parentField] = dragRow[parentField];
                  });
                }
                dragRow[parentField] = isDragToChildFlag ? prevDragRow[rowField] : prevDragRow[parentField];
                internalData.tableFullTreeData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullList, {
                  key: rowField,
                  parentKey: parentField,
                  children: childrenField,
                  mapChildren: mapChildrenField
                });
              }
            }
          } else {
            // 移出
            oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
            const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
            afterFullData.splice(oafIndex, 1);
            tableFullData.splice(otfIndex, 1);
            // 插入
            const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
            const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
            nafIndex = pafIndex + dragOffsetIndex;
            const ntfIndex = ptfIndex + dragOffsetIndex;
            afterFullData.splice(nafIndex, 0, dragRow);
            tableFullData.splice(ntfIndex, 0, dragRow);
          }
          reactData.isDragRowMove = true;
          $xeTable.handleTableData(treeConfig && transform);
          $xeTable.cacheRowMap(false);
          updateScrollYStatus($xeTable);
          if (!(treeConfig && transform)) {
            updateAfterDataIndex($xeTable);
          }
          $xeTable.checkSelectionStatus();
          if (reactData.scrollYLoad) {
            $xeTable.updateScrollYSpace();
          }
          if (evnt) {
            $xeTable.dispatchEvent('row-dragend', {
              oldRow: dragRow,
              newRow: prevDragRow,
              dragRow,
              dragPos: prevDragPos,
              dragToChild: isDragToChildFlag,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
          }
          return $xeTable.$nextTick().then(() => {
            $xeTable.updateCellAreas();
            $xeTable.recalculate();
          }).then(() => {
            return {
              status: true
            };
          });
        }).catch(() => {
          return errRest;
        });
      }
    }
    return Promise.resolve(errRest);
  },
  handleRowDragDragendEvent(evnt) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData,
      prevDragToChild
    } = internalData;
    const {
      dragRow
    } = reactData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      lazy
    } = treeOpts;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const {
      prevDragRow,
      prevDragPos
    } = internalData;
    if (treeConfig && lazy && prevDragToChild) {
      // 懒加载
      const newRowid = getRowid($xeTable, prevDragRow);
      const rowRest = fullAllDataRowIdData[newRowid];
      if (prevDragRow[hasChildField]) {
        if (rowRest && rowRest.treeLoaded) {
          $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
        }
      } else {
        $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
      }
    } else {
      $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
    }
    hideDropTip($xeTable);
    clearRowDropOrigin($xeTable);
    internalData.prevDragToChild = false;
    reactData.dragRow = null;
    reactData.dragCol = null;
    setTimeout(() => {
      reactData.isDragRowMove = false;
    }, 500);
  },
  handleRowDragDragoverEvent(evnt) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const reactData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      fullAllDataRowIdData
    } = internalData;
    const {
      dragRow
    } = reactData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      lazy,
      transform,
      parentField
    } = treeOpts;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowDragOpts = $xeTable.computeRowDragOpts;
    const {
      isPeerDrag,
      isCrossDrag,
      isToChildDrag
    } = rowDragOpts;
    if (!dragRow) {
      evnt.preventDefault();
      return;
    }
    const isControlKey = hasControlKey(evnt);
    const trEl = evnt.currentTarget;
    const rowid = trEl.getAttribute('rowid') || '';
    const rest = fullAllDataRowIdData[rowid];
    if (rest) {
      const row = rest.row;
      const rowid = getRowid($xeTable, row);
      const rowRest = fullAllDataRowIdData[rowid];
      evnt.preventDefault();
      const {
        dragRow
      } = reactData;
      const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
      const dragPos = offsetY < trEl.clientHeight / 2 ? 'top' : 'bottom';
      internalData.prevDragToChild = !!(treeConfig && transform && isToChildDrag && isControlKey);
      internalData.prevDragRow = row;
      internalData.prevDragPos = dragPos;
      if ($xeTable.eqRow(dragRow, row) || isControlKey && treeConfig && lazy && row[hasChildField] && rowRest && !rowRest.treeLoaded || !isCrossDrag && treeConfig && transform && (isPeerDrag ? dragRow[parentField] !== row[parentField] : rest.level)) {
        showDropTip($xeTable, evnt, trEl, null, false, dragPos);
        return;
      }
      showDropTip($xeTable, evnt, trEl, null, true, dragPos);
      $xeTable.dispatchEvent('row-dragover', {
        oldRow: dragRow,
        targetRow: row,
        dragPos
      }, evnt);
    }
  },
  handleCellDragMousedownEvent(evnt, params) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    evnt.stopPropagation();
    const {
      dragConfig
    } = props;
    const rowDragOpts = $xeTable.computeRowDragOpts;
    const {
      trigger,
      dragStartMethod
    } = rowDragOpts;
    const {
      row
    } = params;
    const dragEl = evnt.currentTarget;
    const tdEl = trigger === 'cell' || trigger === 'row' ? dragEl : dragEl.parentElement?.parentElement;
    const trEl = tdEl.parentElement;
    const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
    reactData.isDragRowMove = false;
    clearRowDropOrigin($xeTable);
    if (dStartMethod && !dStartMethod(params)) {
      trEl.draggable = false;
      reactData.dragRow = null;
      reactData.dragCol = null;
      hideDropTip($xeTable);
      return;
    }
    reactData.dragRow = row;
    reactData.dragCol = null;
    trEl.draggable = true;
    updateRowDropOrigin($xeTable, row);
    updateRowDropTipContent($xeTable, tdEl);
    $xeTable.dispatchEvent('row-dragstart', params, evnt);
  },
  handleCellDragMouseupEvent() {
    const $xeTable = this;
    clearDragStatus($xeTable);
  },
  /**
   * 列拖拽
   */
  handleHeaderCellDragDragstartEvent(evnt) {
    if (evnt.dataTransfer) {
      evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
    }
  },
  handleColDragSwapColumn() {
    const $xeTable = this;
    handleUpdateColumn($xeTable);
    parseColumns($xeTable, false).then(() => {
      $xeTable.updateCellAreas();
      $xeTable.saveCustomStore('update:sort');
    });
  },
  handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      mouseConfig
    } = props;
    const columnDragOpts = $xeTable.computeColumnDragOpts;
    const {
      isPeerDrag,
      isCrossDrag,
      isSelfToChildDrag,
      isToChildDrag,
      dragEndMethod,
      dragToChildMethod
    } = columnDragOpts;
    const {
      collectColumn
    } = internalData;
    const dragOffsetIndex = prevDragPos === 'right' ? 1 : 0;
    const errRest = {
      status: false
    };
    if (prevDragCol && dragCol) {
      // 判断是否有拖动
      if (prevDragCol !== dragCol) {
        const dragColumn = dragCol;
        const newColumn = prevDragCol;
        const dragParams = {
          oldColumn: dragColumn,
          newColumn,
          dragColumn,
          dragPos: prevDragPos,
          dragToChild: !!prevDragToChild,
          offsetIndex: dragOffsetIndex
        };
        const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
        return Promise.resolve(dragEndMethod ? dragEndMethod(dragParams) : true).then(status => {
          if (!status) {
            return errRest;
          }
          let oafIndex = -1;
          let nafIndex = -1;
          const oldAllMaps = {};
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn], column => {
            oldAllMaps[column.id] = column;
          });
          let isSelfToChildStatus = false;
          if (dragColumn.parentId && newColumn.parentId) {
            // 子到子
            if (isPeerDrag && !isCrossDrag) {
              if (dragColumn.parentId !== newColumn.parentId) {
                // 非同级
                return errRest;
              }
            } else {
              if (!isCrossDrag) {
                return errRest;
              }
              if (oldAllMaps[newColumn.id]) {
                isSelfToChildStatus = true;
                if (!(isCrossDrag && isSelfToChildDrag)) {
                  if (core_.VxeUI.modal) {
                    core_.VxeUI.modal.message({
                      status: 'error',
                      content: methods_getI18n('vxe.error.treeDragChild')
                    });
                  }
                  return errRest;
                }
              }
            }
          } else if (dragColumn.parentId) {
            // 子到根
            if (!isCrossDrag) {
              return errRest;
            }
          } else if (newColumn.parentId) {
            // 根到子
            if (!isCrossDrag) {
              return errRest;
            }
            if (oldAllMaps[newColumn.id]) {
              isSelfToChildStatus = true;
              if (!(isCrossDrag && isSelfToChildDrag)) {
                if (core_.VxeUI.modal) {
                  core_.VxeUI.modal.message({
                    status: 'error',
                    content: methods_getI18n('vxe.error.treeDragChild')
                  });
                }
                return errRest;
              }
            }
          } else {
            // 根到根
          }
          const oldewMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === dragColumn.id);
          // 改变层级
          if (isSelfToChildStatus && isCrossDrag && isSelfToChildDrag) {
            if (oldewMatchRest) {
              const {
                items: oCols,
                index: oIndex
              } = oldewMatchRest;
              const childList = dragColumn.children || [];
              childList.forEach(column => {
                column.parentId = dragColumn.parentId;
              });
              oCols.splice(oIndex, 1, ...childList);
              dragColumn.children = [];
            }
          } else {
            if (oldewMatchRest) {
              const {
                items: oCols,
                index: oIndex,
                parent: oParent
              } = oldewMatchRest;
              oCols.splice(oIndex, 1);
              if (!oParent) {
                oafIndex = oIndex;
              }
            }
          }
          const newMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === newColumn.id);
          if (newMatchRest) {
            const {
              items: nCols,
              index: nIndex,
              parent: nParent
            } = newMatchRest;
            // 转子级
            if (isCrossDrag && isToChildDrag && isDragToChildFlag) {
              dragColumn.parentId = newColumn.id;
              newColumn.children = (newColumn.children || []).concat([dragColumn]);
            } else {
              dragColumn.parentId = newColumn.parentId;
              nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
            }
            if (!nParent) {
              nafIndex = nIndex;
            }
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parentColumn) => {
            if (!parentColumn) {
              const sortIndex = index + 1;
              column.renderSortNumber = sortIndex;
            }
          });
          reactData.isDragColMove = true;
          if (mouseConfig) {
            if ($xeTable.clearSelected) {
              $xeTable.clearSelected();
            }
            if ($xeTable.clearCellAreas) {
              $xeTable.clearCellAreas();
              $xeTable.clearCopyCellArea();
            }
          }
          if (evnt) {
            $xeTable.dispatchEvent('column-dragend', {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              dragToChild: isDragToChildFlag,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
          }
          if (isSyncColumn) {
            $xeTable.handleColDragSwapColumn();
          }
          return {
            status: true
          };
        }).catch(() => {
          return errRest;
        });
      }
    }
    return Promise.resolve(errRest);
  },
  handleHeaderCellDragDragendEvent(evnt) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      dragCol
    } = reactData;
    const {
      prevDragCol,
      prevDragPos,
      prevDragToChild
    } = internalData;
    $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
    hideDropTip($xeTable);
    clearColDropOrigin($xeTable);
    internalData.prevDragToChild = false;
    reactData.dragRow = null;
    reactData.dragCol = null;
    setTimeout(() => {
      reactData.isDragColMove = false;
      $xeTable.recalculate().then(() => {
        loadScrollXData($xeTable);
      });
    }, 500);
  },
  handleHeaderCellDragDragoverEvent(evnt) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      dragCol
    } = reactData;
    const columnDragOpts = $xeTable.computeColumnDragOpts;
    const {
      isToChildDrag,
      isPeerDrag,
      isCrossDrag
    } = columnDragOpts;
    if (!dragCol) {
      evnt.preventDefault();
      return;
    }
    const isControlKey = hasControlKey(evnt);
    const thEl = evnt.currentTarget;
    const colid = thEl.getAttribute('colid');
    const column = $xeTable.getColumnById(colid);
    if (column) {
      evnt.preventDefault();
      const {
        clientX
      } = evnt;
      const offsetX = clientX - thEl.getBoundingClientRect().x;
      const dragPos = offsetX < thEl.clientWidth / 2 ? 'left' : 'right';
      internalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey);
      internalData.prevDragCol = column;
      internalData.prevDragPos = dragPos;
      if (column.fixed || dragCol && dragCol.id === column.id || !isCrossDrag && (isPeerDrag ? dragCol.parentId !== column.parentId : column.parentId)) {
        showDropTip($xeTable, evnt, null, thEl, false, dragPos);
        return;
      }
      showDropTip($xeTable, evnt, null, thEl, true, dragPos);
      $xeTable.dispatchEvent('column-dragover', {
        oldColumn: dragCol,
        targetColumn: column,
        dragPos
      }, evnt);
      // 边缘滚动
      const el = $xeTable.$refs.refElem;
      if (!el) {
        return;
      }
      const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
      const refTableBody = $xeTable.$refs.refTableBody;
      const tableBodyElem = refTableBody ? refTableBody.$el : null;
      const scrollTargetEl = xHandleEl || tableBodyElem;
      if (scrollTargetEl) {
        const wrapperRect = el.getBoundingClientRect();
        const tableWrapperWidth = el.clientWidth;
        const leftContainerElem = $xeTable.$refs.refLeftContainer;
        const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
        const rightContainerElem = $xeTable.$refs.refRightContainer;
        const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
        const srartX = wrapperRect.x + leftContainerWidth;
        const endX = wrapperRect.x + tableWrapperWidth - rightContainerWidth;
        const distSize = 28;
        const startDistSize = clientX - srartX;
        const endDistSize = endX - clientX;
        if (startDistSize > 0 && startDistSize <= distSize) {
          const scrollRatio = Math.floor(tableWrapperWidth / (startDistSize > distSize / 2 ? 240 : 120));
          scrollTargetEl.scrollLeft -= scrollRatio * (distSize - startDistSize);
        } else if (endDistSize > 0 && endDistSize <= distSize) {
          const scrollRatio = Math.floor(tableWrapperWidth / (endDistSize > distSize / 2 ? 240 : 120));
          scrollTargetEl.scrollLeft += scrollRatio * (distSize - endDistSize);
        }
      }
    }
  },
  handleHeaderCellDragMousedownEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    evnt.stopPropagation();
    const columnDragOpts = $xeTable.computeColumnDragOpts;
    const {
      trigger,
      dragStartMethod
    } = columnDragOpts;
    const {
      column
    } = params;
    const dragEl = evnt.currentTarget;
    const thEl = trigger === 'cell' ? dragEl : dragEl.parentElement?.parentElement;
    reactData.isDragColMove = false;
    clearColDropOrigin($xeTable);
    if (dragStartMethod && !dragStartMethod(params)) {
      thEl.draggable = false;
      reactData.dragRow = null;
      reactData.dragCol = null;
      hideDropTip($xeTable);
      return;
    }
    reactData.dragCol = column;
    reactData.dragRow = null;
    thEl.draggable = true;
    updateColDropOrigin($xeTable, column);
    updateColDropTipContent($xeTable, thEl);
    $xeTable.dispatchEvent('column-dragstart', params, evnt);
  },
  handleHeaderCellDragMouseupEvent() {
    const $xeTable = this;
    const reactData = $xeTable;
    clearColDropOrigin($xeTable);
    hideDropTip($xeTable);
    reactData.dragRow = null;
    reactData.dragCol = null;
    reactData.isDragColMove = false;
  },
  setPendingRow(rows, status) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    const {
      pendingRowMaps
    } = internalData;
    if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
      rows = [rows];
    }
    if (status) {
      rows.forEach(row => {
        const rowid = handleGetRowId(row);
        if (rowid && !pendingRowMaps[rowid]) {
          pendingRowMaps[rowid] = row;
        }
      });
    } else {
      rows.forEach(row => {
        const rowid = handleGetRowId(row);
        if (rowid && pendingRowMaps[rowid]) {
          delete pendingRowMaps[rowid];
        }
      });
    }
    reactData.pendingRowFlag++;
    return $xeTable.$nextTick();
  },
  togglePendingRow(rows) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    const {
      pendingRowMaps
    } = internalData;
    if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
      rows = [rows];
    }
    rows.forEach(row => {
      const rowid = handleGetRowId(row);
      if (rowid) {
        if (pendingRowMaps[rowid]) {
          delete pendingRowMaps[rowid];
        } else {
          pendingRowMaps[rowid] = row;
        }
      }
    });
    reactData.pendingRowFlag++;
    return $xeTable.$nextTick();
  },
  hasPendingByRow(row) {
    const $xeTable = this;
    return $xeTable.isPendingByRow(row);
  },
  isPendingByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      pendingRowMaps
    } = reactData;
    const rowid = getRowid($xeTable, row);
    return !!pendingRowMaps[rowid];
  },
  getPendingRecords() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData,
      pendingRowMaps
    } = internalData;
    const insertRecords = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(pendingRowMaps, (row, rowid) => {
      if (fullAllDataRowIdData[rowid]) {
        insertRecords.push(row);
      }
    });
    return insertRecords;
  },
  clearPendingRow() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    internalData.pendingRowMaps = {};
    reactData.pendingRowFlag++;
    return $xeTable.$nextTick();
  },
  sort(sortConfs, sortOrder) {
    const $xeTable = this;
    const sortOpts = $xeTable.computeSortOpts;
    const {
      multiple,
      remote,
      orders
    } = sortOpts;
    if (sortConfs) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(sortConfs)) {
        sortConfs = [{
          field: sortConfs,
          order: sortOrder
        }];
      }
    }
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)) {
      sortConfs = [sortConfs];
    }
    if (sortConfs.length) {
      let firstSortColumn;
      if (!multiple) {
        clearAllSort($xeTable);
      }
      (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
        let {
          field,
          order
        } = confs;
        let column = field;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)) {
          column = $xeTable.getColumnByField(field);
        }
        if (column && (column.sortable || column.remoteSort)) {
          if (!firstSortColumn) {
            firstSortColumn = column;
          }
          if (orders && orders.indexOf(order) === -1) {
            order = getNextSortOrder($xeTable, column);
          }
          if (column.order !== order) {
            column.order = order;
          }
          column.sortTime = Date.now() + index;
        }
      });
      // 如果是服务端排序，则跳过本地排序处理
      if (!remote || firstSortColumn && firstSortColumn.remoteSort) {
        $xeTable.handleTableData(true);
      }
      return $xeTable.$nextTick().then(() => {
        updateRowOffsetTop($xeTable);
        $xeTable.updateCellAreas();
        return updateStyle($xeTable);
      });
    }
    return $xeTable.$nextTick();
  },
  setSort(sortConfs, isUpdate) {
    const $xeTable = this;
    // 已废弃，即将去掉事件触发 new Event('click') -> null
    return handleSortEvent($xeTable, new Event('click'), sortConfs, isUpdate);
  },
  setSortByEvent(evnt, sortConfs, isUpdate) {
    const $xeTable = this;
    return handleSortEvent($xeTable, evnt, sortConfs, isUpdate);
  },
  /**
   * 清空指定列的排序条件
   * 如果为空则清空所有列的排序条件
   * @param {String} column 列或字段名
   */
  clearSort(fieldOrColumn) {
    const $xeTable = this;
    const sortOpts = $xeTable.computeSortOpts;
    if (fieldOrColumn) {
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column) {
        column.order = null;
      }
    } else {
      clearAllSort($xeTable);
    }
    if (!sortOpts.remote) {
      $xeTable.handleTableData(true);
    }
    return $xeTable.$nextTick().then(() => {
      updateRowOffsetTop($xeTable);
      return updateStyle($xeTable);
    });
  },
  clearSortByEvent(evnt, fieldOrColumn) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      tableFullColumn
    } = internalData;
    const sortOpts = $xeTable.computeSortOpts;
    const sortCols = [];
    let column = null;
    if (evnt) {
      if (fieldOrColumn) {
        column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          column.order = null;
        }
      } else {
        tableFullColumn.forEach(column => {
          if (column.order) {
            column.order = null;
            sortCols.push(column);
          }
        });
      }
      if (!sortOpts.remote) {
        $xeTable.handleTableData(true);
      }
      if (sortCols.length) {
        const params = {
          $table: $xeTable,
          $event: evnt,
          cols: sortCols,
          sortList: []
        };
        $xeTable.dispatchEvent('clear-all-sort', params, evnt);
      } else if (column) {
        $xeTable.handleColumnSortEvent(evnt, column);
      }
    }
    return $xeTable.$nextTick().then(() => {
      updateRowOffsetTop($xeTable);
      return updateStyle($xeTable);
    });
  },
  // 在 v3 中废弃
  getSortColumn() {
    warnLog('vxe.error.delFunc', ['getSortColumn', 'getSortColumns']);
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(this.tableFullColumn, column => (column.sortable || column.remoteSort) && column.order);
  },
  isSort(fieldOrColumn) {
    if (fieldOrColumn) {
      const column = handleFieldOrColumn(this, fieldOrColumn);
      return column && column.sortable && !!column.order;
    }
    return this.getSortColumns().length > 0;
  },
  getSortColumns() {
    const {
      multiple,
      chronological
    } = this.sortOpts;
    const sortList = [];
    this.tableFullColumn.forEach(column => {
      const {
        field,
        order
      } = column;
      if ((column.sortable || column.remoteSort) && order) {
        sortList.push({
          column,
          field,
          property: field,
          order,
          sortTime: column.sortTime
        });
      }
    });
    if (multiple && chronological && sortList.length > 1) {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(sortList, 'sortTime');
    }
    return sortList;
  },
  setFilterByEvent(evnt, fieldOrColumn, options, isUpdate) {
    const $xeTable = this;
    const column = handleFieldOrColumn($xeTable, fieldOrColumn);
    if (column && column.filters) {
      column.filters = toFilters(options || []);
      if (isUpdate) {
        return $xeTable.handleColumnConfirmFilter(column, evnt);
      }
    }
    return $xeTable.$nextTick();
  },
  /**
   * 关闭筛选
   * @param {Event} evnt 事件
   */
  closeFilter() {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      filterStore
    } = reactData;
    const {
      column,
      visible
    } = filterStore;
    filterStore.isAllSelected = false;
    filterStore.isIndeterminate = false;
    filterStore.options = [];
    filterStore.visible = false;
    if (visible) {
      $xeTable.dispatchEvent('filter-visible', {
        column,
        field: column.field,
        property: column.field,
        filterList: () => $xeTable.getCheckedFilters(),
        visible: false
      }, null);
    }
    return $xeTable.$nextTick();
  },
  /**
   * 判断指定列是否为筛选状态，如果为空则判断所有列
   * @param {String} fieldOrColumn 字段名
   */
  isActiveFilterByColumn(fieldOrColumn) {
    const column = handleFieldOrColumn(this, fieldOrColumn);
    if (column) {
      return column.filters && column.filters.some(option => option.checked);
    }
    return this.getCheckedFilters().length > 0;
  },
  // 已废弃
  isFilter(fieldOrColumn) {
    return this.isActiveFilterByColumn(fieldOrColumn);
  },
  clearFilterByEvent(evnt, fieldOrColumn) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      filterStore
    } = reactData;
    const {
      tableFullColumn
    } = internalData;
    const filterOpts = $xeTable.computeFilterOpts;
    const filterCols = [];
    let column = null;
    if (fieldOrColumn) {
      column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column) {
        $xeTable.handleClearFilter(column);
      }
    } else {
      tableFullColumn.forEach(column => {
        if (column.filters) {
          filterCols.push(column);
          $xeTable.handleClearFilter(column);
        }
      });
    }
    if (!fieldOrColumn || column !== filterStore.column) {
      Object.assign(filterStore, {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false
      });
    }
    if (!filterOpts.remote) {
      $xeTable.updateData();
    }
    if (filterCols.length) {
      const params = {
        $table: $xeTable,
        $event: evnt,
        cols: filterCols,
        filterList: []
      };
      $xeTable.dispatchEvent('clear-all-filter', params, evnt);
    } else if (column) {
      $xeTable.dispatchEvent('clear-filter', {
        filterList: () => $xeTable.getCheckedFilters()
      }, evnt);
    }
    return $xeTable.$nextTick();
  },
  /**
   * 判断展开行是否懒加载完成
   * @param {Row} row 行对象
   */
  isRowExpandLoaded(row) {
    const $xeTable = this;
    const {
      fullAllDataRowIdData
    } = this;
    const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
    return rowRest && !!rowRest.expandLoaded;
  },
  clearRowExpandLoaded(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData,
      rowExpandLazyLoadedMaps
    } = internalData;
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      lazy
    } = expandOpts;
    const rowid = getRowid($xeTable, row);
    const rowRest = fullAllDataRowIdData[rowid];
    if (lazy && rowRest) {
      rowRest.expandLoaded = false;
      delete rowExpandLazyLoadedMaps[rowid];
    }
    reactData.rowExpandedFlag++;
    return $xeTable.$nextTick();
  },
  /**
   * 重新懒加载展开行，并展开内容
   * @param {Row} row 行对象
   */
  reloadRowExpand(row) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      rowExpandLazyLoadedMaps
    } = internalData;
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      lazy
    } = expandOpts;
    const rowid = getRowid(this, row);
    if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
      $xeTable.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand($xeTable, row));
    }
    return $xeTable.$nextTick();
  },
  reloadExpandContent(row) {
    warnLog('vxe.error.delFunc', ['reloadExpandContent', 'reloadRowExpand']);
    // 即将废弃
    return this.reloadRowExpand(row);
  },
  /**
   * 展开行事件
   */
  triggerRowExpandEvent(evnt, params) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      expandColumn
    } = reactData;
    const {
      rowExpandLazyLoadedMaps
    } = internalData;
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      row
    } = params;
    const {
      lazy,
      trigger
    } = expandOpts;
    if (trigger === 'manual') {
      return;
    }
    evnt.stopPropagation();
    const rowid = getRowid($xeTable, row);
    if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
      const expanded = !$xeTable.isRowExpandByRow(row);
      const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
      const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
      $xeTable.setRowExpand(row, expanded);
      $xeTable.dispatchEvent('toggle-row-expand', {
        expanded,
        column: expandColumn,
        columnIndex,
        $columnIndex,
        row,
        rowIndex: $xeTable.getRowIndex(row),
        $rowIndex: $xeTable.getVMRowIndex(row)
      }, evnt);
    }
  },
  /**
   * 切换展开行
   */
  toggleRowExpand(row) {
    return this.setRowExpand(row, !this.isRowExpandByRow(row));
  },
  /**
   * 设置所有行的展开与否
   * @param {Boolean} expanded 是否展开
   */
  setAllRowExpand(expanded) {
    const {
      treeConfig,
      treeOpts,
      tableFullData,
      tableFullTreeData
    } = this;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    let expandedRows = [];
    if (treeConfig) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, row => {
        expandedRows.push(row);
      }, {
        children: childrenField
      });
    } else {
      expandedRows = tableFullData;
    }
    return this.setRowExpand(expandedRows, expanded);
  },
  /**
   * 设置展开行，二个参数设置这一行展开与否
   * 支持单行
   * 支持多行
   * @param {Array/Row} rows 行数据
   * @param {Boolean} expanded 是否展开
   */
  setRowExpand(rows, expanded) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      expandColumn
    } = reactData;
    let {
      fullAllDataRowIdData,
      rowExpandedMaps,
      rowExpandLazyLoadedMaps
    } = internalData;
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      reserve,
      lazy,
      accordion,
      toggleMethod
    } = expandOpts;
    const lazyRests = [];
    const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
    const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
    if (rows) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      if (accordion) {
        // 只能同时展开一个
        rowExpandedMaps = {};
        internalData.rowExpandedMaps = rowExpandedMaps;
        rows = rows.slice(rows.length - 1, rows.length);
      }
      const validRows = toggleMethod ? rows.filter(row => toggleMethod({
        $table: $xeTable,
        expanded,
        column: expandColumn,
        columnIndex,
        $columnIndex,
        row,
        rowIndex: $xeTable.getRowIndex(row),
        $rowIndex: $xeTable.getVMRowIndex(row)
      })) : rows;
      if (expanded) {
        validRows.forEach(row => {
          const rowid = handleGetRowId(row);
          if (!rowExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
            if (isLoad) {
              lazyRests.push(handleAsyncRowExpand($xeTable, row));
            } else {
              rowExpandedMaps[rowid] = row;
            }
          }
        });
      } else {
        validRows.forEach(item => {
          const rowid = handleGetRowId(item);
          if (rowExpandedMaps[rowid]) {
            delete rowExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach(row => handleRowExpandReserve($xeTable, row, expanded));
      }
    }
    reactData.rowExpandedFlag++;
    return Promise.all(lazyRests).then(() => $xeTable.$nextTick()).then(() => $xeTable.recalculate(true)).then(() => {
      updateRowOffsetTop($xeTable);
      updateRowExpandStyle($xeTable);
      handleRowExpandScroll($xeTable);
      return $xeTable.updateCellAreas();
    });
  },
  /**
   * 判断行是否为展开状态
   * @param {Row} row 行对象
   */
  isRowExpandByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      rowExpandedFlag
    } = reactData;
    const {
      rowExpandedMaps
    } = internalData;
    const rowid = getRowid(this, row);
    return !!rowExpandedFlag && !!rowExpandedMaps[rowid];
  },
  isExpandByRow(row) {
    warnLog('vxe.error.delFunc', ['isExpandByRow', 'isRowExpandByRow']);
    // 即将废弃
    return this.isRowExpandByRow(row);
  },
  /**
   * 手动清空展开行状态，数据会恢复成未展开的状态
   */
  clearRowExpand() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      tableFullData
    } = internalData;
    const expandOpts = $xeTable.computeExpandOpts;
    const {
      reserve
    } = expandOpts;
    const expList = $xeTable.getRowExpandRecords();
    internalData.rowExpandedMaps = {};
    reactData.rowExpandedFlag++;
    if (reserve) {
      tableFullData.forEach(row => handleRowExpandReserve($xeTable, row, false));
    }
    return $xeTable.$nextTick().then(() => {
      if (expList.length) {
        return $xeTable.recalculate(true);
      }
    }).then(() => {
      updateRowOffsetTop($xeTable);
      updateRowExpandStyle($xeTable);
      handleRowExpandScroll($xeTable);
      return $xeTable.updateCellAreas();
    });
  },
  clearRowExpandReserve() {
    this.rowExpandedReserveRowMap = {};
    return this.$nextTick();
  },
  getRowExpandRecords() {
    const $xeTable = this;
    const internalData = $xeTable;
    const rest = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.rowExpandedMaps, item => {
      if (item) {
        rest.push(item);
      }
    });
    return rest;
  },
  setRowGroups(fieldOrColumns) {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      aggregateConfig,
      rowGroupConfig
    } = props;
    if (!(aggregateConfig || rowGroupConfig)) {
      errLog('vxe.error.reqProp', ['aggregate-config']);
      return $xeTable.$nextTick();
    }
    if (fieldOrColumns) {
      handleUpdateRowGroup($xeTable, (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumns) ? fieldOrColumns : [fieldOrColumns]).map(fieldOrColumn => {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? fieldOrColumn : fieldOrColumn.field;
      }));
      return loadTableData($xeTable, internalData.tableSynchData, true);
    }
    return $xeTable.$nextTick();
  },
  clearRowGroups() {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    const {
      aggregateConfig,
      rowGroupConfig
    } = props;
    if (!(aggregateConfig || rowGroupConfig)) {
      errLog('vxe.error.reqProp', ['aggregate-config']);
      return $xeTable.$nextTick();
    }
    handleUpdateRowGroup($xeTable, []);
    return loadTableData($xeTable, internalData.tableSynchData, true);
  },
  isRowGroupRecord(row) {
    const $xeTable = this;
    warnLog('vxe.error.delFunc', ['isRowGroupRecord', 'isAggregateRecord']);
    return $xeTable.isAggregateRecord(row);
  },
  isRowGroupExpandByRow(row) {
    const $xeTable = this;
    warnLog('vxe.error.delFunc', ['isRowGroupExpandByRow', 'isAggregateExpandByRow']);
    return $xeTable.isAggregateExpandByRow(row);
  },
  isAggregateRecord(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      isRowGroupStatus
    } = reactData;
    return isRowGroupStatus && row.isAggregate;
  },
  isAggregateExpandByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      rowGroupExpandedFlag
    } = reactData;
    const {
      rowGroupExpandedMaps
    } = internalData;
    return !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[getRowid($xeTable, row)];
  },
  setRowGroupExpand(rows, expanded) {
    const $xeTable = this;
    if (rows) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      return handleRowGroupVirtualExpand($xeTable, rows, expanded);
    }
    return $xeTable.$nextTick();
  },
  setAllRowGroupExpand(expanded) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      tableFullGroupData
    } = internalData;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const {
      mapChildrenField
    } = aggregateOpts;
    const rgExpandedMaps = {};
    if (expanded && mapChildrenField) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData, row => {
        if (row[mapChildrenField] && row[mapChildrenField].length) {
          rgExpandedMaps[getRowid($xeTable, row)] = row;
        }
      }, {
        children: mapChildrenField
      });
    }
    internalData.rowGroupExpandedMaps = rgExpandedMaps;
    handleVirtualTreeToList($xeTable);
    reactData.rowGroupExpandedFlag++;
    return $xeTable.handleTableData();
  },
  clearRowGroupExpand() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    internalData.rowGroupExpandedMaps = {};
    handleVirtualTreeToList($xeTable);
    reactData.rowGroupExpandedFlag++;
    return $xeTable.handleTableData();
  },
  getTreeExpandRecords() {
    const $xeTable = this;
    const internalData = $xeTable;
    const rest = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.treeExpandedMaps, item => {
      if (item) {
        rest.push(item);
      }
    });
    return rest;
  },
  /**
   * 内部方法、获取树表格状态
   * @deprecated
   * @private
   */
  getTreeStatus() {
    if (this.treeConfig) {
      return {
        config: this.treeOpts,
        rowExpandeds: this.getTreeExpandRecords()
      };
    }
    return null;
  },
  /**
   * 判断树节点是否懒加载完成
   * @param {Row} row 行对象
   */
  isTreeExpandLoaded(row) {
    const $xeTable = this;
    const {
      fullAllDataRowIdData
    } = this;
    const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
    return rowRest && !!rowRest.treeLoaded;
  },
  clearTreeExpandLoaded(rows) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      fullAllDataRowIdData,
      treeExpandedMaps
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform
    } = treeOpts;
    if (rows) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      rows.forEach(row => {
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          rowRest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
      });
    } else {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(fullAllDataRowIdData, rowRest => {
        rowRest.treeLoaded = false;
      });
    }
    internalData.treeExpandedMaps = {};
    if (transform) {
      handleVirtualTreeToList($xeTable);
      $xeTable.handleTableData();
    }
    reactData.treeExpandedFlag++;
    return $xeTable.$nextTick();
  },
  /**
   * 重新懒加载树节点，并展开该节点
   * @param {Row} row 行对象
   */
  reloadTreeExpand(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeExpandLazyLoadedMaps
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      lazy
    } = treeOpts;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowid = getRowid($xeTable, row);
    if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
      return $xeTable.clearTreeExpandLoaded(row).then(() => {
        return handleAsyncTreeExpandChilds($xeTable, row);
      }).then(() => {
        if (transform) {
          handleVirtualTreeToList($xeTable);
          $xeTable.handleTableData();
        }
        reactData.treeExpandedFlag++;
      }).then(() => {
        return $xeTable.recalculate();
      });
    }
    return $xeTable.$nextTick();
  },
  reloadTreeChilds(row) {
    const $xeTable = this;
    warnLog('vxe.error.delFunc', ['reloadTreeChilds', 'reloadTreeExpand']);
    // 即将废弃
    return $xeTable.reloadTreeExpand(row);
  },
  /**
   * 行分组事件
   */
  triggerRowGroupExpandEvent(evnt, params) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      rowGroupExpandedMaps
    } = internalData;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const {
      row,
      column
    } = params;
    const {
      trigger
    } = aggregateOpts;
    if (trigger === 'manual') {
      return;
    }
    evnt.stopPropagation();
    const rowid = getRowid($xeTable, row);
    const expanded = !rowGroupExpandedMaps[rowid];
    const columnIndex = $xeTable.getColumnIndex(column);
    const $columnIndex = $xeTable.getVMColumnIndex(column);
    $xeTable.setRowGroupExpand(row, expanded);
    $xeTable.dispatchEvent('toggle-row-group-expand', {
      expanded,
      column,
      columnIndex,
      $columnIndex,
      row
    }, evnt);
  },
  /**
   * 展开树节点事件
   */
  triggerTreeExpandEvent(evnt, params) {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      treeExpandLazyLoadedMaps,
      treeEATime
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      row,
      column
    } = params;
    const {
      lazy,
      trigger,
      accordion
    } = treeOpts;
    if (trigger === 'manual') {
      return;
    }
    evnt.stopPropagation();
    const rowid = getRowid(this, row);
    if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
      const expanded = !$xeTable.isTreeExpandByRow(row);
      const columnIndex = $xeTable.getColumnIndex(column);
      const $columnIndex = $xeTable.getVMColumnIndex(column);
      if (treeEATime) {
        clearTimeout(treeEATime);
      }
      $xeTable.setTreeExpand(row, expanded).then(() => {
        if (accordion) {
          internalData.treeEATime = setTimeout(() => {
            internalData.treeEATime = undefined;
            $xeTable.scrollToRow(row);
          }, 30);
        }
      });
      $xeTable.dispatchEvent('toggle-tree-expand', {
        expanded,
        column,
        columnIndex,
        $columnIndex,
        row
      }, evnt);
    }
  },
  /**
   * 切换/展开树节点
   */
  toggleTreeExpand(row) {
    return this.setTreeExpand(row, !this.isTreeExpandByRow(row));
  },
  /**
   * 设置所有树节点的展开与否
   * @param {Boolean} expanded 是否展开
   */
  setAllTreeExpand(expanded) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      tableFullData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const {
      transform,
      lazy
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const expandeds = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData, row => {
      const rowChildren = row[childrenField];
      if (lazy || rowChildren && rowChildren.length) {
        expandeds.push(row);
      }
    }, {
      children: childrenField
    });
    return $xeTable.setTreeExpand(expandeds, expanded).then(() => {
      if (transform) {
        handleVirtualTreeToList($xeTable);
        reactData.treeExpandedFlag++;
        return $xeTable.recalculate();
      }
    });
  },
  /**
   * 设置展开树形节点，二个参数设置这一行展开与否
   * 支持单行
   * 支持多行
   * @param {Array/Row} rows 行数据
   * @param {Boolean} expanded 是否展开
   */
  setTreeExpand(rows, expanded) {
    const $xeTable = this;
    const {
      treeOpts
    } = this;
    const {
      transform
    } = treeOpts;
    if (rows) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      if (rows.length) {
        // 如果为虚拟树
        if (transform) {
          return handleVirtualTreeExpand($xeTable, rows, expanded);
        } else {
          return handleBaseTreeExpand($xeTable, rows, expanded);
        }
      }
    }
    return this.$nextTick();
  },
  /**
   * 判断行是否为树形节点展开状态
   * @param {Row} row 行对象
   */
  isTreeExpandByRow(row) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeExpandedFlag
    } = reactData;
    const {
      treeExpandedMaps
    } = internalData;
    return !!treeExpandedFlag && !!treeExpandedMaps[getRowid($xeTable, row)];
  },
  /**
   * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
   */
  clearTreeExpand() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      tableFullTreeData
    } = internalData;
    const treeOpts = $xeTable.computeTreeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const {
      transform,
      reserve
    } = treeOpts;
    const expList = $xeTable.getTreeExpandRecords();
    internalData.treeExpandedMaps = {};
    if (reserve) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, row => handleTreeExpandReserve($xeTable, row, false), {
        children: childrenField
      });
    }
    return $xeTable.handleTableData().then(() => {
      if (transform) {
        handleVirtualTreeToList($xeTable);
        $xeTable.handleTableData();
      }
      reactData.treeExpandedFlag++;
    }).then(() => {
      if (expList.length) {
        $xeTable.recalculate();
      }
    });
  },
  clearTreeExpandReserve() {
    this.treeExpandedReserveRowMap = {};
    return this.$nextTick();
  },
  /**
   * 获取表格的滚动状态
   */
  getScroll() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollXLoad,
      scrollYLoad
    } = reactData;
    const {
      elemStore
    } = internalData;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    return {
      virtualX: scrollXLoad,
      virtualY: scrollYLoad,
      scrollTop: bodyScrollElem ? bodyScrollElem.scrollTop : 0,
      scrollLeft: bodyScrollElem ? bodyScrollElem.scrollLeft : 0
    };
  },
  handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      highlightHoverRow
    } = props;
    const {
      lastScrollLeft,
      lastScrollTop
    } = internalData;
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    if (!xHandleEl || !yHandleEl) {
      return;
    }
    const rowOpts = $xeTable.computeRowOpts;
    const validTip = $xeTable.$refs.refValidTooltip;
    const tooltip = $xeTable.$refs.refTooltip;
    const bodyHeight = yHandleEl.clientHeight;
    const bodyWidth = xHandleEl.clientWidth;
    const scrollHeight = yHandleEl.scrollHeight;
    const scrollWidth = xHandleEl.scrollWidth;
    let isTop = false;
    let isBottom = false;
    let isLeft = false;
    let isRight = false;
    let direction = '';
    let isTopBoundary = false;
    let isBottomBoundary = false;
    let isLeftBoundary = false;
    let isRightBoundary = false;
    if (isRollX) {
      const xThreshold = $xeTable.computeScrollXThreshold;
      isLeft = scrollLeft <= 0;
      if (!isLeft) {
        isRight = scrollLeft + bodyWidth >= scrollWidth;
      }
      if (scrollLeft > lastScrollLeft) {
        direction = 'right';
        if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
          isRightBoundary = true;
        }
      } else {
        direction = 'left';
        if (scrollLeft <= xThreshold) {
          isLeftBoundary = true;
        }
      }
      $xeTable.checkScrolling();
      internalData.lastScrollLeft = scrollLeft;
    }
    if (isRollY) {
      const yThreshold = $xeTable.computeScrollYThreshold;
      isTop = scrollTop <= 0;
      if (!isTop) {
        isBottom = scrollTop + bodyHeight >= scrollHeight;
      }
      if (scrollTop > lastScrollTop) {
        direction = 'bottom';
        if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
          isBottomBoundary = true;
        }
      } else {
        direction = 'top';
        if (scrollTop <= yThreshold) {
          isTopBoundary = true;
        }
      }
      internalData.lastScrollTop = scrollTop;
    }
    reactData.isDragColMove = false;
    reactData.isDragRowMove = false;
    reactData.lastScrollTime = Date.now();
    const evntParams = {
      scrollTop,
      scrollLeft,
      bodyHeight,
      bodyWidth,
      scrollHeight,
      scrollWidth,
      isX: isRollX,
      isY: isRollY,
      isTop,
      isBottom,
      isLeft,
      isRight,
      direction,
      ...params
    };
    updateRowExpandStyle($xeTable);
    checkLastSyncScroll($xeTable, isRollX, isRollY);
    if (isRollX) {
      $xeTable.closeFilter();
    }
    if (rowOpts.isHover || highlightHoverRow) {
      $xeTable.clearHoverRow();
    }
    if (validTip && validTip.reactData.visible) {
      validTip.close();
    }
    if (tooltip && tooltip.reactData.visible) {
      tooltip.close();
    }
    if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
      $xeTable.dispatchEvent('scroll-boundary', evntParams, evnt);
    }
    $xeTable.dispatchEvent('scroll', evntParams, evnt);
  },
  /**
   * 横向 X 可视渲染事件处理
   */
  triggerScrollXEvent() {
    const $xeTable = this;
    const virtualXOpts = $xeTable.computeVirtualXOpts;
    if (virtualXOpts.immediate) {
      loadScrollXData($xeTable);
    } else {
      lazyScrollXData($xeTable);
    }
  },
  /**
   * 纵向 Y 可视渲染事件处理
   */
  triggerScrollYEvent() {
    const $xeTable = this;
    const virtualYOpts = $xeTable.computeVirtualYOpts;
    if (virtualYOpts.immediate) {
      loadScrollYData($xeTable);
    } else {
      lazyScrollYData($xeTable);
    }
  },
  triggerBodyScrollEvent(evnt, fixedType) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollYLoad,
      scrollXLoad
    } = reactData;
    const {
      elemStore,
      intoRunScroll,
      lastScrollTop,
      lastScrollLeft,
      inWheelScroll,
      inVirtualScroll,
      inHeaderScroll,
      inBodyScroll,
      scrollRenderType,
      inFooterScroll
    } = internalData;
    if (inWheelScroll || inVirtualScroll || inHeaderScroll || inFooterScroll) {
      return;
    }
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const rowExpandEl = $xeTable.$refs.refRowExpandElem;
    if (intoRunScroll) {
      return;
    }
    if (!bodyScrollElem) {
      return;
    }
    if (!xHandleEl) {
      return;
    }
    if (!yHandleEl) {
      return;
    }
    if (inBodyScroll) {
      if (scrollRenderType !== fixedType) {
        return;
      }
    }
    let scrollTop = yHandleEl.scrollTop;
    let scrollLeft = xHandleEl.scrollLeft;
    if (leftScrollElem && fixedType === 'left') {
      scrollTop = leftScrollElem.scrollTop;
    } else if (rightScrollElem && fixedType === 'right') {
      scrollTop = rightScrollElem.scrollTop;
    } else {
      scrollTop = bodyScrollElem.scrollTop;
      scrollLeft = bodyScrollElem.scrollLeft;
    }
    const isRollX = scrollLeft !== lastScrollLeft;
    const isRollY = scrollTop !== lastScrollTop;
    internalData.inBodyScroll = true;
    internalData.scrollRenderType = fixedType;
    if (isRollY) {
      if (fixedType === 'left') {
        setScrollTop(bodyScrollElem, scrollTop);
        setScrollTop(rightScrollElem, scrollTop);
      } else if (fixedType === 'right') {
        setScrollTop(bodyScrollElem, scrollTop);
        setScrollTop(leftScrollElem, scrollTop);
      } else {
        setScrollTop(leftScrollElem, scrollTop);
        setScrollTop(rightScrollElem, scrollTop);
      }
      setScrollTop(yHandleEl, scrollTop);
      setScrollTop(rowExpandEl, scrollTop);
      if (scrollYLoad) {
        $xeTable.triggerScrollYEvent(evnt);
      }
    }
    if (isRollX) {
      setScrollLeft(xHandleEl, scrollLeft);
      setScrollLeft(headerScrollElem, scrollLeft);
      setScrollLeft(footerScrollElem, scrollLeft);
      if (scrollXLoad) {
        $xeTable.triggerScrollXEvent(evnt);
      }
    }
    $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
      type: 'body',
      fixed: fixedType
    });
  },
  triggerHeaderScrollEvent(evnt, fixedType) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollXLoad
    } = reactData;
    const {
      elemStore,
      intoRunScroll,
      inWheelScroll,
      inVirtualScroll,
      inBodyScroll,
      inFooterScroll
    } = internalData;
    if (inWheelScroll || inVirtualScroll || inBodyScroll || inFooterScroll) {
      return;
    }
    if (intoRunScroll) {
      return;
    }
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    if (!headerScrollElem) {
      return;
    }
    if (!xHandleEl) {
      return;
    }
    if (!yHandleEl) {
      return;
    }
    const scrollTop = yHandleEl.scrollTop;
    const scrollLeft = headerScrollElem.scrollLeft;
    const isRollX = true;
    const isRollY = false;
    internalData.inHeaderScroll = true;
    setScrollLeft(xHandleEl, scrollLeft);
    setScrollLeft(footerScrollElem, scrollLeft);
    setScrollLeft(bodyScrollElem, scrollLeft);
    if (scrollXLoad) {
      $xeTable.triggerScrollXEvent(evnt);
    }
    $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
      type: 'header',
      fixed: fixedType
    });
  },
  triggerFooterScrollEvent(evnt, fixedType) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollXLoad
    } = reactData;
    const {
      elemStore,
      intoRunScroll,
      inWheelScroll,
      inVirtualScroll,
      inHeaderScroll,
      inBodyScroll
    } = internalData;
    if (inWheelScroll || inVirtualScroll || inHeaderScroll || inBodyScroll) {
      return;
    }
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    if (intoRunScroll) {
      return;
    }
    if (!footerScrollElem) {
      return;
    }
    if (!xHandleEl) {
      return;
    }
    if (!yHandleEl) {
      return;
    }
    const scrollTop = yHandleEl.scrollTop;
    const scrollLeft = footerScrollElem.scrollLeft;
    const isRollX = true;
    const isRollY = false;
    internalData.inFooterScroll = true;
    setScrollLeft(xHandleEl, scrollLeft);
    setScrollLeft(headerScrollElem, scrollLeft);
    setScrollLeft(bodyScrollElem, scrollLeft);
    if (scrollXLoad) {
      $xeTable.triggerScrollXEvent(evnt);
    }
    $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
      type: 'footer',
      fixed: fixedType
    });
  },
  triggerBodyWheelEvent(evnt) {
    const $xeTable = this;
    const tableProps = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      target,
      deltaY,
      deltaX,
      shiftKey
    } = evnt;
    if (target && /^textarea$/i.test(target.tagName)) {
      return;
    }
    const {
      highlightHoverRow
    } = tableProps;
    const {
      scrollXLoad,
      scrollYLoad,
      expandColumn
    } = reactData;
    const leftFixedWidth = $xeTable.computeLeftFixedWidth;
    const rightFixedWidth = $xeTable.computeRightFixedWidth;
    if (!(leftFixedWidth || rightFixedWidth || expandColumn)) {
      return;
    }
    const {
      elemStore,
      lastScrollTop,
      lastScrollLeft
    } = internalData;
    const rowOpts = $xeTable.computeRowOpts;
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const rowExpandEl = $xeTable.$refs.refRowExpandElem;
    if (!xHandleEl) {
      return;
    }
    if (!yHandleEl) {
      return;
    }
    if (!bodyScrollElem) {
      return;
    }
    const wheelSpeed = getWheelSpeed(reactData.lastScrollTime);
    const deltaTop = shiftKey ? 0 : Math.ceil(deltaY * wheelSpeed);
    const deltaLeft = Math.ceil((shiftKey ? deltaY || deltaX : deltaX) * wheelSpeed);
    const isTopWheel = deltaTop < 0;
    const currScrollTop = bodyScrollElem.scrollTop;
    // 如果滚动位置已经是顶部或底部，则不需要触发
    if (isTopWheel ? currScrollTop <= 0 : currScrollTop >= bodyScrollElem.scrollHeight - bodyScrollElem.clientHeight) {
      return;
    }
    const scrollTop = currScrollTop + deltaTop;
    const scrollLeft = bodyScrollElem.scrollLeft + deltaLeft;
    const isRollX = scrollLeft !== lastScrollLeft;
    const isRollY = scrollTop !== lastScrollTop;
    if (rowOpts.isHover || highlightHoverRow) {
      $xeTable.clearHoverRow();
    }
    // 用于鼠标纵向滚轮处理
    if (isRollX) {
      evnt.preventDefault();
      internalData.inWheelScroll = true;
      if (browseObj.firefox || browseObj.safari) {
        const currLeftNum = scrollLeft;
        setScrollLeft(xHandleEl, currLeftNum);
        setScrollLeft(bodyScrollElem, currLeftNum);
        setScrollLeft(headerScrollElem, currLeftNum);
        setScrollLeft(footerScrollElem, currLeftNum);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
          type: 'table',
          fixed: ''
        });
      } else {
        wheelScrollLeftTo(scrollLeft, offsetLeft => {
          const currLeftNum = offsetLeft;
          setScrollLeft(xHandleEl, currLeftNum);
          setScrollLeft(bodyScrollElem, currLeftNum);
          setScrollLeft(headerScrollElem, currLeftNum);
          setScrollLeft(footerScrollElem, currLeftNum);
          if (scrollXLoad) {
            $xeTable.triggerScrollXEvent(evnt);
          }
          $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
            type: 'table',
            fixed: ''
          });
        });
      }
    }
    if (isRollY) {
      evnt.preventDefault();
      if (browseObj.firefox || browseObj.safari) {
        const currTopNum = scrollTop;
        setScrollTop(yHandleEl, currTopNum);
        setScrollTop(bodyScrollElem, currTopNum);
        setScrollTop(leftScrollElem, currTopNum);
        setScrollTop(rightScrollElem, currTopNum);
        setScrollTop(rowExpandEl, currTopNum);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
          type: 'table',
          fixed: ''
        });
      } else {
        wheelScrollTopTo(scrollTop - currScrollTop, offsetTop => {
          const currTopNum = bodyScrollElem.scrollTop + offsetTop;
          internalData.inWheelScroll = true;
          setScrollTop(yHandleEl, currTopNum);
          setScrollTop(bodyScrollElem, currTopNum);
          setScrollTop(leftScrollElem, currTopNum);
          setScrollTop(rightScrollElem, currTopNum);
          setScrollTop(rowExpandEl, currTopNum);
          if (scrollYLoad) {
            $xeTable.triggerScrollYEvent(evnt);
          }
          $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
            type: 'table',
            fixed: ''
          });
        });
      }
    }
  },
  triggerVirtualScrollXEvent(evnt) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollXLoad
    } = reactData;
    const {
      elemStore,
      inWheelScroll,
      lastScrollTop,
      inHeaderScroll,
      inBodyScroll,
      inFooterScroll
    } = internalData;
    if (inHeaderScroll || inBodyScroll || inFooterScroll) {
      return;
    }
    if (inWheelScroll) {
      return;
    }
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    const wrapperEl = evnt.currentTarget;
    const {
      scrollLeft
    } = wrapperEl;
    const yBodyEl = yHandleEl || bodyScrollElem;
    let scrollTop = 0;
    if (yBodyEl) {
      scrollTop = yBodyEl.scrollTop;
    }
    const isRollX = true;
    const isRollY = scrollTop !== lastScrollTop;
    internalData.inVirtualScroll = true;
    setScrollLeft(bodyScrollElem, scrollLeft);
    setScrollLeft(headerScrollElem, scrollLeft);
    setScrollLeft(footerScrollElem, scrollLeft);
    if (scrollXLoad) {
      $xeTable.triggerScrollXEvent(evnt);
    }
    $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
      type: 'table',
      fixed: ''
    });
  },
  triggerVirtualScrollYEvent(evnt) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollYLoad
    } = reactData;
    const {
      elemStore,
      inWheelScroll,
      lastScrollLeft,
      inHeaderScroll,
      inBodyScroll,
      inFooterScroll
    } = internalData;
    if (inHeaderScroll || inBodyScroll || inFooterScroll) {
      return;
    }
    if (inWheelScroll) {
      return;
    }
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const rowExpandEl = $xeTable.$refs.refRowExpandElem;
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const wrapperEl = evnt.currentTarget;
    const {
      scrollTop
    } = wrapperEl;
    const xBodyEl = xHandleEl || bodyScrollElem;
    let scrollLeft = 0;
    if (xBodyEl) {
      scrollLeft = xBodyEl.scrollLeft;
    }
    const isRollX = scrollLeft !== lastScrollLeft;
    const isRollY = true;
    internalData.inVirtualScroll = true;
    setScrollTop(bodyScrollElem, scrollTop);
    setScrollTop(leftScrollElem, scrollTop);
    setScrollTop(rightScrollElem, scrollTop);
    setScrollTop(rowExpandEl, scrollTop);
    if (scrollYLoad) {
      $xeTable.triggerScrollYEvent(evnt);
    }
    $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
      type: 'table',
      fixed: ''
    });
  },
  updateScrollXData() {
    const $xeTable = this;
    const reactData = $xeTable;
    const {
      isAllOverflow
    } = reactData;
    handleTableColumn($xeTable);
    $xeTable.updateScrollXSpace();
    return $xeTable.$nextTick().then(() => {
      handleTableColumn($xeTable);
      $xeTable.updateScrollXSpace();
      if (!isAllOverflow) {
        $xeTable.updateScrollYSpace();
      }
    });
  },
  // 更新横向 X 可视渲染上下剩余空间大小
  updateScrollXSpace() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      scrollXLoad,
      overflowX,
      scrollXWidth
    } = reactData;
    const {
      visibleColumn,
      scrollXStore,
      elemStore,
      fullColumnIdData
    } = internalData;
    const mouseOpts = $xeTable.computeMouseOpts;
    const tableBody = $xeTable.$refs.refTableBody;
    const tableBodyElem = tableBody ? tableBody.$el : null;
    if (tableBodyElem) {
      const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
      const bodyTableElem = getRefElem(elemStore['main-body-table']);
      const headerTableElem = getRefElem(elemStore['main-header-table']);
      const footerTableElem = getRefElem(elemStore['main-footer-table']);
      let xSpaceLeft = 0;
      const firstColumn = visibleColumn[scrollXStore.startIndex];
      if (firstColumn) {
        const colRest = fullColumnIdData[firstColumn.id] || {};
        xSpaceLeft = colRest.oLeft;
      }
      let clientWidth = 0;
      if (bodyScrollElem) {
        clientWidth = bodyScrollElem.clientWidth;
      }
      // 虚拟渲染
      let isScrollXBig = false;
      let ySpaceWidth = scrollXWidth;
      if (scrollXWidth > maxXWidth) {
        // 触右
        if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollLeft + clientWidth >= maxXWidth) {
          xSpaceLeft = maxXWidth - bodyTableElem.clientWidth;
        } else {
          xSpaceLeft = (maxXWidth - clientWidth) * (xSpaceLeft / (scrollXWidth - clientWidth));
        }
        ySpaceWidth = maxXWidth;
        isScrollXBig = true;
      }
      if (!(scrollXLoad && overflowX)) {
        xSpaceLeft = 0;
      }
      if (headerTableElem) {
        headerTableElem.style.transform = headerTableElem.getAttribute('xvm') ? `translate(${xSpaceLeft}px, 0px)` : '';
      }
      if (bodyTableElem) {
        bodyTableElem.style.transform = `translate(${xSpaceLeft}px, ${reactData.scrollYTop || 0}px)`;
      }
      if (footerTableElem) {
        footerTableElem.style.transform = footerTableElem.getAttribute('xvm') ? `translate(${xSpaceLeft}px, 0px)` : '';
      }
      const containerList = ['main'];
      containerList.forEach(name => {
        const layoutList = ['header', 'body', 'footer'];
        layoutList.forEach(layout => {
          const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
          if (xSpaceElem) {
            xSpaceElem.style.width = scrollXLoad ? `${ySpaceWidth}px` : '';
          }
        });
      });
      reactData.scrollXLeft = xSpaceLeft;
      reactData.scrollXWidth = ySpaceWidth;
      reactData.isScrollXBig = isScrollXBig;
      const scrollXSpaceEl = $xeTable.$refs.refScrollXSpaceElem;
      if (scrollXSpaceEl) {
        scrollXSpaceEl.style.width = `${ySpaceWidth}px`;
      }
      if (isScrollXBig && mouseOpts.area) {
        errLog('vxe.error.notProp', ['mouse-config.area']);
      }
      calcScrollbar($xeTable);
      return $xeTable.$nextTick(() => {
        updateStyle($xeTable);
      });
    }
  },
  updateScrollYData() {
    const $xeTable = this;
    $xeTable.handleTableData();
    $xeTable.updateScrollYSpace();
    return $xeTable.$nextTick().then(() => {
      $xeTable.handleTableData();
      $xeTable.updateScrollYSpace();
    });
  },
  // 更新纵向 Y 可视渲染上下剩余空间大小
  updateScrollYSpace() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      isAllOverflow,
      scrollYLoad,
      expandColumn
    } = reactData;
    const {
      scrollYStore,
      elemStore,
      isResizeCellHeight,
      afterFullData,
      fullAllDataRowIdData,
      rowExpandedMaps
    } = internalData;
    const {
      startIndex
    } = scrollYStore;
    const mouseOpts = $xeTable.computeMouseOpts;
    const expandOpts = $xeTable.computeExpandOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const cellOpts = $xeTable.computeCellOpts;
    const defaultRowHeight = $xeTable.computeDefaultRowHeight;
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const bodyTableElem = getRefElem(elemStore['main-body-table']);
    const leftBodyTableElem = getRefElem(elemStore['left-body-table']);
    const rightbodyTableElem = getRefElem(elemStore['right-body-table']);
    const containerList = ['main', 'left', 'right'];
    let ySpaceTop = 0;
    let scrollYHeight = 0;
    let isScrollYBig = false;
    if (scrollYLoad) {
      const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
      if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
        scrollYHeight = afterFullData.length * defaultRowHeight;
        if (scrollYHeight > maxYHeight) {
          isScrollYBig = true;
        }
        ySpaceTop = Math.max(0, startIndex * defaultRowHeight);
      } else {
        const firstRow = afterFullData[startIndex];
        let rowid = getRowid($xeTable, firstRow);
        let rowRest = fullAllDataRowIdData[rowid] || {};
        ySpaceTop = rowRest.oTop || 0;
        const lastRow = afterFullData[afterFullData.length - 1];
        rowid = getRowid($xeTable, lastRow);
        rowRest = fullAllDataRowIdData[rowid] || {};
        scrollYHeight = (rowRest.oTop || 0) + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
        // 是否展开行
        if (expandColumn && rowExpandedMaps[rowid]) {
          scrollYHeight += rowRest.expandHeight || expandOpts.height || 0;
        }
        if (scrollYHeight > maxYHeight) {
          isScrollYBig = true;
        }
      }
    } else {
      if (bodyTableElem) {
        scrollYHeight = bodyTableElem.clientHeight;
      }
    }
    let clientHeight = 0;
    if (bodyScrollElem) {
      clientHeight = bodyScrollElem.clientHeight;
    }
    // 虚拟渲染
    let ySpaceHeight = scrollYHeight;
    let scrollYTop = ySpaceTop;
    if (isScrollYBig) {
      // 触底
      if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollTop + clientHeight >= maxYHeight) {
        scrollYTop = maxYHeight - bodyTableElem.clientHeight;
      } else {
        scrollYTop = (maxYHeight - clientHeight) * (ySpaceTop / (scrollYHeight - clientHeight));
      }
      ySpaceHeight = maxYHeight;
    }
    if (leftBodyTableElem) {
      leftBodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
    }
    if (bodyTableElem) {
      bodyTableElem.style.transform = `translate(${reactData.scrollXLeft || 0}px, ${scrollYTop}px)`;
    }
    if (rightbodyTableElem) {
      rightbodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
    }
    containerList.forEach(name => {
      const layoutList = ['header', 'body', 'footer'];
      layoutList.forEach(layout => {
        const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
        if (ySpaceElem) {
          ySpaceElem.style.height = ySpaceHeight ? `${ySpaceHeight}px` : '';
        }
      });
    });
    const scrollYSpaceEl = $xeTable.$refs.refScrollYSpaceElem;
    if (scrollYSpaceEl) {
      scrollYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : '';
    }
    const rowExpandYSpaceEl = $xeTable.$refs.refRowExpandYSpaceElem;
    if (rowExpandYSpaceEl) {
      rowExpandYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : '';
    }
    reactData.scrollYTop = scrollYTop;
    reactData.scrollYHeight = scrollYHeight;
    reactData.isScrollYBig = isScrollYBig;
    if (isScrollYBig && mouseOpts.area) {
      errLog('vxe.error.notProp', ['mouse-config.area']);
    }
    calcScrollbar($xeTable);
    return $xeTable.$nextTick().then(() => {
      updateStyle($xeTable);
    });
  },
  updateScrollYStatus() {
    const $xeTable = this;
    return updateScrollYStatus($xeTable);
  },
  /**
   * 如果有滚动条，则滚动到对应的位置
   * @param {Number} scrollLeft 左距离
   * @param {Number} scrollTop 上距离
   */
  scrollTo(scrollLeft, scrollTop) {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      elemStore
    } = internalData;
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    internalData.intoRunScroll = true;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
      setScrollLeft(xHandleEl, scrollLeft);
      setScrollLeft(bodyScrollElem, scrollLeft);
      setScrollLeft(headerScrollElem, scrollLeft);
      setScrollLeft(footerScrollElem, scrollLeft);
      loadScrollXData($xeTable);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
      setScrollTop(yHandleEl, scrollTop);
      setScrollTop(bodyScrollElem, scrollTop);
      setScrollTop(leftScrollElem, scrollTop);
      setScrollTop(rightScrollElem, scrollTop);
      loadScrollYData($xeTable);
    }
    if (reactData.scrollXLoad || reactData.scrollYLoad) {
      return new Promise(resolve => {
        setTimeout(() => {
          $xeTable.$nextTick(() => {
            internalData.intoRunScroll = false;
            resolve();
          });
        }, 30);
      });
    }
    return $xeTable.$nextTick();
  },
  /**
   * 如果有滚动条，则滚动到对应的行
   * @param {Row} row 行对象
   * @param {ColumnInfo} column 列配置
   */
  scrollToRow(row, fieldOrColumn) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const {
      isAllOverflow,
      scrollYLoad,
      scrollXLoad
    } = reactData;
    const rest = [];
    if (row) {
      if (props.treeConfig) {
        rest.push($xeTable.scrollToTreeRow(row));
      } else {
        rest.push(rowToVisible($xeTable, row));
      }
    }
    if (fieldOrColumn) {
      rest.push(handleScrollToRowColumn($xeTable, fieldOrColumn, row));
    }
    return Promise.all(rest).then(() => {
      if (row) {
        if (!isAllOverflow && (scrollYLoad || scrollXLoad)) {
          calcCellHeight($xeTable);
          calcCellWidth($xeTable);
        }
        return $xeTable.$nextTick();
      }
    });
  },
  /**
   * 如果有滚动条，则滚动到对应的列
   * @param {ColumnInfo} column 列配置
   */
  scrollToColumn(fieldOrColumn) {
    const $xeTable = this;
    return handleScrollToRowColumn($xeTable, fieldOrColumn);
  },
  /**
   * 对于树形结构中，可以直接滚动到指定深层节点中
   * 对于某些特定的场景可能会用到，比如定位到某一节点
   * @param {Row} row 行对象
   */
  scrollToTreeRow(row) {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const {
      treeConfig
    } = props;
    const {
      isRowGroupStatus
    } = reactData;
    const {
      tableFullData
    } = internalData;
    const rests = [];
    if (treeConfig || isRowGroupStatus) {
      const aggregateOpts = $xeTable.computeAggregateOpts;
      const treeOpts = $xeTable.computeTreeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData, item => $xeTable.eqRow(item, row), {
        children: isRowGroupStatus ? aggregateOpts.mapChildrenField : childrenField
      });
      if (matchObj) {
        const nodes = matchObj.nodes;
        nodes.forEach((row, index) => {
          if (index < nodes.length - 1 && !$xeTable.isTreeExpandByRow(row)) {
            rests.push($xeTable.setTreeExpand(row, true));
          }
        });
      }
    }
    return Promise.all(rests).then(() => rowToVisible($xeTable, row));
  },
  /**
   * 手动清除滚动相关信息，还原到初始状态
   */
  clearScroll() {
    const $xeTable = this;
    const internalData = $xeTable;
    const {
      elemStore,
      scrollXStore,
      scrollYStore
    } = internalData;
    const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    const footerScrollElem = getRefElem(elemStore['main-footer-scroll']);
    const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
    const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
    const xHandleEl = $xeTable.$refs.refScrollXHandleElem;
    const yHandleEl = $xeTable.$refs.refScrollYHandleElem;
    internalData.intoRunScroll = true;
    setScrollLeft(xHandleEl, 0);
    setScrollLeft(bodyScrollElem, 0);
    setScrollLeft(headerScrollElem, 0);
    setScrollLeft(footerScrollElem, 0);
    setScrollTop(yHandleEl, 0);
    setScrollTop(bodyScrollElem, 0);
    setScrollTop(leftScrollElem, 0);
    setScrollTop(rightScrollElem, 0);
    scrollXStore.startIndex = 0;
    scrollXStore.visibleStartIndex = 0;
    scrollXStore.endIndex = scrollXStore.visibleSize;
    scrollXStore.visibleEndIndex = scrollXStore.visibleSize;
    scrollYStore.startIndex = 0;
    scrollYStore.visibleStartIndex = 0;
    scrollYStore.endIndex = scrollYStore.visibleSize;
    scrollYStore.visibleEndIndex = scrollYStore.visibleSize;
    return $xeTable.$nextTick().then(() => {
      internalData.intoRunScroll = false;
    });
  },
  /**
   * 更新表尾合计
   */
  updateFooter() {
    const $xeTable = this;
    const props = $xeTable;
    const reactData = $xeTable;
    const internalData = $xeTable;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      showFooter,
      footerData,
      footerMethod
    } = props;
    const {
      visibleColumn,
      afterFullData
    } = internalData;
    let footData = [];
    if (showFooter && footerData && footerData.length) {
      footData = footerData.slice(0);
    } else if (showFooter && footerMethod) {
      footData = visibleColumn.length ? footerMethod({
        columns: visibleColumn,
        data: afterFullData,
        $table: $xeTable,
        $grid: $xeGrid
      }) : [];
    }
    reactData.footerTableData = footData;
    $xeTable.handleUpdateFooterMerge();
    return $xeTable.$nextTick();
  },
  /**
   * 更新列状态 updateStatus({ row, column }, cellValue)
   * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
   * 如果单元格配置了校验规则，则会进行校验
   */
  updateStatus(slotParams, cellValue) {
    const $xeTable = this;
    const props = $xeTable;
    return this.$nextTick().then(() => {
      const {
        editRules
      } = props;
      if (slotParams && editRules) {
        return $xeTable.handleCellRuleUpdateStatus('change', slotParams, cellValue);
      }
    });
  },
  /**
   * 设置合并单元格
   * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
   */
  setMergeCells(merges) {
    const $xeTable = this;
    const props = $xeTable;
    if (props.spanMethod) {
      errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);
    }
    handleBodyMerge($xeTable, merges);
    $xeTable.handleUpdateBodyMerge();
    return $xeTable.$nextTick().then(() => {
      $xeTable.updateCellAreas();
      return updateStyle($xeTable);
    });
  },
  /**
   * 移除单元格合并
   * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
   */
  removeMergeCells(merges) {
    const $xeTable = this;
    const props = $xeTable;
    if (props.spanMethod) {
      errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);
    }
    const rest = removeBodyMerges($xeTable, merges);
    $xeTable.handleUpdateBodyMerge();
    return $xeTable.$nextTick().then(() => {
      $xeTable.updateCellAreas();
      updateStyle($xeTable);
      return rest;
    });
  },
  /**
   * 获取所有被合并的单元格
   */
  getMergeCells() {
    const $xeTable = this;
    const internalData = $xeTable;
    return internalData.mergeBodyList.slice(0);
  },
  /**
   * 清除所有单元格合并
   */
  clearMergeCells() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    internalData.mergeBodyList = [];
    internalData.mergeBodyMaps = {};
    internalData.mergeBodyCellMaps = {};
    reactData.mergeBodyFlag++;
    return $xeTable.$nextTick().then(() => {
      return updateStyle($xeTable);
    });
  },
  setMergeFooterItems(merges) {
    const $xeTable = this;
    const props = $xeTable;
    if (props.footerSpanMethod) {
      errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);
    }
    handleFooterMerge($xeTable, merges);
    $xeTable.handleUpdateFooterMerge();
    return $xeTable.$nextTick().then(() => {
      $xeTable.updateCellAreas();
      return updateStyle($xeTable);
    });
  },
  removeMergeFooterItems(merges) {
    const $xeTable = this;
    const props = $xeTable;
    if (props.footerSpanMethod) {
      errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);
    }
    const rest = removeFooterMerges($xeTable, merges);
    $xeTable.handleUpdateFooterMerge();
    return $xeTable.$nextTick().then(() => {
      $xeTable.updateCellAreas();
      updateStyle($xeTable);
      return rest;
    });
  },
  /**
   * 获取所有被合并的表尾
   */
  getMergeFooterItems() {
    const $xeTable = this;
    const internalData = $xeTable;
    return internalData.mergeFooterList.slice(0);
  },
  /**
   * 清除所有表尾合并
   */
  clearMergeFooterItems() {
    const $xeTable = this;
    const reactData = $xeTable;
    const internalData = $xeTable;
    internalData.mergeFooterList = [];
    internalData.mergeFooterMaps = {};
    internalData.mergeFooterCellMaps = {};
    reactData.mergeFootFlag++;
    return $xeTable.$nextTick().then(() => {
      return updateStyle($xeTable);
    });
  },
  updateZindex() {
    if (this.zIndex) {
      this.tZindex = this.zIndex;
    } else if (this.tZindex < getLastZIndex()) {
      this.tZindex = nextZIndex();
    }
  },
  updateCellAreas() {
    const $xeTable = this;
    const props = $xeTable;
    const {
      mouseConfig
    } = props;
    const mouseOpts = $xeTable.computeMouseOpts;
    if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreaEvent) {
      return $xeTable.handleRecalculateCellAreaEvent();
    }
    return $xeTable.$nextTick();
  },
  dispatchEvent(type, params, evnt) {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    $xeTable.$emit(type, createEvent(evnt, {
      $table: $xeTable,
      $grid: $xeGrid
    }, params));
  },
  // 已废弃，使用 dispatchEvent
  emitEvent(type, params, evnt) {
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    this.$emit(type, Object.assign({
      $table: $xeTable,
      $grid: $xeGrid,
      $event: evnt
    }, params));
  },
  focus() {
    this.isActivated = true;
    return this.$nextTick();
  },
  blur() {
    this.isActivated = false;
    return this.$nextTick();
  },
  // 连接工具栏
  connect($toolbar) {
    if ($toolbar && $toolbar.syncUpdate) {
      $toolbar.syncUpdate({
        collectColumn: this.collectColumn,
        $table: this
      });
      this.$toolbar = $toolbar;
    } else {
      errLog('vxe.error.barUnableLink');
    }
    return this.$nextTick();
  },
  /*************************
   * Publish methods
   *************************/
  /**
   * 已废弃，被 getCellElement 替换
   * @deprecated
   */
  getCell(row, column) {
    return this.getCellElement(row, column);
  },
  findRowIndexOf(list, row) {
    return row ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => this.eqRow(item, row)) : -1;
  },
  eqRow(row1, row2) {
    if (row1 && row2) {
      if (row1 === row2) {
        return true;
      }
      return getRowid(this, row1) === getRowid(this, row2);
    }
    return false;
  },
  /*************************
   * Publish methods
   *************************/
  getSetupOptions() {
    return methods_getConfig();
  }
};
// Module methods
const funcs = 'setFilter,openFilter,clearFilter,saveFilterPanel,saveFilterPanelByEvent,resetFilterPanel,resetFilterPanelByEvent,getCheckedFilters,updateFilterOptionStatus,closeMenu,setActiveCellArea,getActiveCellArea,getCellAreas,clearCellAreas,copyCellArea,cutCellArea,pasteCellArea,getCopyCellArea,getCopyCellAreas,clearCopyCellArea,setCellAreas,openFNR,openFind,openReplace,closeFNR,getSelectedCell,clearSelected,insert,insertAt,insertNextAt,insertChild,insertChildAt,insertChildNextAt,remove,removeCheckboxRow,removeRadioRow,removeCurrentRow,getRecordset,getInsertRecords,getRemoveRecords,getUpdateRecords,clearEdit,clearActived,getEditRecord,getActiveRecord,isEditByRow,isActiveByRow,setEditRow,setActiveRow,setEditCell,setActiveCell,setSelectCell,clearValidate,fullValidate,validate,fullValidateField,validateField,openExport,closeExport,openPrint,closePrint,getPrintHtml,exportData,openImport,closeImport,importData,saveFile,readFile,importByFile,print,openCustom,closeCustom,saveCustom,cancelCustom,resetCustom,toggleCustomAllCheckbox,setCustomAllCheckbox'.split(',');
funcs.forEach(name => {
  Methods[name] = function (...args) {
    if (!this[`_${name}`]) {
      if ('openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').includes(name)) {
        errLog('vxe.error.reqModule', ['Export']);
      } else if ('fullValidate,validate'.split(',').includes(name)) {
        errLog('vxe.error.reqModule', ['Validator']);
      } else if ('setFilter,openFilter,clearFilter,getCheckedFilters'.split(',').includes(name)) {
        errLog('vxe.error.reqModule', ['Filter']);
      } else if ('insert,insertAt,insertNextAt,remove,removeCheckboxRow,removeRadioRow,removeCurrentRow,getRecordset,getInsertRecords,getRemoveRecords,getUpdateRecords,getEditRecord,getActiveRecord,isEditByRow,isActiveByRow,setEditRow,setActiveRow,setEditCell,setActiveCell'.split(',').includes(name)) {
        errLog('vxe.error.reqModule', ['Edit']);
      } else if ('openCustom'.split(',').includes(name)) {
        errLog('vxe.error.reqModule', ['Custom']);
      }
    }
    return this[`_${name}`] ? this[`_${name}`](...args) : null;
  };
});
/* harmony default export */ var methods = (Methods);
;// CONCATENATED MODULE: ./packages/table/src/body.ts







const {
  getI18n: body_getI18n,
  renderer: body_renderer,
  renderEmptyElement: body_renderEmptyElement
} = core_.VxeUI;
const renderType = 'body';
// 滚动、拖动过程中不需要触发
const isVMScrollProcess = $xeTable => {
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const {
    delayHover
  } = tableProps;
  const {
    lastScrollTime,
    isDragResize
  } = tableReactData;
  return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
};
function renderLine(h, $xeTable, rowid, params, cellHeight) {
  const tableProps = $xeTable;
  const tableInternalData = $xeTable;
  const {
    row,
    column
  } = params;
  const {
    afterFullData
  } = tableInternalData;
  const {
    treeConfig
  } = tableProps;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    slots,
    treeNode
  } = column;
  const {
    fullAllDataRowIdData
  } = tableInternalData;
  if (slots && slots.line) {
    return $xeTable.callSlot(slots.line, params, h);
  }
  const rowRest = fullAllDataRowIdData[rowid];
  let rLevel = 0;
  let prevRow = null;
  if (rowRest) {
    rLevel = rowRest.level;
    prevRow = rowRest.items[rowRest.treeIndex - 1];
  }
  if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
    return [h('div', {
      key: 'tl',
      class: 'vxe-tree--line-wrapper'
    }, [h('div', {
      class: 'vxe-tree--line',
      style: {
        height: `${$xeTable.eqRow(afterFullData[0], row) ? 1 : calcTreeLine(params, prevRow)}px`,
        bottom: `-${Math.floor(cellHeight / 2)}px`,
        left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize($xeTable) : 0) + 16}px`
      }
    })])];
  }
  return [];
}
/**
 * 渲染列
 */
function renderTdColumn(h, $xeTable, seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) {
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const tableInternalData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    columnKey,
    resizable: allResizable,
    showOverflow: allShowOverflow,
    border,
    height,
    treeConfig,
    cellClassName: allCellClassName,
    cellStyle,
    align: allAlign,
    spanMethod,
    mouseConfig,
    editConfig,
    editRules,
    tooltipConfig,
    padding: allPadding
  } = tableProps;
  const {
    tableData,
    dragRow,
    overflowX,
    currentColumn,
    scrollXLoad,
    scrollYLoad,
    mergeBodyFlag,
    calcCellHeightFlag,
    resizeHeightFlag,
    resizeWidthFlag,
    editStore,
    isAllOverflow,
    validErrorMaps
  } = tableReactData;
  const {
    fullAllDataRowIdData,
    fullColumnIdData,
    mergeBodyCellMaps,
    visibleColumn,
    afterFullData,
    mergeBodyList,
    scrollXStore,
    scrollYStore
  } = tableInternalData;
  const cellOpts = $xeTable.computeCellOpts;
  const validOpts = $xeTable.computeValidOpts;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  const editOpts = $xeTable.computeEditOpts;
  const tooltipOpts = $xeTable.computeTooltipOpts;
  const virtualXOpts = $xeTable.computeVirtualXOpts;
  const virtualYOpts = $xeTable.computeVirtualYOpts;
  const {
    isAllColumnDrag,
    isAllRowDrag
  } = $xeTable.resizableOpts;
  const rowOpts = $xeTable.computeRowOpts;
  const rowDragOpts = $xeTable.computeRowDragOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
  const {
    disabledMethod: dragDisabledMethod,
    isCrossDrag,
    isPeerDrag
  } = rowDragOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const mouseOpts = $xeTable.computeMouseOpts;
  const areaOpts = $xeTable.computeAreaOpts;
  const cellOffsetWidth = $xeTable.computeCellOffsetWidth;
  const {
    selectCellToRow
  } = areaOpts;
  const {
    type,
    cellRender,
    editRender,
    align,
    showOverflow,
    className,
    treeNode,
    rowResize,
    padding,
    verticalAlign,
    slots
  } = column;
  const {
    verticalAlign: allVerticalAlign
  } = cellOpts;
  const {
    actived
  } = editStore;
  const rowRest = fullAllDataRowIdData[rowid] || {};
  const colid = column.id;
  const colRest = fullColumnIdData[colid] || {};
  const renderOpts = editRender || cellRender;
  const compConf = renderOpts ? body_renderer.get(renderOpts.name) : null;
  const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
  const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : '';
  const showAllTip = tooltipOpts.showAll;
  const columnIndex = colRest.index;
  const _columnIndex = colRest._index;
  const isEdit = isEnableConf(editRender);
  const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
  let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
  const isCellPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
  const cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showOverflow) ? allShowOverflow : showOverflow;
  const showEllipsis = cellOverflow === 'ellipsis';
  const showTitle = cellOverflow === 'title';
  const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
  const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
  const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
  const isCsHeight = !!customCellHeight;
  const isRsHeight = resizeHeight > 0;
  let isDirty;
  const tdOns = {};
  const cellAlign = align || (compConf ? compConf.tableCellAlign : '') || allAlign;
  const cellVerticalAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
  const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
  const showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? height || tableData.length > 1 : validOpts.message === 'inline');
  const tdAttrs = {
    colid
  };
  const cellParams = {
    $table: $xeTable,
    $grid: $xeGrid,
    isEdit: false,
    seq,
    rowid,
    row,
    rowIndex,
    $rowIndex,
    _rowIndex,
    column,
    columnIndex,
    $columnIndex,
    _columnIndex,
    fixed: fixedType,
    type: renderType,
    isHidden: !!fixedHiddenColumn,
    level: rowLevel,
    visibleData: afterFullData,
    data: tableData,
    items
  };
  let isRowDragCell = false;
  let isDisabledDrag = false;
  if (rowOpts.drag) {
    isRowDragCell = rowDragOpts.trigger === 'row' || column.dragSort && rowDragOpts.trigger === 'cell';
  }
  if (isRowDragCell) {
    isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
  }
  // hover 进入事件
  if (showTitle || showTooltip || showAllTip || tooltipConfig) {
    tdOns.mouseenter = evnt => {
      if (isVMScrollProcess($xeTable)) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        // 如果配置了显示 tooltip
        $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
      }
      $xeTable.dispatchEvent('cell-mouseenter', Object.assign({
        cell: evnt.currentTarget
      }, cellParams), evnt);
    };
  }
  // hover 退出事件
  if (showTooltip || showAllTip || tooltipConfig) {
    tdOns.mouseleave = evnt => {
      if (isVMScrollProcess($xeTable)) {
        return;
      }
      if (showTooltip || showAllTip) {
        $xeTable.handleTargetLeaveEvent(evnt);
      }
      $xeTable.dispatchEvent('cell-mouseleave', Object.assign({
        cell: evnt.currentTarget
      }, cellParams), evnt);
    };
  }
  // 按下事件处理
  if (isRowDragCell || checkboxOpts.range || mouseConfig) {
    tdOns.mousedown = evnt => {
      $xeTable.triggerCellMousedownEvent(evnt, cellParams);
    };
  }
  // 拖拽列事件
  if (isRowDragCell) {
    tdOns.mouseup = $xeTable.triggerCellMouseupEvent;
  }
  // 点击事件处理
  tdOns.click = evnt => {
    $xeTable.triggerCellClickEvent(evnt, cellParams);
  };
  // 双击事件处理
  tdOns.dblclick = evnt => {
    $xeTable.triggerCellDblclickEvent(evnt, cellParams);
  };
  let isMergeCell = false;
  let mergeRowspan = 1;
  // 合并行或列
  if (mergeBodyFlag && mergeBodyList.length) {
    const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
    if (spanRest) {
      const {
        rowspan,
        colspan
      } = spanRest;
      if (!rowspan || !colspan) {
        return null;
      }
      if (rowspan > 1) {
        isMergeCell = true;
        mergeRowspan = rowspan;
        tdAttrs.rowspan = rowspan;
      }
      if (colspan > 1) {
        isMergeCell = true;
        tdAttrs.colspan = colspan;
      }
    }
  } else if (spanMethod) {
    // 自定义合并行或列的方法
    const {
      rowspan = 1,
      colspan = 1
    } = spanMethod(cellParams) || {};
    if (!rowspan || !colspan) {
      return null;
    }
    if (rowspan > 1) {
      isMergeCell = true;
      mergeRowspan = rowspan;
      tdAttrs.rowspan = rowspan;
    }
    if (colspan > 1) {
      isMergeCell = true;
      tdAttrs.colspan = colspan;
    }
  }
  // 如果被合并不可隐藏
  if (fixedHiddenColumn && isMergeCell) {
    if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
      fixedHiddenColumn = false;
    }
  }
  // 如果编辑列开启显示状态
  if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
    isDirty = $xeTable.isUpdateByRow(row, column.field);
  }
  const isVNAutoHeight = scrollYLoad && !hasEllipsis;
  let cellHeight = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
  const isLastColumn = $columnIndex === columns.length - 1;
  const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
  let isVNPreEmptyStatus = false;
  if (!isMergeCell) {
    if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
      if (scrollYLoad && !treeConfig && !virtualYOpts.immediate && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
        isVNPreEmptyStatus = true;
      } else if (scrollXLoad && !virtualXOpts.immediate && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
        isVNPreEmptyStatus = true;
      }
    }
  }
  if (mergeRowspan > 1) {
    const mEndRow = afterFullData[_rowIndex + mergeRowspan - 1];
    if (mEndRow) {
      const meRowRest = fullAllDataRowIdData[getRowid($xeTable, mEndRow)];
      if (meRowRest) {
        cellHeight += meRowRest.oTop - rowRest.oTop + getCellRestHeight(meRowRest, cellOpts, rowOpts, defaultRowHeight);
      }
    }
  }
  const tcStyle = {};
  if (hasEllipsis && resizeWidthFlag) {
    let tsColspan = tdAttrs.colspan || 0;
    if (tsColspan > 1) {
      for (let index = 1; index < tsColspan; index++) {
        const nextColumn = visibleColumn[columnIndex + index];
        if (nextColumn) {
          tsColspan += nextColumn.renderWidth;
        }
      }
    }
    tcStyle.width = `${column.renderWidth - cellOffsetWidth * tsColspan}px`;
  }
  if (scrollYLoad || hasEllipsis || isCsHeight || isRsHeight) {
    tcStyle.height = `${cellHeight}px`;
  } else {
    tcStyle.minHeight = `${cellHeight}px`;
  }
  const tdVNs = [];
  if (fixedHiddenColumn && isAllOverflow) {
    tdVNs.push(h('div', {
      key: 'tc',
      class: ['vxe-cell', {
        'c--title': showTitle,
        'c--tooltip': showTooltip,
        'c--ellipsis': showEllipsis
      }],
      style: tcStyle
    }));
  } else {
    // 渲染单元格
    if (treeConfig) {
      tdVNs.push(...renderLine(h, $xeTable, rowid, cellParams, cellHeight));
    }
    tdVNs.push(h('div', {
      key: 'tc',
      class: ['vxe-cell', {
        'c--title': showTitle,
        'c--tooltip': showTooltip,
        'c--ellipsis': showEllipsis
      }],
      style: tcStyle,
      attrs: {
        title: showTitle ? $xeTable.getCellLabel(row, column) : null
      }
    }, isVNPreEmptyStatus ? [] : [h('div', {
      attrs: {
        colid,
        rowid
      },
      class: 'vxe-cell--wrapper'
    }, column.renderCell(h, cellParams))]));
    if (showValidTip && errorValidItem) {
      const errRule = errorValidItem.rule;
      const validSlot = slots ? slots.valid : null;
      const validParams = {
        ...cellParams,
        ...errorValidItem,
        rule: errorValidItem
      };
      tdVNs.push(h('div', {
        key: 'tcv',
        class: ['vxe-cell--valid-error-tip', getClass(validOpts.className, errorValidItem)],
        style: errRule && errRule.maxWidth ? {
          width: `${errRule.maxWidth}px`
        } : undefined
      }, [h('div', {
        class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || 'normal'}`
      }, [validSlot ? $xeTable.callSlot(validSlot, validParams, h) : [h('span', {
        class: 'vxe-cell--valid-error-msg'
      }, errorValidItem.content)]])]));
    }
  }
  let showAreaRowStatus = false;
  if (mouseConfig && mouseOpts.area && selectCellToRow) {
    if (!_columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
      showAreaRowStatus = true;
    }
  }
  if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
    tdVNs.push(h('div', {
      key: 'tcc',
      class: ['vxe-cell--col-resizable', {
        'is--line': !border || border === 'none'
      }],
      on: {
        mousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
        dblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
      }
    }));
  }
  if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
    tdVNs.push(h('div', {
      key: 'tcr',
      class: 'vxe-cell--row-resizable',
      on: {
        mousedown: evnt => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
        dblclick: evnt => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
      }
    }));
  }
  return h('td', {
    class: ['vxe-body--column', colid, cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : '', cellAlign ? `col--${cellAlign}` : '', type ? `col--${type}` : '', {
      'col--last': isLastColumn,
      'col--tree-node': treeNode,
      'col--edit': isEdit,
      'col--ellipsis': hasEllipsis,
      'col--cs-height': isCsHeight,
      'col--rs-height': isRsHeight,
      'col--to-row': showAreaRowStatus,
      'col--auto-height': isVNAutoHeight,
      'fixed--width': !isAutoCellWidth,
      'fixed--hidden': fixedHiddenColumn,
      'is--padding': isCellPadding,
      'is--progress': fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
      'is--drag-cell': isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
      'is--drag-disabled': isDisabledDrag,
      'col--dirty': isDirty,
      'col--active': editConfig && isEdit && actived.row === row && (actived.column === column || editOpts.mode === 'row'),
      'col--valid-error': !!errorValidItem,
      'col--current': currentColumn === column
    }, getClass(compCellClassName, cellParams), getClass(className, cellParams), getClass(allCellClassName, cellParams)],
    key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? column.id : $columnIndex,
    attrs: tdAttrs,
    style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle),
    on: tdOns
  }, isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
}
function renderRows(h, _vm, fixedType, isOptimizeMode, tableData, tableColumn) {
  const $xeTable = _vm.$parent;
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const tableInternalData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    stripe,
    rowKey,
    highlightHoverRow,
    rowClassName,
    rowStyle,
    editConfig,
    treeConfig
  } = tableProps;
  const {
    hasFixedColumn,
    treeExpandedFlag,
    isColLoading,
    scrollXLoad,
    scrollYLoad,
    isAllOverflow,
    rowExpandedFlag,
    expandColumn,
    selectRadioRow,
    pendingRowFlag,
    isDragColMove,
    rowExpandHeightFlag,
    isRowGroupStatus
  } = tableReactData;
  const {
    fullAllDataRowIdData,
    fullColumnIdData,
    treeExpandedMaps,
    pendingRowMaps,
    rowExpandedMaps
  } = tableInternalData;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  const radioOpts = $xeTable.computeRadioOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const editOpts = $xeTable.computeEditOpts;
  const rowOpts = $xeTable.computeRowOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    transform,
    seqMode
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const rows = [];
  const {
    handleGetRowId
  } = createHandleGetRowId($xeTable);
  const isDeepRow = treeConfig || isRowGroupStatus;
  tableData.forEach((row, $rowIndex) => {
    const trOn = {};
    const rowid = handleGetRowId(row);
    const rowRest = fullAllDataRowIdData[rowid] || {};
    let rowIndex = $rowIndex;
    let rowLevel = 0;
    let seq = -1;
    let _rowIndex = -1;
    const hasRowGroupAggregate = isRowGroupStatus && row.isAggregate;
    // 当前行事件
    if (rowOpts.isHover || highlightHoverRow) {
      trOn.mouseenter = evnt => {
        if (isVMScrollProcess($xeTable)) {
          return;
        }
        $xeTable.triggerHoverEvent(evnt, {
          row,
          rowIndex
        });
      };
      trOn.mouseleave = () => {
        if (isVMScrollProcess($xeTable)) {
          return;
        }
        $xeTable.clearHoverRow();
      };
    }
    if (rowRest) {
      rowLevel = rowRest.level;
      if (hasRowGroupAggregate || treeConfig && transform && seqMode === 'increasing') {
        seq = rowRest._index + 1;
      } else {
        seq = rowRest.seq;
      }
      rowIndex = rowRest.index;
      _rowIndex = rowRest._index;
    }
    const params = {
      $table: $xeTable,
      seq,
      rowid,
      fixed: fixedType,
      type: renderType,
      level: rowLevel,
      row,
      rowIndex,
      $rowIndex,
      _rowIndex
    };
    // 行是否被展开
    const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
    // 树节点是否被展开
    let isExpandTree = false;
    let rowChildren = [];
    // 是否新增行
    let isNewRow = false;
    if (editConfig) {
      isNewRow = $xeTable.isInsertByRow(row);
    }
    if (treeConfig && !scrollYLoad && !transform) {
      rowChildren = row[childrenField];
      isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
    }
    // 拖拽行事件
    if (rowOpts.drag && !isRowGroupStatus && (!treeConfig || transform)) {
      trOn.dragstart = $xeTable.handleRowDragDragstartEvent;
      trOn.dragend = $xeTable.handleRowDragDragendEvent;
      trOn.dragover = $xeTable.handleRowDragDragoverEvent;
    }
    const trClass = ['vxe-body--row', isDeepRow ? `row--level-${rowLevel}` : '', {
      'row--stripe': stripe && (_rowIndex + 1) % 2 === 0,
      'is--new': isNewRow,
      'is--expand-row': isExpandRow,
      'is--expand-tree': isExpandTree,
      'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
      'row--radio': radioOpts.highlight && selectRadioRow === row,
      'row--checked': checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
      'row--pending': !!pendingRowFlag && !!pendingRowMaps[rowid],
      'row--group': hasRowGroupAggregate
    }, rowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowClassName) ? rowClassName(params) : rowClassName : ''];
    const tdVNs = tableColumn.map((column, $columnIndex) => {
      return renderTdColumn(h, $xeTable, seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
    });
    rows.push(!isColLoading && columnOpts.drag && columnDragOpts.animation ? h('transition-group', {
      props: {
        tag: 'tr',
        name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`
      },
      class: trClass,
      attrs: {
        rowid
      },
      style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : undefined,
      key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex,
      nativeOn: trOn
    }, tdVNs) : h('tr', {
      class: trClass,
      attrs: {
        rowid
      },
      style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : undefined,
      key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex,
      on: trOn
    }, tdVNs));
    // 如果行被展开了
    if (isExpandRow) {
      const expandOpts = $xeTable.computeExpandOpts;
      const {
        height: expandHeight,
        padding,
        mode: expandMode
      } = expandOpts;
      if (expandMode === 'fixed') {
        rows.push(h('tr', {
          class: 'vxe-body--row-expanded-place',
          key: `expand_${rowid}`,
          attrs: {
            rowid
          }
        }, [h('td', {
          class: 'vxe-body--row-expanded-place-column',
          attrs: {
            colspan: tableColumn.length
          },
          style: {
            height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
          }
        })]));
      } else {
        const cellStyle = {};
        if (expandHeight) {
          cellStyle.height = `${expandHeight}px`;
        }
        if (treeConfig) {
          cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
        }
        const {
          showOverflow
        } = expandColumn || {};
        const colid = expandColumn.id;
        const colRest = fullColumnIdData[colid] || {};
        const hasEllipsis = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showOverflow) ? isAllOverflow : showOverflow;
        let columnIndex = -1;
        let $columnIndex = -1;
        let _columnIndex = -1;
        if (colRest) {
          columnIndex = colRest.index;
          $columnIndex = colRest.$index;
          _columnIndex = colRest._index;
        }
        const expandParams = {
          $grid: $xeGrid,
          $table: $xeTable,
          seq,
          column: expandColumn,
          columnIndex,
          $columnIndex,
          _columnIndex,
          fixed: fixedType,
          type: renderType,
          level: rowLevel,
          row,
          rowid,
          rowIndex,
          $rowIndex,
          _rowIndex,
          isHidden: false,
          isEdit: false,
          visibleData: [],
          data: [],
          items: []
        };
        rows.push(h('tr', {
          class: ['vxe-body--expanded-row', {
            'is--padding': padding
          }],
          key: `expand_${rowid}`
        }, [h('td', {
          class: ['vxe-body--expanded-column', {
            'fixed--hidden': fixedType && !hasFixedColumn,
            'col--ellipsis': hasEllipsis
          }],
          attrs: {
            colspan: tableColumn.length
          }
        }, [h('div', {
          class: ['vxe-body--expanded-cell', {
            'is--ellipsis': expandHeight
          }],
          style: cellStyle
        }, [expandColumn.renderData(h, expandParams)])])]));
      }
    }
    // 如果是树形表格
    if (isExpandTree) {
      rows.push(...renderRows(h, _vm, fixedType, isOptimizeMode, rowChildren, tableColumn));
    }
  });
  return rows;
}
/* harmony default export */ var body = ({
  name: 'VxeTableBody',
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ''
    }
  },
  mounted() {
    const _vm = this;
    const props = _vm;
    const $xeTable = _vm.$parent;
    const tableInternalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = tableInternalData;
    const prefix = `${fixedType || 'main'}-body-`;
    elemStore[`${prefix}wrapper`] = _vm.$refs.refElem;
    elemStore[`${prefix}scroll`] = _vm.$refs.refBodyScroll;
    elemStore[`${prefix}table`] = _vm.$refs.refBodyTable;
    elemStore[`${prefix}colgroup`] = _vm.$refs.refBodyColgroup;
    elemStore[`${prefix}list`] = _vm.$refs.refBodyTBody;
    elemStore[`${prefix}xSpace`] = _vm.$refs.refBodyXSpace;
    elemStore[`${prefix}ySpace`] = _vm.$refs.refBodyYSpace;
    elemStore[`${prefix}emptyBlock`] = _vm.$refs.refBodyEmptyBlock;
  },
  destroyed() {
    const props = this;
    const $xeTable = this.$parent;
    const tableInternalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = tableInternalData;
    const prefix = `${fixedType || 'main'}-body-`;
    elemStore[`${prefix}wrapper`] = null;
    elemStore[`${prefix}scroll`] = null;
    elemStore[`${prefix}table`] = null;
    elemStore[`${prefix}colgroup`] = null;
    elemStore[`${prefix}list`] = null;
    elemStore[`${prefix}xSpace`] = null;
    elemStore[`${prefix}ySpace`] = null;
    elemStore[`${prefix}emptyBlock`] = null;
  },
  render(h) {
    const props = this;
    const $xeTable = this.$parent;
    const tableProps = $xeTable;
    const tableReactData = $xeTable;
    const tableInternalData = $xeTable;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      xID,
      $scopedSlots
    } = $xeTable;
    const {
      fixedColumn,
      fixedType,
      tableColumn
    } = props;
    const {
      spanMethod,
      footerSpanMethod,
      mouseConfig
    } = tableProps;
    const {
      isGroup,
      tableData,
      isRowLoading,
      isColLoading,
      overflowX,
      scrollXLoad,
      scrollYLoad,
      isAllOverflow,
      isDragRowMove,
      expandColumn,
      dragRow,
      dragCol
    } = tableReactData;
    const {
      visibleColumn,
      fullAllDataRowIdData,
      fullColumnIdData
    } = tableInternalData;
    const rowOpts = $xeTable.computeRowOpts;
    const emptyOpts = $xeTable.computeEmptyOpts;
    const mouseOpts = $xeTable.computeMouseOpts;
    const rowDragOpts = $xeTable.computeRowDragOpts;
    const expandOpts = $xeTable.computeExpandOpts;
    let renderDataList = tableData;
    let renderColumnList = tableColumn;
    let isOptimizeMode = false;
    // 如果是使用优化模式
    if (scrollXLoad || scrollYLoad || isAllOverflow) {
      if (expandColumn && expandOpts.mode !== 'fixed' || spanMethod || footerSpanMethod) {
        // 如果不支持优化模式
      } else {
        isOptimizeMode = true;
      }
    }
    if (!isColLoading && (fixedType || !overflowX)) {
      renderColumnList = visibleColumn;
    }
    if (fixedType) {
      if (isOptimizeMode) {
        renderColumnList = fixedColumn || [];
      }
    }
    // 行拖拽
    if (scrollYLoad && dragRow) {
      if (renderDataList.length > 2) {
        const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
        if (dRowRest) {
          const drIndex = dRowRest._index;
          const firstRow = renderDataList[0];
          const lastRow = renderDataList[renderDataList.length - 1];
          const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
          const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
          if (firstRowRest && lastRowRest) {
            const frIndex = firstRowRest._index;
            const lrIndex = lastRowRest._index;
            if (drIndex < frIndex) {
              renderDataList = [dragRow].concat(renderDataList);
            } else if (drIndex > lrIndex) {
              renderDataList = renderDataList.concat([dragRow]);
            }
          }
        }
      }
    }
    if (!fixedType && !isGroup) {
      // 列拖拽
      if (scrollXLoad && dragCol) {
        if (renderColumnList.length > 2) {
          const dCowRest = fullColumnIdData[dragCol.id];
          if (dCowRest) {
            const dcIndex = dCowRest._index;
            const firstCol = renderColumnList[0];
            const lastCol = renderColumnList[renderColumnList.length - 1];
            const firstColRest = fullColumnIdData[firstCol.id];
            const lastColRest = fullColumnIdData[lastCol.id];
            if (firstColRest && lastColRest) {
              const fcIndex = firstColRest._index;
              const lcIndex = lastColRest._index;
              if (dcIndex < fcIndex) {
                renderColumnList = [dragCol].concat(renderColumnList);
              } else if (dcIndex > lcIndex) {
                renderColumnList = renderColumnList.concat([dragCol]);
              }
            }
          }
        }
      }
    }
    let emptyContent;
    if ($scopedSlots.empty) {
      emptyContent = $scopedSlots.empty.call(this, {
        $table: $xeTable,
        $grid: $xeGrid
      });
    } else {
      const compConf = emptyOpts.name ? body_renderer.get(emptyOpts.name) : null;
      const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
      if (rtEmptyView) {
        emptyContent = getSlotVNs(rtEmptyView.call(this, h, emptyOpts, {
          $table: $xeTable
        }));
      } else {
        emptyContent = tableProps.emptyText || body_getI18n('vxe.table.emptyText');
      }
    }
    const ons = {
      scroll(evnt) {
        $xeTable.triggerBodyScrollEvent(evnt, fixedType);
      }
    };
    return h('div', {
      ref: 'refElem',
      class: ['vxe-table--body-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
      attrs: {
        xid: xID
      }
    }, [h('div', {
      ref: 'refBodyScroll',
      class: 'vxe-table--body-inner-wrapper',
      on: ons
    }, [fixedType ? body_renderEmptyElement($xeTable) : h('div', {
      ref: 'refBodyXSpace',
      class: 'vxe-body--x-space'
    }), h('div', {
      ref: 'refBodyYSpace',
      class: 'vxe-body--y-space'
    }), h('table', {
      ref: 'refBodyTable',
      class: 'vxe-table--body',
      attrs: {
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }
    }, [
    /**
     * 列宽
     */
    h('colgroup', {
      ref: 'refBodyColgroup'
    }, renderColumnList.map((column, $columnIndex) => {
      return h('col', {
        attrs: {
          name: column.id
        },
        key: $columnIndex,
        style: {
          width: `${column.renderWidth}px`
        }
      });
    })),
    /**
     * 内容
     */
    !(isRowLoading || isColLoading) && rowOpts.drag && rowDragOpts.animation ? h('transition-group', {
      ref: 'refBodyTBody',
      props: {
        tag: 'tbody',
        name: `vxe-body--row-list${isDragRowMove ? '' : '-disabled'}`
      }
    }, renderRows(h, this, fixedType, isOptimizeMode, renderDataList, renderColumnList)) : h('tbody', {
      ref: 'refBodyTBody'
    }, renderRows(h, this, fixedType, isOptimizeMode, renderDataList, renderColumnList))]), h('div', {
      class: 'vxe-table--checkbox-range'
    }), mouseConfig && mouseOpts.area ? h('div', {
      class: 'vxe-table--cell-area'
    }, [h('span', {
      class: 'vxe-table--cell-main-area'
    }, mouseOpts.extension ? [h('span', {
      class: 'vxe-table--cell-main-area-btn',
      on: {
        mousedown(evnt) {
          if ($xeTable.triggerCellAreaExtendMousedownEvent) {
            $xeTable.triggerCellAreaExtendMousedownEvent(evnt, {
              $table: $xeTable,
              fixed: fixedType,
              type: renderType
            });
          }
        }
      }
    })] : null), h('span', {
      class: 'vxe-table--cell-copy-area'
    }), h('span', {
      class: 'vxe-table--cell-extend-area'
    }), h('span', {
      class: 'vxe-table--cell-multi-area'
    }), h('span', {
      class: 'vxe-table--cell-active-area'
    }), h('span', {
      class: 'vxe-table--cell-row-status-area'
    })]) : body_renderEmptyElement($xeTable), !fixedType ? h('div', {
      class: 'vxe-table--empty-block',
      ref: 'emptyBlock'
    }, [h('div', {
      class: 'vxe-table--empty-content'
    }, emptyContent)]) : body_renderEmptyElement($xeTable)])]);
  }
});
;// CONCATENATED MODULE: ./packages/table/src/header.ts




const {
  renderer: header_renderer,
  renderEmptyElement: header_renderEmptyElement
} = core_.VxeUI;
const cellType = 'header';
const header_renderRows = (h, _vm, isGroup, isOptimizeMode, cols, $rowIndex) => {
  const props = _vm;
  const $xeTable = _vm.$parent;
  const $xeGrid = $xeTable.$xeGrid;
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const tableInternalData = $xeTable;
  const {
    fixedType
  } = props;
  const {
    resizable: allResizable,
    columnKey,
    headerCellClassName,
    headerCellStyle,
    showHeaderOverflow: allColumnHeaderOverflow,
    headerAlign: allHeaderAlign,
    align: allAlign,
    mouseConfig
  } = tableProps;
  const {
    currentColumn,
    dragCol,
    scrollXLoad,
    scrollYLoad,
    overflowX
  } = tableReactData;
  const {
    fullColumnIdData,
    scrollXStore
  } = tableInternalData;
  const virtualXOpts = $xeTable.computeVirtualXOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const headerCellOpts = $xeTable.computeHeaderCellOpts;
  const currCellHeight = getCellHeight(headerCellOpts.height) || defaultRowHeight;
  const {
    disabledMethod: dragDisabledMethod,
    isCrossDrag,
    isPeerDrag
  } = columnDragOpts;
  return cols.map((column, $columnIndex) => {
    const {
      type,
      showHeaderOverflow,
      headerAlign,
      align,
      filters,
      headerClassName,
      editRender,
      cellRender
    } = column;
    // const { enabled } = tooltipOpts
    const colid = column.id;
    const colRest = fullColumnIdData[colid] || {};
    const renderOpts = editRender || cellRender;
    const compConf = renderOpts ? header_renderer.get(renderOpts.name) : null;
    const isColGroup = column.children && column.children.length;
    const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
    const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
    const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
    const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : '') || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
    const showEllipsis = headOverflow === 'ellipsis';
    const showTitle = headOverflow === 'title';
    const showTooltip = headOverflow === true || headOverflow === 'tooltip';
    const hasEllipsis = showTitle || showTooltip || showEllipsis;
    let hasFilter = false;
    let firstFilterOption = null;
    if (filters) {
      firstFilterOption = filters[0];
      hasFilter = filters.some(item => item.checked);
    }
    const columnIndex = colRest.index;
    const _columnIndex = colRest._index;
    const cellParams = {
      $table: $xeTable,
      $grid: $xeGrid,
      $rowIndex,
      column,
      columnIndex,
      $columnIndex,
      _columnIndex,
      firstFilterOption,
      fixed: fixedType,
      type: cellType,
      isHidden: fixedHiddenColumn,
      hasFilter
    };
    const thAttrs = {
      colid,
      colspan: column.colSpan > 1 ? column.colSpan : null,
      rowspan: column.rowSpan > 1 ? column.rowSpan : null
    };
    const thOns = {
      click: evnt => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
      dblclick: evnt => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
    };
    const isColDragCell = columnOpts.drag && columnDragOpts.trigger === 'cell';
    let isDisabledDrag = false;
    if (isColDragCell) {
      isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
    }
    // 按下事件处理
    if (mouseConfig || isColDragCell) {
      thOns.mousedown = evnt => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
    }
    // 拖拽列事件
    if (columnOpts.drag) {
      thOns.dragstart = $xeTable.handleHeaderCellDragDragstartEvent;
      thOns.dragend = $xeTable.handleHeaderCellDragDragendEvent;
      thOns.dragover = $xeTable.handleHeaderCellDragDragoverEvent;
      if (isColDragCell) {
        thOns.mouseup = $xeTable.handleHeaderCellDragMouseupEvent;
      }
    }
    const isLastColumn = $columnIndex === cols.length - 1;
    const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
    const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
    let isVNPreEmptyStatus = false;
    if (isOptimizeMode && !isGroup) {
      if (!dragCol || dragCol.id !== colid) {
        if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
          isVNPreEmptyStatus = true;
        }
      }
    }
    const tcStyle = {};
    if (hasEllipsis) {
      tcStyle.height = `${currCellHeight}px`;
    } else {
      tcStyle.minHeight = `${currCellHeight}px`;
    }
    return h('th', {
      class: ['vxe-header--column', colid, {
        [`col--${headAlign}`]: headAlign,
        [`col--${type}`]: type,
        'col--last': isLastColumn,
        'col--fixed': column.fixed,
        'col--group': isColGroup,
        'col--ellipsis': hasEllipsis,
        'fixed--width': !isAutoCellWidth,
        'fixed--hidden': fixedHiddenColumn,
        'is--padding': isPadding,
        'is--sortable': column.sortable,
        'col--filter': !!filters,
        'is--filter-active': hasFilter,
        'is--drag-active': columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
        'is--drag-disabled': columnOpts.drag && isDisabledDrag,
        'col--current': currentColumn === column
      }, getClass(headerClassName, cellParams), getClass(headerCellClassName, cellParams)],
      attrs: thAttrs,
      style: headerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : undefined,
      on: thOns,
      key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex
    }, [h('div', {
      class: ['vxe-cell', {
        'c--title': showTitle,
        'c--tooltip': showTooltip,
        'c--ellipsis': showEllipsis
      }],
      style: tcStyle
    }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [h('div', {
      attrs: {
        colid
      },
      class: 'vxe-cell--wrapper'
    }, column.renderHeader(h, cellParams))]),
    /**
    * 列宽拖动
    */
    !fixedHiddenColumn && showResizable ? h('div', {
      class: 'vxe-cell--col-resizable',
      on: {
        mousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
        dblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
      }
    }) : header_renderEmptyElement($xeTable)]);
  });
};
function renderHeads(h, _vm, isGroup, isOptimizeMode, headerGroups) {
  const props = _vm;
  const $xeTable = _vm.$parent;
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const {
    fixedType
  } = props;
  const columnOpts = $xeTable.computeColumnOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    headerRowClassName,
    headerRowStyle
  } = tableProps;
  const {
    isColLoading,
    isDragColMove
  } = tableReactData;
  return headerGroups.map((cols, $rowIndex) => {
    const params = {
      $table: $xeTable,
      $rowIndex,
      fixed: fixedType,
      type: cellType
    };
    if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
      return h('transition-group', {
        key: $rowIndex,
        props: {
          tag: 'tr',
          name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`,
          class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ''],
          style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }
      }, header_renderRows(h, _vm, isGroup, isOptimizeMode, cols, $rowIndex));
    }
    return h('tr', {
      key: $rowIndex,
      class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ''],
      style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : undefined
    }, header_renderRows(h, _vm, isGroup, isOptimizeMode, cols, $rowIndex));
  });
}
/* harmony default export */ var header = ({
  name: 'VxeTableHeader',
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      headerColumn: []
    };
  },
  watch: {
    tableColumn() {
      this.uploadColumn();
    }
  },
  created() {
    this.uploadColumn();
  },
  mounted() {
    const _vm = this;
    const props = _vm;
    const $xeTable = _vm.$parent;
    const internalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = internalData;
    const prefix = `${fixedType || 'main'}-header-`;
    elemStore[`${prefix}wrapper`] = _vm.$refs.refElem;
    elemStore[`${prefix}scroll`] = _vm.$refs.refHeaderScroll;
    elemStore[`${prefix}table`] = _vm.$refs.refHeaderTable;
    elemStore[`${prefix}colgroup`] = _vm.$refs.refHeaderColgroup;
    elemStore[`${prefix}list`] = _vm.$refs.refHeaderTHead;
    elemStore[`${prefix}xSpace`] = _vm.$refs.refHeaderXSpace;
    elemStore[`${prefix}repair`] = _vm.$refs.refHeaderBorderRepair;
  },
  destroyed() {
    const props = this;
    const $xeTable = this.$parent;
    const internalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = internalData;
    const prefix = `${fixedType || 'main'}-header-`;
    elemStore[`${prefix}wrapper`] = null;
    elemStore[`${prefix}scroll`] = null;
    elemStore[`${prefix}table`] = null;
    elemStore[`${prefix}colgroup`] = null;
    elemStore[`${prefix}list`] = null;
    elemStore[`${prefix}xSpace`] = null;
    elemStore[`${prefix}repair`] = null;
  },
  render(h) {
    const props = this;
    const $xeTable = this.$parent;
    const tableProps = $xeTable;
    const tableReactData = $xeTable;
    const tableInternalData = $xeTable;
    const {
      xID
    } = $xeTable;
    const {
      fixedType,
      fixedColumn,
      tableColumn
    } = props;
    const {
      headerColumn
    } = this;
    const {
      mouseConfig,
      showHeaderOverflow: allColumnHeaderOverflow,
      spanMethod,
      footerSpanMethod
    } = tableProps;
    const {
      isGroup,
      isColLoading,
      overflowX,
      scrollXLoad,
      dragCol
    } = tableReactData;
    const {
      visibleColumn,
      fullColumnIdData
    } = tableInternalData;
    const mouseOpts = $xeTable.computeMouseOpts;
    let renderHeaderList = headerColumn;
    let renderColumnList = tableColumn;
    let isOptimizeMode = false;
    if (isGroup) {
      renderColumnList = visibleColumn;
    } else {
      // 如果是使用优化模式
      if (scrollXLoad && allColumnHeaderOverflow) {
        if (spanMethod || footerSpanMethod) {
          // 如果不支持优化模式
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        // 如果是使用优化模式
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      renderHeaderList = [renderColumnList];
    }
    if (!fixedType && !isGroup) {
      // 列拖拽
      if (scrollXLoad && dragCol) {
        if (renderColumnList.length > 2) {
          const dCowRest = fullColumnIdData[dragCol.id];
          if (dCowRest) {
            const dcIndex = dCowRest._index;
            const firstCol = renderColumnList[0];
            const lastCol = renderColumnList[renderColumnList.length - 1];
            const firstColRest = fullColumnIdData[firstCol.id];
            const lastColRest = fullColumnIdData[lastCol.id];
            if (firstColRest && lastColRest) {
              const fcIndex = firstColRest._index;
              const lcIndex = lastColRest._index;
              if (dcIndex < fcIndex) {
                renderColumnList = [dragCol].concat(renderColumnList);
                renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
              } else if (dcIndex > lcIndex) {
                renderColumnList = renderColumnList.concat([dragCol]);
                renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
              }
            }
          }
        }
      }
    }
    return h('div', {
      ref: 'refElem',
      class: ['vxe-table--header-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
      attrs: {
        xid: xID
      }
    }, [h('div', {
      ref: 'refHeaderScroll',
      class: 'vxe-table--header-inner-wrapper',
      on: {
        scroll(evnt) {
          $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
        }
      }
    }, [fixedType ? header_renderEmptyElement($xeTable) : h('div', {
      ref: 'refHeaderXSpace',
      class: 'vxe-body--x-space'
    }), h('table', {
      ref: 'refHeaderTable',
      class: 'vxe-table--header',
      attrs: {
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }
    }, [
    /**
     * 列宽
     */
    h('colgroup', {
      ref: 'refHeaderColgroup'
    }, renderColumnList.map((column, $columnIndex) => {
      return h('col', {
        attrs: {
          name: column.id
        },
        key: $columnIndex,
        style: {
          width: `${column.renderWidth}px`
        }
      });
    })),
    /**
     * 头部
     */
    h('thead', {
      ref: 'refHeaderTHead'
    }, renderHeads(h, this, isGroup, isOptimizeMode, renderHeaderList)), mouseConfig && mouseOpts.area ? h('div', {
      class: 'vxe-table--cell-area'
    }, [h('span', {
      class: 'vxe-table--cell-main-area'
    }), h('span', {
      class: 'vxe-table--cell-copy-area'
    }), h('span', {
      class: 'vxe-table--cell-extend-area'
    }), h('span', {
      class: 'vxe-table--cell-multi-area'
    }), h('span', {
      class: 'vxe-table--cell-active-area'
    }), h('span', {
      class: 'vxe-table--cell-col-status-area'
    })]) : header_renderEmptyElement($xeTable)])])]);
  },
  methods: {
    uploadColumn() {
      const $xeTable = this.$parent;
      const tableReactData = $xeTable;
      const {
        isGroup
      } = tableReactData;
      this.headerColumn = isGroup ? convertHeaderColumnToRows(this.tableGroupColumn) : [];
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/src/footer.ts





const footer_renderType = 'footer';
const {
  renderer: footer_renderer,
  renderEmptyElement: footer_renderEmptyElement
} = core_.VxeUI;
function footer_renderRows(h, _vm, isOptimizeMode, tableColumn, footerTableData, row, $rowIndex, _rowIndex) {
  const props = _vm;
  const $xeTable = _vm.$parent;
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const tableInternalData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    fixedType
  } = props;
  const {
    resizable: allResizable,
    border,
    footerCellClassName,
    footerCellStyle,
    footerAlign: allFooterAlign,
    footerSpanMethod,
    align: allAlign,
    columnKey,
    showFooterOverflow: allColumnFooterOverflow
  } = tableProps;
  const {
    scrollXLoad,
    scrollYLoad,
    overflowX,
    currentColumn
  } = tableReactData;
  const {
    fullColumnIdData,
    mergeFooterList,
    mergeFooterCellMaps,
    scrollXStore
  } = tableInternalData;
  const virtualXOpts = $xeTable.computeVirtualXOpts;
  const tooltipOpts = $xeTable.computeTooltipOpts;
  const resizableOpts = $xeTable.resizableOpts;
  const {
    isAllColumnDrag
  } = resizableOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const cellOpts = $xeTable.computeCellOpts;
  const footerCellOpts = $xeTable.computeFooterCellOpts;
  const currCellHeight = getCellHeight(footerCellOpts.height) || defaultRowHeight;
  return tableColumn.map((column, $columnIndex) => {
    const {
      type,
      showFooterOverflow,
      footerAlign,
      align,
      footerClassName,
      editRender,
      cellRender
    } = column;
    const colid = column.id;
    const colRest = fullColumnIdData[colid] || {};
    const renderOpts = editRender || cellRender;
    const compConf = renderOpts ? footer_renderer.get(renderOpts.name) : null;
    const showAllTip = tooltipOpts.showAll;
    const isColGroup = column.children && column.children.length;
    const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
    const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
    const footOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
    const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : '') || allFooterAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
    const showEllipsis = footOverflow === 'ellipsis';
    const showTitle = footOverflow === 'title';
    const showTooltip = footOverflow === true || footOverflow === 'tooltip';
    const hasEllipsis = showTitle || showTooltip || showEllipsis;
    const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
    const attrs = {
      colid
    };
    const tfOns = {};
    const columnIndex = colRest.index;
    const _columnIndex = colRest._index;
    const itemIndex = _columnIndex;
    const cellParams = {
      $table: $xeTable,
      $grid: $xeGrid,
      row,
      rowIndex: _rowIndex,
      _rowIndex,
      $rowIndex,
      column,
      columnIndex,
      $columnIndex,
      _columnIndex,
      itemIndex,
      items: row,
      fixed: fixedType,
      type: footer_renderType,
      data: footerTableData
    };
    if (showTitle || showTooltip || showAllTip) {
      tfOns.mouseenter = evnt => {
        if (showTitle) {
          updateCellTitle(evnt.currentTarget, column);
        } else if (showTooltip || showAllTip) {
          $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
        }
      };
    }
    if (showTooltip || showAllTip) {
      tfOns.mouseleave = evnt => {
        if (showTooltip || showAllTip) {
          $xeTable.handleTargetLeaveEvent(evnt);
        }
      };
    }
    tfOns.click = evnt => {
      $xeTable.dispatchEvent('footer-cell-click', Object.assign({
        cell: evnt.currentTarget
      }, cellParams), evnt);
    };
    tfOns.dblclick = evnt => {
      $xeTable.dispatchEvent('footer-cell-dblclick', Object.assign({
        cell: evnt.currentTarget
      }, cellParams), evnt);
    };
    let isMergeCell = false;
    // 合并行或列
    if (mergeFooterList.length) {
      const spanRest = mergeFooterCellMaps[`${_rowIndex}:${_columnIndex}`];
      if (spanRest) {
        const {
          rowspan,
          colspan
        } = spanRest;
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          isMergeCell = true;
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          isMergeCell = true;
          attrs.colspan = colspan;
        }
      }
    } else if (footerSpanMethod) {
      // 自定义合并方法
      const {
        rowspan = 1,
        colspan = 1
      } = footerSpanMethod(cellParams) || {};
      if (!rowspan || !colspan) {
        return null;
      }
      if (rowspan > 1) {
        attrs.rowspan = rowspan;
      }
      if (colspan > 1) {
        attrs.colspan = colspan;
      }
    }
    const isLastColumn = $columnIndex === tableColumn.length - 1;
    const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
    let isVNPreEmptyStatus = false;
    if (isOptimizeMode && !isMergeCell) {
      if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
        isVNPreEmptyStatus = true;
      }
    }
    const tcStyle = {};
    if (hasEllipsis) {
      tcStyle.height = `${currCellHeight}px`;
    } else {
      tcStyle.minHeight = `${currCellHeight}px`;
    }
    return h('td', {
      class: ['vxe-footer--column', column.id, {
        [`col--${footAlign}`]: footAlign,
        [`col--${type}`]: type,
        'col--last': isLastColumn,
        'fixed--width': !isAutoCellWidth,
        'fixed--hidden': fixedHiddenColumn,
        'is--padding': isPadding,
        'col--ellipsis': hasEllipsis,
        'col--current': currentColumn === column
      }, getClass(footerClassName, cellParams), getClass(footerCellClassName, cellParams)],
      attrs,
      style: footerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : undefined,
      on: tfOns,
      key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex
    }, [h('div', {
      class: ['vxe-cell', {
        'c--title': showTitle,
        'c--tooltip': showTooltip,
        'c--ellipsis': showEllipsis
      }],
      style: tcStyle
    }, isVNPreEmptyStatus ? [] : [h('div', {
      attrs: {
        colid
      },
      class: 'vxe-cell--wrapper'
    }, column.renderFooter(h, cellParams))]),
    /**
     * 列宽拖动
     */
    !fixedHiddenColumn && showResizable && isAllColumnDrag ? h('div', {
      class: ['vxe-cell--col-resizable', {
        'is--line': !border || border === 'none'
      }],
      on: {
        mousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
        dblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
      }
    }) : footer_renderEmptyElement($xeTable)]);
  });
}
function footer_renderHeads(h, _vm, isOptimizeMode, renderColumnList) {
  const props = _vm;
  const $xeTable = _vm.$parent;
  const tableProps = $xeTable;
  const tableReactData = $xeTable;
  const {
    fixedType,
    footerTableData
  } = props;
  const {
    footerRowClassName,
    footerRowStyle
  } = tableProps;
  const {
    isColLoading,
    isDragColMove
  } = tableReactData;
  const columnOpts = $xeTable.computeColumnOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  return footerTableData.map((row, $rowIndex) => {
    const _rowIndex = $rowIndex;
    const rowParams = {
      $table: $xeTable,
      row,
      _rowIndex,
      $rowIndex,
      fixed: fixedType,
      type: footer_renderType
    };
    if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
      return h('transition-group', {
        key: $rowIndex,
        props: {
          tag: 'tr',
          name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`,
          class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
          style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : undefined
        }
      }, footer_renderRows(h, _vm, isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
    }
    return h('tr', {
      key: $rowIndex,
      class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
      style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : undefined
    }, footer_renderRows(h, _vm, isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
  });
}
/* harmony default export */ var footer = ({
  name: 'VxeTableFooter',
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  mounted() {
    const _vm = this;
    const props = _vm;
    const $xeTable = _vm.$parent;
    const tableInternalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = tableInternalData;
    const prefix = `${fixedType || 'main'}-footer-`;
    elemStore[`${prefix}wrapper`] = _vm.$refs.refElem;
    elemStore[`${prefix}scroll`] = _vm.$refs.refFooterScroll;
    elemStore[`${prefix}table`] = _vm.$refs.refFooterTable;
    elemStore[`${prefix}colgroup`] = _vm.$refs.refFooterColgroup;
    elemStore[`${prefix}list`] = _vm.$refs.refFooterTFoot;
    elemStore[`${prefix}xSpace`] = _vm.$refs.refFooterXSpace;
  },
  destroyed() {
    const props = this;
    const $xeTable = this.$parent;
    const tableInternalData = $xeTable;
    const {
      fixedType
    } = props;
    const {
      elemStore
    } = tableInternalData;
    const prefix = `${fixedType || 'main'}-footer-`;
    elemStore[`${prefix}wrapper`] = null;
    elemStore[`${prefix}scroll`] = null;
    elemStore[`${prefix}table`] = null;
    elemStore[`${prefix}colgroup`] = null;
    elemStore[`${prefix}list`] = null;
    elemStore[`${prefix}xSpace`] = null;
  },
  render(h) {
    const props = this;
    const $xeTable = this.$parent;
    const tableProps = $xeTable;
    const tableReactData = $xeTable;
    const tableInternalData = $xeTable;
    const {
      xID
    } = $xeTable;
    const {
      fixedType,
      fixedColumn,
      tableColumn
    } = props;
    const {
      spanMethod,
      footerSpanMethod,
      showFooterOverflow: allColumnFooterOverflow
    } = tableProps;
    const {
      visibleColumn,
      fullColumnIdData
    } = tableInternalData;
    const {
      isGroup,
      isColLoading,
      overflowX,
      scrollXLoad,
      dragCol
    } = tableReactData;
    let renderColumnList = tableColumn;
    let isOptimizeMode = false;
    // 如果是使用优化模式
    if (scrollXLoad && allColumnFooterOverflow) {
      if (spanMethod || footerSpanMethod) {
        // 如果不支持优化模式
      } else {
        isOptimizeMode = true;
      }
    }
    if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
      renderColumnList = visibleColumn;
    }
    if (fixedType) {
      if (isOptimizeMode) {
        renderColumnList = fixedColumn || [];
      }
    }
    if (!fixedType && !isGroup) {
      // 列拖拽
      if (scrollXLoad && dragCol) {
        if (renderColumnList.length > 2) {
          const dCowRest = fullColumnIdData[dragCol.id];
          if (dCowRest) {
            const dcIndex = dCowRest._index;
            const firstCol = renderColumnList[0];
            const lastCol = renderColumnList[renderColumnList.length - 1];
            const firstColRest = fullColumnIdData[firstCol.id];
            const lastColRest = fullColumnIdData[lastCol.id];
            if (firstColRest && lastColRest) {
              const fcIndex = firstColRest._index;
              const lcIndex = lastColRest._index;
              if (dcIndex < fcIndex) {
                renderColumnList = [dragCol].concat(renderColumnList);
              } else if (dcIndex > lcIndex) {
                renderColumnList = renderColumnList.concat([dragCol]);
              }
            }
          }
        }
      }
    }
    return h('div', {
      ref: 'refElem',
      class: ['vxe-table--footer-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
      attrs: {
        xid: xID
      }
    }, [h('div', {
      ref: 'refFooterScroll',
      class: 'vxe-table--footer-inner-wrapper',
      on: {
        scroll(evnt) {
          $xeTable.triggerFooterScrollEvent(evnt, fixedType);
        }
      }
    }, [fixedType ? footer_renderEmptyElement($xeTable) : h('div', {
      ref: 'refFooterXSpace',
      class: 'vxe-body--x-space'
    }), h('table', {
      ref: 'refFooterTable',
      class: 'vxe-table--footer',
      attrs: {
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }
    }, [
    /**
     * 列宽
     */
    h('colgroup', {
      ref: 'refFooterColgroup'
    }, renderColumnList.map((column, $columnIndex) => {
      return h('col', {
        attrs: {
          name: column.id
        },
        key: $columnIndex,
        style: {
          width: `${column.renderWidth}px`
        }
      });
    })),
    /**
    * 底部
    */
    h('tfoot', {
      ref: 'refFooterTFoot'
    }, footer_renderHeads(h, this, isOptimizeMode, renderColumnList))])])]);
  }
});
;// CONCATENATED MODULE: ./packages/table/src/props.ts

const {
  getConfig: props_getConfig
} = core_.VxeUI;
/* harmony default export */ var props = ({
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => props_getConfig().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => props_getConfig().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => props_getConfig().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => props_getConfig().table.border
  },
  // 已废弃，被 cell-config.padding 替换
  padding: {
    type: Boolean,
    default: null
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => props_getConfig().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => props_getConfig().table.size || props_getConfig().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => props_getConfig().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => props_getConfig().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => props_getConfig().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => props_getConfig().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => props_getConfig().table.showHeader
  },
  // 已废弃，被 row-config.isCurrent 替换
  highlightCurrentRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentRow
  },
  // 已废弃，被 row-config.isHover 替换
  highlightHoverRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverRow
  },
  /**
   * （即将废弃）是否要高亮当前选中列
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentColumn
  },
  /**
   * （即将废弃）鼠标移到列是否要高亮显示
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverColumn
  },
  // 已废弃，直接删除
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => props_getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => props_getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => props_getConfig().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => props_getConfig().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置项
  columnConfig: Object,
  // 当前列配置项
  currentColumnConfig: Object,
  // 单元格配置项
  cellConfig: Object,
  // 表头单元格配置项
  headerCellConfig: Object,
  // 表尾单元格配置项
  footerCellConfig: Object,
  // 行配置项
  rowConfig: Object,
  // 数据聚合配置项
  aggregateConfig: Object,
  //  已废弃，被 aggregateConfig 替换
  rowGroupConfig: Object,
  // 当前行配置项
  currentRowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: [Boolean, Object],
  // 导入配置项
  importConfig: [Boolean, Object],
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: [Boolean, Object],
  // 快捷菜单配置项
  menuConfig: [Boolean, Object],
  // 在 v4 中废弃 contextMenu
  contextMenu: [Boolean, Object],
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制/粘贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: [Boolean, Object],
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: [Boolean, Object],
  // 自定义列配置项
  customConfig: Object,
  // （即将废弃）横向虚拟滚动配置项
  scrollX: Object,
  // （即将废弃）纵向虚拟滚动配置项
  scrollY: Object,
  // 横向虚拟滚动配置项
  virtualXConfig: Object,
  // 纵向虚拟滚动配置项
  virtualYConfig: Object,
  // 滚动条配置项
  scrollbarConfig: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => props_getConfig().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => props_getConfig().table.delayHover
  },
  // 额外的参数
  params: Object
});
;// CONCATENATED MODULE: ./packages/table/module/custom/panel.ts






const {
  getI18n: panel_getI18n,
  getIcon: panel_getIcon,
  renderEmptyElement: panel_renderEmptyElement
} = core_.VxeUI;
function panel_showDropTip(_vm, evnt, optEl, showLine, dragPos) {
  const {
    prevDragToChild
  } = _vm;
  const el = _vm.$refs.bodyElemRef;
  if (!el) {
    return;
  }
  const wrapperRect = el.getBoundingClientRect();
  if (optEl) {
    const dragLineEl = _vm.$refs.refDragLineElem;
    if (dragLineEl) {
      if (showLine) {
        const optRect = optEl.getBoundingClientRect();
        dragLineEl.style.display = 'block';
        dragLineEl.style.top = `${Math.max(1, optRect.y + el.scrollTop - wrapperRect.y)}px`;
        dragLineEl.style.height = `${optRect.height}px`;
        dragLineEl.style.width = `${optRect.width}px`;
        dragLineEl.setAttribute('drag-pos', dragPos);
        dragLineEl.setAttribute('drag-to-child', prevDragToChild ? 'y' : 'n');
      } else {
        dragLineEl.style.display = '';
      }
    }
  }
  const dragTipEl = _vm.$refs.refDragTipElem;
  if (dragTipEl) {
    dragTipEl.style.display = 'block';
    dragTipEl.style.top = `${Math.min(el.clientHeight + el.scrollTop - dragTipEl.clientHeight, evnt.clientY + el.scrollTop - wrapperRect.y)}px`;
    dragTipEl.style.left = `${Math.min(el.clientWidth + el.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el.scrollLeft - wrapperRect.x)}px`;
    dragTipEl.setAttribute('drag-status', showLine ? prevDragToChild ? 'sub' : 'normal' : 'disabled');
  }
}
function panel_hideDropTip(_vm) {
  const dragTipEl = _vm.$refs.refDragTipElem;
  const dragLineEl = _vm.$refs.refDragLineElem;
  if (dragTipEl) {
    dragTipEl.style.display = '';
  }
  if (dragLineEl) {
    dragLineEl.style.display = '';
  }
}
const renderDragTip = (h, _vm) => {
  const $xeTable = _vm.$xeTable;
  const dragCol = $xeTable.dragColumnRef;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  return h('div', {}, [h('div', {
    ref: 'refDragLineElem',
    class: ['vxe-table-custom-popup--drag-line', {
      'is--guides': columnDragOpts.showGuidesStatus
    }]
  }), h('div', {
    ref: 'refDragTipElem',
    class: 'vxe-table-custom-popup--drag-tip'
  }, [h('div', {
    class: 'vxe-table-custom-popup--drag-tip-wrapper'
  }, [h('div', {
    class: 'vxe-table-custom-popup--drag-tip-status'
  }, [h('span', {
    class: ['vxe-table-custom-popup--drag-tip-normal-status', panel_getIcon().TABLE_DRAG_STATUS_ROW]
  }), h('span', {
    class: ['vxe-table-custom-popup--drag-tip-sub-status', panel_getIcon().TABLE_DRAG_STATUS_SUB_ROW]
  }), h('span', {
    class: ['vxe-table-custom-popup--drag-tip-disabled-status', panel_getIcon().TABLE_DRAG_DISABLED]
  })]), h('div', {
    class: 'vxe-table-custom-popup--drag-tip-content'
  }, panel_getI18n('vxe.custom.cstmDragTarget', [dragCol && dragCol.type !== 'html' ? dragCol.getTitle() : '']))])])]);
};
const renderSimplePanel = (h, _vm) => {
  const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
  const props = _vm;
  const $xeTable = _vm.$xeTable;
  const reactData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    customStore
  } = props;
  const {
    isCustomStatus,
    customColumnList
  } = reactData;
  const customOpts = $xeTable.computeCustomOpts;
  const {
    immediate
  } = customOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    maxHeight
  } = customStore;
  const {
    checkMethod,
    visibleMethod,
    allowVisible,
    allowSort,
    allowFixed,
    trigger,
    placement
  } = customOpts;
  const isMaxFixedColumn = $xeTable.computeIsMaxFixedColumn;
  const {
    isCrossDrag
  } = columnDragOpts;
  const slots = customOpts.slots || {};
  const headerSlot = slots.header;
  const topSlot = slots.top;
  const bottomSlot = slots.bottom;
  const defaultSlot = slots.default;
  const footerSlot = slots.footer;
  const colVNs = [];
  const customWrapperOns = {};
  const isAllChecked = customStore.isAll;
  const isAllIndeterminate = customStore.isIndeterminate;
  // hover 触发
  if (trigger === 'hover') {
    customWrapperOns.mouseenter = _vm.handleWrapperMouseenterEvent;
    customWrapperOns.mouseleave = _vm.handleWrapperMouseleaveEvent;
  }
  const params = {
    $table: $xeTable,
    $grid: $xeGrid,
    columns: customColumnList,
    isAllChecked,
    isAllIndeterminate,
    isCustomStatus
  };
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
    const isVisible = visibleMethod ? visibleMethod({
      $table: $xeTable,
      column
    }) : true;
    if (isVisible) {
      const isChecked = column.renderVisible;
      const isIndeterminate = column.halfVisible;
      const isColGroup = column.children && column.children.length;
      const colTitle = formatText(column.getTitle(), 1);
      const isDisabled = checkMethod ? !checkMethod({
        $table: $xeTable,
        column
      }) : false;
      const isHidden = !isChecked;
      colVNs.push(h('li', {
        key: column.id,
        attrs: {
          colid: column.id
        },
        class: ['vxe-table-custom--option', `level--${column.level}`, {
          'is--hidden': isDisabled || isHidden,
          'is--group': isColGroup
        }],
        on: {
          dragstart: _vm.sortDragstartEvent,
          dragend: _vm.sortDragendEvent,
          dragover: _vm.sortDragoverEvent
        }
      }, [allowVisible ? h('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isChecked,
          'is--indeterminate': isIndeterminate,
          'is--disabled': isDisabled
        }],
        attrs: {
          title: panel_getI18n('vxe.custom.setting.colVisible')
        },
        on: {
          click: () => {
            if (!isDisabled) {
              _vm.changeCheckboxOption(column);
            }
          }
        }
      }, [h('span', {
        class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      })]) : panel_renderEmptyElement($xeTable), h('div', {
        class: 'vxe-table-custom--name-option'
      }, [allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h('div', {
        class: 'vxe-table-custom--sort-option'
      }, [h('span', {
        class: ['vxe-table-custom--sort-btn', {
          'is--disabled': isDisabled || isHidden || column.renderFixed
        }],
        attrs: {
          title: panel_getI18n('vxe.custom.setting.sortHelpTip')
        },
        on: isDisabled || isHidden || column.renderFixed ? {} : {
          mousedown: _vm.sortMousedownEvent,
          mouseup: _vm.sortMouseupEvent
        }
      }, [h('i', {
        class: panel_getIcon().TABLE_CUSTOM_SORT
      })])]) : panel_renderEmptyElement($xeTable), column.type === 'html' ? h('div', {
        key: '1',
        class: 'vxe-table-custom--checkbox-label',
        domProps: {
          innerHTML: colTitle
        }
      }) : h('div', {
        key: '0',
        class: 'vxe-table-custom--checkbox-label',
        attrs: {
          title: colTitle
        }
      }, colTitle)]), !parent && allowFixed ? h('div', {
        class: 'vxe-table-custom--fixed-option'
      }, [h(VxeUIButtonComponent, {
        props: {
          mode: 'text',
          icon: column.renderFixed === 'left' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
          status: column.renderFixed === 'left' ? 'primary' : '',
          disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
          title: panel_getI18n(column.renderFixed === 'left' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedLeft')
        },
        on: {
          click: () => {
            _vm.changeFixedOption(column, 'left');
          }
        }
      }), h(VxeUIButtonComponent, {
        props: {
          mode: 'text',
          icon: column.renderFixed === 'right' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
          status: column.renderFixed === 'right' ? 'primary' : '',
          disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
          title: panel_getI18n(column.renderFixed === 'right' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedRight')
        },
        on: {
          click: () => {
            _vm.changeFixedOption(column, 'right');
          }
        }
      })]) : panel_renderEmptyElement($xeTable)]));
    }
  });
  return h('div', {
    key: 'simple',
    class: ['vxe-table-custom-wrapper', `placement--${placement}`, {
      'is--active': customStore.visible
    }],
    style: maxHeight && !['left', 'right'].includes(placement || '') ? {
      maxHeight: `${maxHeight}px`
    } : {}
  }, customStore.visible ? [h('div', {
    class: 'vxe-table-custom--header'
  }, headerSlot ? $xeTable.callSlot(headerSlot, params, h) : [h('ul', {
    class: 'vxe-table-custom--panel-list'
  }, [h('li', {
    class: 'vxe-table-custom--option'
  }, [allowVisible ? h('div', {
    class: ['vxe-table-custom--checkbox-option', {
      'is--checked': isAllChecked,
      'is--indeterminate': isAllIndeterminate
    }],
    attrs: {
      title: panel_getI18n('vxe.table.allTitle')
    },
    on: {
      click: _vm.allOptionEvent
    }
  }, [h('span', {
    class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
  }), h('span', {
    class: 'vxe-checkbox--label'
  }, panel_getI18n('vxe.toolbar.customAll'))]) : h('span', {
    class: 'vxe-checkbox--label'
  }, panel_getI18n('vxe.table.customTitle'))])])]), h('div', {
    ref: 'bodyElemRef',
    class: 'vxe-table-custom--body'
  }, [topSlot ? h('div', {
    class: 'vxe-table-custom--panel-top'
  }, $xeTable.callSlot(topSlot, params, h)) : panel_renderEmptyElement($xeTable), defaultSlot ? h('div', {
    class: 'vxe-table-custom--panel-body'
  }, $xeTable.callSlot(defaultSlot, params, h)) : h('transition-group', {
    class: 'vxe-table-custom--panel-list',
    props: {
      name: 'vxe-table-custom--list',
      tag: 'ul'
    },
    on: customWrapperOns
  }, colVNs), bottomSlot ? h('div', {
    class: 'vxe-table-custom--panel-bottom'
  }, $xeTable.callSlot(bottomSlot, params, h)) : panel_renderEmptyElement($xeTable), renderDragTip(h, _vm)]), customOpts.showFooter ? h('div', {
    class: 'vxe-table-custom--footer'
  }, footerSlot ? $xeTable.callSlot(footerSlot, params, h) : [h('div', {
    class: 'vxe-table-custom--footer-buttons'
  }, [h(VxeUIButtonComponent, {
    props: {
      mode: 'text',
      content: customOpts.resetButtonText || panel_getI18n('vxe.table.customRestore'),
      disabled: !isCustomStatus
    },
    on: {
      click: _vm.resetCustomEvent
    }
  }), immediate ? h(VxeUIButtonComponent, {
    props: {
      mode: 'text',
      content: customOpts.closeButtonText || panel_getI18n('vxe.table.customClose')
    },
    on: {
      click: _vm.cancelCloseEvent
    }
  }) : h(VxeUIButtonComponent, {
    props: {
      mode: 'text',
      content: customOpts.resetButtonText || panel_getI18n('vxe.table.customCancel')
    },
    on: {
      click: _vm.cancelCustomEvent
    }
  }), immediate ? panel_renderEmptyElement($xeTable) : h(VxeUIButtonComponent, {
    props: {
      mode: 'text',
      status: 'primary',
      content: customOpts.confirmButtonText || panel_getI18n('vxe.table.customConfirm')
    },
    on: {
      click: _vm.confirmCustomEvent
    }
  })])]) : null] : []);
};
const renderPopupPanel = (h, _vm) => {
  const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
  const VxeUIDrawerComponent = core_.VxeUI.getComponent('VxeDrawer');
  const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
  const VxeUINumberInputComponent = core_.VxeUI.getComponent('VxeInput');
  const $xeTableCustomPanel = _vm;
  const props = _vm;
  const $xeTable = _vm.$xeTable;
  const tableProps = $xeTable;
  const reactData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    customStore
  } = props;
  const {
    resizable: allResizable
  } = tableProps;
  const {
    isCustomStatus,
    customColumnList
  } = reactData;
  const customOpts = $xeTable.computeCustomOpts;
  const {
    immediate
  } = customOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const {
    mode,
    modalOptions,
    drawerOptions,
    allowVisible,
    allowSort,
    allowFixed,
    allowResizable,
    checkMethod,
    visibleMethod
  } = customOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const {
    maxFixedSize
  } = columnOpts;
  const resizableOpts = $xeTable.computeResizableOpts;
  const {
    minWidth: reMinWidth,
    maxWidth: reMaxWidth
  } = resizableOpts;
  const modalOpts = Object.assign({}, modalOptions);
  const drawerOpts = Object.assign({}, drawerOptions);
  const isMaxFixedColumn = $xeTable.computeIsMaxFixedColumn;
  const {
    isCrossDrag
  } = columnDragOpts;
  const slots = customOpts.slots || {};
  const headerSlot = slots.header;
  const topSlot = slots.top;
  const bottomSlot = slots.bottom;
  const defaultSlot = slots.default;
  const footerSlot = slots.footer;
  const trVNs = [];
  const isAllChecked = customStore.isAll;
  const isAllIndeterminate = customStore.isIndeterminate;
  const params = {
    $table: $xeTable,
    $grid: $xeGrid,
    columns: customColumnList,
    isAllChecked,
    isAllIndeterminate,
    isCustomStatus
  };
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
    const isVisible = visibleMethod ? visibleMethod({
      $table: $xeTable,
      column
    }) : true;
    if (isVisible) {
      // 默认继承调整宽度
      let customMinWidth = 0;
      let customMaxWidth = 0;
      if (allowResizable) {
        const resizeParams = {
          $table: $xeTable,
          column,
          columnIndex: index,
          $columnIndex: index,
          $rowIndex: -1
        };
        if (reMinWidth) {
          customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
        }
        if (reMaxWidth) {
          customMaxWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
        }
      }
      const isChecked = column.renderVisible;
      const isIndeterminate = column.halfVisible;
      const colTitle = formatText(column.getTitle(), 1);
      const isColGroup = column.children && column.children.length;
      const isDisabled = checkMethod ? !checkMethod({
        $table: $xeTable,
        column
      }) : false;
      const isHidden = !isChecked;
      trVNs.push(h('tr', {
        key: column.id,
        attrs: {
          colid: column.id
        },
        class: [`vxe-table-custom-popup--row level--${column.level}`, {
          'is--group': isColGroup
        }],
        on: {
          dragstart: _vm.sortDragstartEvent,
          dragend: _vm.sortDragendEvent,
          dragover: _vm.sortDragoverEvent
        }
      }, [allowVisible ? h('td', {
        class: 'vxe-table-custom-popup--column-item col--visible'
      }, [h('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isChecked,
          'is--indeterminate': isIndeterminate,
          'is--disabled': isDisabled
        }],
        attrs: {
          title: panel_getI18n('vxe.custom.setting.colVisible')
        },
        on: {
          click: () => {
            if (!isDisabled) {
              _vm.changeCheckboxOption(column);
            }
          }
        }
      }, [h('span', {
        class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      })])]) : panel_renderEmptyElement($xeTable), h('td', {
        class: 'vxe-table-custom-popup--column-item col--name'
      }, [h('div', {
        class: 'vxe-table-custom-popup--name'
      }, [allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h('div', {
        class: ['vxe-table-custom-popup--column-sort-btn', {
          'is--disabled': isDisabled || isHidden || column.renderFixed
        }],
        attrs: {
          title: panel_getI18n('vxe.custom.setting.sortHelpTip')
        },
        on: isDisabled || isHidden || column.renderFixed ? {} : {
          mousedown: _vm.sortMousedownEvent,
          mouseup: _vm.sortMouseupEvent
        }
      }, [h('i', {
        class: panel_getIcon().TABLE_CUSTOM_SORT
      })]) : h('div', {
        class: 'vxe-table-custom-popup--column-sort-placeholder'
      }) : panel_renderEmptyElement($xeTable), column.type === 'html' ? h('div', {
        key: '1',
        class: 'vxe-table-custom-popup--title',
        domProps: {
          innerHTML: colTitle
        }
      }) : h('div', {
        key: '0',
        class: 'vxe-table-custom-popup--title',
        attrs: {
          title: colTitle
        }
      }, colTitle)])]), allowResizable ? h('td', {
        class: 'vxe-table-custom-popup--column-item col--resizable'
      }, [column.children && column.children.length || !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h('span', '-') : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
        props: {
          type: 'integer',
          immediate: false,
          disabled: isDisabled || isHidden,
          value: column.renderResizeWidth,
          min: customMinWidth || undefined,
          max: customMaxWidth || undefined
        },
        on: {
          modelValue(value) {
            column.renderResizeWidth = Math.max(0, Number(value));
          },
          change() {
            _vm.changeColumnWidth(column);
          }
        }
      }) : panel_renderEmptyElement($xeTableCustomPanel)]) : panel_renderEmptyElement($xeTable), allowFixed ? h('td', {
        class: 'vxe-table-custom-popup--column-item col--fixed'
      }, [parent ? h('span', '-') : h('vxe-radio-group', {
        props: {
          value: column.renderFixed || '',
          type: 'button',
          size: 'mini',
          disabled: isDisabled || isHidden,
          options: [{
            label: panel_getI18n('vxe.custom.setting.fixedLeft'),
            value: 'left',
            disabled: isDisabled || isHidden || isMaxFixedColumn
          }, {
            label: panel_getI18n('vxe.custom.setting.fixedUnset'),
            value: '',
            disabled: isDisabled || isHidden
          }, {
            label: panel_getI18n('vxe.custom.setting.fixedRight'),
            value: 'right',
            disabled: isDisabled || isHidden || isMaxFixedColumn
          }]
        },
        on: {
          input(value) {
            _vm.changeFixedOption(column, value);
          }
        }
      })]) : panel_renderEmptyElement($xeTable)]));
    }
  });
  const scopedSlots = {
    default: () => {
      if (defaultSlot) {
        return $xeTable.callSlot(defaultSlot, params, h);
      }
      return h('div', {
        ref: 'bodyElemRef',
        class: 'vxe-table-custom-popup--body'
      }, [topSlot ? h('div', {
        class: 'vxe-table-custom-popup--table-top'
      }, $xeTable.callSlot(topSlot, params, h)) : panel_renderEmptyElement($xeTable), h('div', {
        class: 'vxe-table-custom-popup--table-wrapper'
      }, [h('table', {}, [h('colgroup', {}, [allowVisible ? h('col', {
        class: 'vxe-table-custom-popup--table-col-seq'
      }) : panel_renderEmptyElement($xeTable), h('col', {
        class: 'vxe-table-custom-popup--table-col-title'
      }), allowResizable ? h('col', {
        class: 'vxe-table-custom-popup--table-col-width'
      }) : panel_renderEmptyElement($xeTable), allowFixed ? h('col', {
        class: 'vxe-table-custom-popup--table-col-fixed'
      }) : panel_renderEmptyElement($xeTable)]), h('thead', {}, [h('tr', {}, [allowVisible ? h('th', {}, [h('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        attrs: {
          title: panel_getI18n('vxe.table.allTitle')
        },
        on: {
          click: _vm.allOptionEvent
        }
      }, [h('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }), h('span', {
        class: 'vxe-checkbox--label'
      }, panel_getI18n('vxe.toolbar.customAll'))])]) : panel_renderEmptyElement($xeTable), h('th', {}, panel_getI18n('vxe.custom.setting.colTitle')), allowResizable ? h('th', {}, panel_getI18n('vxe.custom.setting.colResizable')) : panel_renderEmptyElement($xeTable), allowFixed ? h('th', {}, panel_getI18n(`vxe.custom.setting.${maxFixedSize ? 'colFixedMax' : 'colFixed'}`, [maxFixedSize])) : panel_renderEmptyElement($xeTable)])]), h('transition-group', {
        class: 'vxe-table-custom--panel-list',
        props: {
          tag: 'tbody',
          name: 'vxe-table-custom--list'
        }
      }, trVNs)])]), bottomSlot ? h('div', {
        class: 'vxe-table-custom-popup--table-bottom'
      }, $xeTable.callSlot(bottomSlot, params, h)) : panel_renderEmptyElement($xeTable), renderDragTip(h, _vm)]);
    },
    footer: () => {
      if (footerSlot) {
        return $xeTable.callSlot(footerSlot, params, h);
      }
      return h('div', {
        class: 'vxe-table-custom-popup--footer'
      }, [h(VxeUIButtonComponent, {
        props: {
          content: customOpts.resetButtonText || panel_getI18n('vxe.custom.cstmRestore'),
          disabled: !isCustomStatus
        },
        on: {
          click: _vm.resetCustomEvent
        }
      }), immediate ? h(VxeUIButtonComponent, {
        props: {
          content: customOpts.resetButtonText || panel_getI18n('vxe.table.customClose')
        },
        on: {
          click: _vm.cancelCloseEvent
        }
      }) : h(VxeUIButtonComponent, {
        props: {
          content: customOpts.resetButtonText || panel_getI18n('vxe.custom.cstmCancel')
        },
        on: {
          click: _vm.cancelCustomEvent
        }
      }), immediate ? panel_renderEmptyElement($xeTable) : h(VxeUIButtonComponent, {
        props: {
          status: 'primary',
          content: customOpts.confirmButtonText || panel_getI18n('vxe.custom.cstmConfirm')
        },
        on: {
          click: _vm.confirmCustomEvent
        }
      })]);
    }
  };
  if (headerSlot) {
    scopedSlots.header = () => $xeTable.callSlot(headerSlot, params, h);
  }
  if (mode === 'drawer') {
    return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
      key: 'drawer',
      props: {
        className: ['vxe-table-custom-drawer-wrapper', 'vxe-table--ignore-clear', drawerOpts.className || ''].join(' '),
        value: customStore.visible,
        title: drawerOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
        width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
        position: drawerOpts.position,
        resize: !!drawerOpts.resize,
        escClosable: !!drawerOpts.escClosable,
        maskClosable: !!drawerOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true
      },
      on: {
        input(value) {
          customStore.visible = value;
        }
      },
      scopedSlots
    }) : panel_renderEmptyElement($xeTableCustomPanel);
  }
  return VxeUIModalComponent ? h(VxeUIModalComponent, {
    key: 'modal',
    props: {
      className: ['vxe-table-custom-popup-wrapper', 'vxe-table--ignore-clear', modalOpts.className || ''].join(' '),
      value: customStore.visible,
      title: modalOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
      width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
      minWidth: modalOpts.minWidth || 700,
      height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
      minHeight: modalOpts.minHeight || 400,
      showZoom: modalOpts.showZoom,
      showMaximize: modalOpts.showMaximize,
      showMinimize: modalOpts.showMinimize,
      mask: modalOpts.mask,
      lockView: modalOpts.lockView,
      resize: modalOpts.resize,
      escClosable: !!modalOpts.escClosable,
      maskClosable: !!modalOpts.maskClosable,
      destroyOnClose: true,
      showFooter: true
    },
    on: {
      input(value) {
        customStore.visible = value;
      }
    },
    scopedSlots
  }) : panel_renderEmptyElement($xeTableCustomPanel);
};
/* harmony default export */ var panel = ({
  name: 'VxeTableCustomPanel',
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  inject: {
    $xeTable: {
      default: null
    }
  },
  data() {
    return {
      prevDragCol: undefined,
      prevDragToChild: false,
      prevDragPos: null
    };
  },
  computed: {},
  created() {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIDrawerComponent = core_.VxeUI.getComponent('VxeDrawer');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUINumberInputComponent = core_.VxeUI.getComponent('VxeNumberInput');
    const VxeUIRadioGroupComponent = core_.VxeUI.getComponent('VxeRadioGroup');
    this.$nextTick(() => {
      const $xeTable = this.$xeTable;
      const {
        customOpts
      } = $xeTable;
      const {
        mode
      } = customOpts;
      if (!VxeUIModalComponent && mode === 'modal') {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIDrawerComponent && mode === 'drawer') {
        errLog('vxe.error.reqComp', ['vxe-drawer']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUINumberInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-input']);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog('vxe.error.reqComp', ['vxe-radio-group']);
      }
    });
  },
  render(h) {
    const $xeTable = this.$xeTable;
    const customOpts = $xeTable.computeCustomOpts;
    if (['modal', 'drawer', 'popup'].includes(`${customOpts.mode}`)) {
      return renderPopupPanel(h, this);
    }
    return renderSimplePanel(h, this);
  },
  methods: {
    handleWrapperMouseenterEvent(evnt) {
      const $xeTable = this.$xeTable;
      const {
        customStore
      } = this;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    },
    handleWrapperMouseleaveEvent(evnt) {
      const $xeTable = this.$xeTable;
      const {
        customStore
      } = this;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    },
    getStoreData() {
      return {};
    },
    confirmCustomEvent({
      $event
    }) {
      const $xeTable = this.$xeTable;
      const reactData = $xeTable;
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('confirm', $event);
    },
    cancelCloseEvent({
      $event
    }) {
      const $xeTable = this.$xeTable;
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('close', $event);
    },
    cancelCustomEvent({
      $event
    }) {
      const $xeTable = this.$xeTable;
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('cancel', $event);
    },
    handleResetCustomEvent(evnt) {
      const $xeTable = this.$xeTable;
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('reset', evnt);
    },
    resetCustomEvent(evnt) {
      if (core_.VxeUI.modal) {
        core_.VxeUI.modal.confirm({
          content: panel_getI18n('vxe.custom.cstmConfirmRestore'),
          className: 'vxe-table--ignore-clear',
          escClosable: true
        }).then(type => {
          if (type === 'confirm') {
            this.handleResetCustomEvent(evnt);
          }
        });
      } else {
        this.handleResetCustomEvent(evnt);
      }
    },
    resetPopupCustomEvent(evnt) {
      if (core_.VxeUI.modal) {
        core_.VxeUI.modal.confirm({
          content: panel_getI18n('vxe.custom.cstmConfirmRestore'),
          className: 'vxe-table--ignore-clear',
          escClosable: true
        }).then(type => {
          if (type === 'confirm') {
            this.resetCustomEvent(evnt);
          }
        });
      } else {
        this.resetCustomEvent(evnt);
      }
    },
    handleOptionCheck(column) {
      const $xeTable = this.$xeTable;
      const reactData = $xeTable;
      const {
        customColumnList
      } = reactData;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(customColumnList, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.visible = parent.children.every(column => column.visible);
          parent.halfVisible = !parent.visible && parent.children.some(column => column.visible || column.halfVisible);
          this.handleOptionCheck(parent);
        }
      }
    },
    changeCheckboxOption(column) {
      const $xeTable = this.$xeTable;
      const reactData = $xeTable;
      const customOpts = $xeTable.computeCustomOpts;
      const isChecked = !column.renderVisible;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      this.handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    },
    changeColumnWidth(column) {
      const $xeTable = this.$xeTable;
      const reactData = $xeTable;
      const customOpts = $xeTable.computeCustomOpts;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore('update:width');
        }
      }
    },
    changeFixedOption(column, colFixed) {
      const $xeTable = this.$xeTable;
      const reactData = $xeTable;
      const isMaxFixedColumn = $xeTable.computeIsMaxFixedColumn;
      const customOpts = $xeTable.computeCustomOpts;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.fixed = '';
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:fixed');
      } else {
        if (column.renderFixed === colFixed) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    },
    allOptionEvent() {
      const $xeTable = this.$xeTable;
      $xeTable.toggleCustomAllCheckbox();
    },
    sortMousedownEvent(evnt) {
      const $xeTable = this.$xeTable;
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      this.dragCol = column;
      addClass(trEl, 'active--drag-origin');
    },
    sortMouseupEvent(evnt) {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      panel_hideDropTip(this);
      trEl.draggable = false;
      this.dragCol = null;
      removeClass(trEl, 'active--drag-origin');
    },
    sortDragstartEvent(evnt) {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
    },
    sortDragendEvent(evnt) {
      const $xeTable = this.$xeTable;
      const tableProps = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        dragCol,
        prevDragPos,
        prevDragCol,
        prevDragToChild
      } = this;
      const {
        mouseConfig
      } = tableProps;
      const {
        customColumnList
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        immediate
      } = customOpts;
      const trEl = evnt.currentTarget;
      const columnDragOpts = $xeTable.computeColumnDragOpts;
      const {
        isCrossDrag,
        isSelfToChildDrag,
        isToChildDrag,
        dragEndMethod
      } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === 'bottom' ? 1 : 0;
      if (prevDragCol && dragCol) {
        // 判断是否有拖动
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then(status => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn], column => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            // 只有实时拖拽支持跨层级
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                // 子到子
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                // 子到根
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                // 根到子
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else {
                // 根到根
              }
              const oldewMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === dragColumn.id);
              // 改变层级
              if (isSelfToChildStatus && isCrossDrag && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex
                  } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach(column => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex,
                    parent: oParent
                  } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === newColumn.id);
              if (newMatchRest) {
                const {
                  items: nCols,
                  index: nIndex,
                  parent: nParent
                } = newMatchRest;
                // 转子级
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent('column-dragend', {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {});
        }
      }
      panel_hideDropTip(this);
      this.dragCol.value = null;
      trEl.draggable = false;
      trEl.removeAttribute('drag-pos');
      removeClass(trEl, 'active--drag-target');
      removeClass(trEl, 'active--drag-origin');
    },
    sortDragoverEvent(evnt) {
      const $xeTable = this.$xeTable;
      const {
        dragCol
      } = this;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = $xeTable.computeColumnDragOpts;
      const {
        isCrossDrag,
        isToChildDrag
      } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const isControlKey = hasControlKey(evnt);
      const colid = optEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      // 是否移入有效列
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? 'top' : 'bottom';
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          panel_showDropTip(this, evnt, optEl, false, dragPos);
          return;
        }
        this.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey && immediate);
        this.prevDragCol = column;
        this.prevDragPos = dragPos;
        panel_showDropTip(this, evnt, optEl, true, dragPos);
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/filter/panel.ts



const {
  getI18n: filter_panel_getI18n,
  getIcon: filter_panel_getIcon,
  renderer: panel_renderer,
  globalMixins
} = core_.VxeUI;
function renderOptions($xeFilterPanel, h, filterRender, compConf) {
  const props = $xeFilterPanel;
  const $xeTable = $xeFilterPanel.$xeTable;
  const tableInternalData = $xeTable;
  const {
    filterStore
  } = props;
  const {
    column,
    multiple,
    maxHeight
  } = filterStore;
  const slots = column ? column.slots : null;
  const filterSlot = slots ? slots.filter : null;
  const params = Object.assign({}, tableInternalData._currFilterParams, {
    $panel: $xeFilterPanel,
    $table: $xeTable
  });
  const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
  if (filterSlot) {
    return [h('div', {
      class: 'vxe-table--filter-template',
      style: maxHeight ? {
        maxHeight: `${maxHeight}px`
      } : {}
    }, $xeTable.callSlot(filterSlot, params, h))];
  } else if (rtFilter) {
    return [h('div', {
      class: 'vxe-table--filter-template',
      style: maxHeight ? {
        maxHeight: `${maxHeight}px`
      } : {}
    }, getSlotVNs(rtFilter.call($xeTable, h, filterRender, params)))];
  }
  const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some(item => item._checked);
  const isAllIndeterminate = multiple && filterStore.isIndeterminate;
  return [h('ul', {
    class: 'vxe-table--filter-header'
  }, [h('li', {
    class: ['vxe-table--filter-option', {
      'is--checked': isAllChecked,
      'is--indeterminate': isAllIndeterminate
    }],
    attrs: {
      title: filter_panel_getI18n(multiple ? 'vxe.table.allTitle' : 'vxe.table.allFilter')
    },
    on: {
      click: evnt => {
        $xeFilterPanel.changeAllOption(evnt, !filterStore.isAllSelected);
      }
    }
  }, (multiple ? [h('span', {
    class: ['vxe-checkbox--icon', isAllIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
  })] : []).concat([h('span', {
    class: 'vxe-checkbox--label'
  }, filter_panel_getI18n('vxe.table.allFilter'))]))]), h('ul', {
    class: 'vxe-table--filter-body',
    style: maxHeight ? {
      maxHeight: `${maxHeight}px`
    } : {}
  }, filterStore.options.map(item => {
    const isChecked = item._checked;
    const isIndeterminate = false;
    return h('li', {
      class: ['vxe-table--filter-option', {
        'is--checked': isChecked
      }],
      attrs: {
        title: item.label
      },
      on: {
        click: evnt => {
          $xeFilterPanel.changeOption(evnt, !item._checked, item);
        }
      }
    }, (multiple ? [h('span', {
      class: ['vxe-checkbox--icon', isIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
    })] : []).concat([h('span', {
      class: 'vxe-checkbox--label'
    }, formatText(item.label, 1))]));
  }))];
}
function renderFooter($xeFilterPanel, h) {
  const props = $xeFilterPanel;
  const $xeTable = $xeFilterPanel.$xeTable;
  const {
    filterStore
  } = props;
  const {
    column,
    multiple
  } = filterStore;
  const filterOpts = $xeTable.computeFilterOpts;
  const hasCheckOption = $xeFilterPanel.computeHasCheckOption;
  const filterRender = column.filterRender;
  const compConf = isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
  const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
  return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [h('div', {
    class: 'vxe-table--filter-footer'
  }, [h('button', {
    class: {
      'is--disabled': isDisabled
    },
    attrs: {
      disabled: isDisabled
    },
    on: {
      click: $xeFilterPanel.confirmFilter
    }
  }, filterOpts.confirmButtonText || filter_panel_getI18n('vxe.table.confirmFilter')), h('button', {
    on: {
      click: $xeFilterPanel.resetFilter
    }
  }, filterOpts.resetButtonText || filter_panel_getI18n('vxe.table.resetFilter'))])] : [];
}
/* harmony default export */ var filter_panel = ({
  name: 'VxeTableFilterPanel',
  mixins: [globalMixins.sizeMixin],
  props: {
    filterStore: Object
  },
  inject: {
    $xeTable: {
      default: null
    }
  },
  computed: {
    computeHasCheckOption() {
      const {
        filterStore
      } = this;
      return filterStore && filterStore.options.some(option => option.checked);
    }
  },
  mounted() {
    const $xeFilterPanel = this;
    const $xeTable = $xeFilterPanel.$xeTable;
    const filterOpts = $xeTable.computeFilterOpts;
    const {
      transfer
    } = filterOpts;
    const el = this.$refs.refElem;
    if (transfer && el) {
      document.body.appendChild(el);
    }
  },
  beforeDestroy() {
    const el = this.$refs.refElem;
    if (el && el.parentNode) {
      el.parentNode.removeChild(el);
    }
  },
  render(h) {
    const $xeFilterPanel = this;
    const props = $xeFilterPanel;
    const $xeTable = $xeFilterPanel.$xeTable;
    const tableInternalData = $xeTable;
    const {
      filterStore
    } = props;
    const {
      visible,
      multiple,
      column
    } = filterStore;
    const filterRender = column ? column.filterRender : null;
    const compConf = isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
    const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : '';
    const params = Object.assign({}, tableInternalData._currFilterParams, {
      $panel: $xeFilterPanel,
      $table: $xeTable
    });
    const tableProps = $xeTable;
    const vSize = $xeFilterPanel.computeSize;
    const filterOpts = $xeTable.computeFilterOpts;
    const {
      destroyOnClose
    } = filterOpts;
    return h('div', {
      ref: 'refElem',
      class: ['vxe-table--filter-wrapper', 'filter--prevent-default', compConf && compConf.className ? compConf.className : '', getClass(filterClassName, params), {
        [`size--${vSize}`]: vSize,
        'is--animat': tableProps.animat,
        'is--multiple': multiple,
        'is--active': visible
      }],
      style: filterStore.style
    }, filterStore.visible && (destroyOnClose ? visible : true) && column ? renderOptions($xeFilterPanel, h, filterRender, compConf).concat(renderFooter($xeFilterPanel, h)) : []);
  },
  methods: {
    // 全部筛选事件
    filterCheckAllEvent(evnt, value) {
      const filterStore = this.filterStore;
      filterStore.options.forEach(option => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    },
    /*************************
     * Publish methods
     *************************/
    // （单选）筛选发生改变
    changeRadioOption(evnt, checked, item) {
      const $xeTable = this.$parent;
      const {
        filterStore
      } = this;
      filterStore.options.forEach(option => {
        option._checked = false;
      });
      item._checked = checked;
      $xeTable.checkFilterOptions();
      this.confirmFilter(evnt);
    },
    // （多选）筛选发生改变
    changeMultipleOption(evnt, checked, item) {
      const $xeTable = this.$parent;
      item._checked = checked;
      $xeTable.checkFilterOptions();
    },
    changeAllOption(evnt, checked) {
      if (this.filterStore.multiple) {
        this.filterCheckAllEvent(evnt, checked);
      } else {
        this.resetFilter(evnt);
      }
    },
    // 筛选发生改变
    changeOption(evnt, checked, item) {
      if (this.filterStore.multiple) {
        this.changeMultipleOption(evnt, checked, item);
      } else {
        this.changeRadioOption(evnt, checked, item);
      }
    },
    // 确认筛选
    confirmFilter(evnt) {
      const $xeTable = this.$parent;
      $xeTable.handleFilterConfirmFilter(evnt);
    },
    // 重置筛选
    resetFilter(evnt) {
      const $xeTable = this.$parent;
      $xeTable.handleFilterResetFilter(evnt);
    }
    /*************************
     * Publish methods
     *************************/
  }
});
;// CONCATENATED MODULE: ./packages/table/module/export/import-panel.ts




const {
  getI18n: import_panel_getI18n,
  getIcon: import_panel_getIcon,
  globalMixins: import_panel_globalMixins,
  renderEmptyElement: import_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var import_panel = ({
  name: 'VxeTableImportPanel',
  mixins: [import_panel_globalMixins.sizeMixin],
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  components: {
    // VxeModal,
    // VxeRadio
  },
  inject: {
    $xeTable: {
      default: null
    }
  },
  data() {
    return {
      loading: false
    };
  },
  computed: {
    selectName() {
      return `${this.storeData.filename}.${this.storeData.type}`;
    },
    hasFile() {
      return this.storeData.file && this.storeData.type;
    },
    parseTypeLabel() {
      const {
        storeData
      } = this;
      const {
        type,
        typeList
      } = storeData;
      if (type) {
        const selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(typeList, item => type === item.value);
        return selectItem ? selectItem.label : '*.*';
      }
      return `*.${typeList.map(item => item.value).join(', *.')}`;
    }
  },
  created() {
    const $xeTableImportPanel = this;
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    $xeTableImportPanel.$nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
    });
  },
  render(h) {
    const $xeTable = this.$parent;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      hasFile,
      loading,
      parseTypeLabel,
      defaultOptions,
      storeData,
      selectName
    } = this;
    const slots = defaultOptions.slots || {};
    const topSlot = slots.top;
    const bottomSlot = slots.bottom;
    const defaultSlot = slots.default;
    const footerSlot = slots.footer;
    return h('vxe-modal', {
      ref: 'modal',
      props: {
        id: 'VXE_IMPORT_MODAL',
        value: storeData.visible,
        title: import_panel_getI18n('vxe.import.impTitle'),
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading
      },
      on: {
        input(value) {
          storeData.visible = value;
        },
        show: this.showEvent
      },
      scopedSlots: {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? h('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params, h)) : import_panel_renderEmptyElement(this), h('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params, h) : [h('table', {
            class: 'vxe-table-export--panel-table',
            attrs: {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }
          }, [h('tbody', [h('tr', [h('td', import_panel_getI18n('vxe.import.impFile')), h('td', [hasFile ? h('div', {
            class: 'vxe-table-export--selected--file',
            attrs: {
              title: selectName
            }
          }, [h('span', selectName), h('i', {
            class: import_panel_getIcon().INPUT_CLEAR,
            on: {
              click: this.clearFileEvent
            }
          })]) : h('button', {
            ref: 'fileBtn',
            class: 'vxe-table-export--select--file',
            attrs: {
              type: 'button'
            },
            on: {
              click: this.selectFileEvent
            }
          }, import_panel_getI18n('vxe.import.impSelect'))])]), h('tr', [h('td', import_panel_getI18n('vxe.import.impType')), h('td', parseTypeLabel)]), h('tr', [h('td', import_panel_getI18n('vxe.import.impMode')), h('td', [h('vxe-select', {
            props: {
              value: defaultOptions.mode,
              options: storeData.modeList
            },
            on: {
              modelValue(value) {
                defaultOptions.mode = value;
              }
            }
          })])])])])]), bottomSlot ? h('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params, h)) : import_panel_renderEmptyElement(this)]);
        },
        footer: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params, h) : [h('div', {
            class: 'vxe-table-export--panel-btns'
          }, [h('vxe-button', {
            on: {
              click: this.cancelEvent
            }
          }, import_panel_getI18n('vxe.import.impCancel')), h('vxe-button', {
            props: {
              status: 'primary',
              disabled: !hasFile || loading
            },
            on: {
              click: this.importEvent
            }
          }, import_panel_getI18n('vxe.import.impConfirm'))])]);
        }
      }
    });
  },
  methods: {
    clearFileEvent() {
      Object.assign(this.storeData, {
        filename: '',
        sheetName: '',
        type: ''
      });
    },
    selectFileEvent() {
      const $xeTable = this.$parent;
      $xeTable.readFile(this.defaultOptions).then(params => {
        const {
          file
        } = params;
        Object.assign(this.storeData, parseFile(file), {
          file
        });
      }).catch(e => e);
    },
    showEvent() {
      this.$nextTick(() => {
        const {
          $refs
        } = this;
        const targetElem = $refs.fileBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
    },
    cancelEvent() {
      this.storeData.visible = false;
    },
    importEvent() {
      const $xeTable = this.$parent;
      this.loading = true;
      $xeTable.importByFile(this.storeData.file, Object.assign({}, $xeTable.importOpts, this.defaultOptions)).then(() => {
        this.loading = false;
        this.storeData.visible = false;
      }).catch(() => {
        this.loading = false;
      });
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/export/export-panel.ts





const {
  getI18n: export_panel_getI18n,
  getIcon: export_panel_getIcon,
  globalMixins: export_panel_globalMixins,
  renderEmptyElement: export_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var export_panel = ({
  name: 'VxeTableExportPanel',
  mixins: [export_panel_globalMixins.sizeMixin],
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  components: {
    // VxeModal,
    // VxeInput,
    // VxeCheckbox,
    // VxeSelect,
    // VxeOption
  },
  inject: {
    $xeTable: {
      default: null
    }
  },
  data() {
    return {
      isAll: false,
      isIndeterminate: false,
      loading: false
    };
  },
  computed: {
    checkedAll() {
      return this.storeData.columns.every(column => column.checked);
    },
    showSheet() {
      return ['html', 'xml', 'xlsx', 'pdf'].indexOf(this.defaultOptions.type) > -1;
    },
    supportMerge() {
      const {
        storeData,
        defaultOptions
      } = this;
      return !defaultOptions.original && defaultOptions.mode === 'current' && (storeData.isPrint || ['html', 'xlsx'].indexOf(defaultOptions.type) > -1);
    },
    // computeSupportGroup () {
    //   const { defaultOptions } = this
    //   return ['html', 'xlsx', 'csv', 'txt'].indexOf(defaultOptions.type) > -1
    // },
    supportStyle() {
      const {
        defaultOptions
      } = this;
      return !defaultOptions.original && ['xlsx'].indexOf(defaultOptions.type) > -1;
    }
  },
  created() {
    const $xeTableExportPanel = this;
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    const VxeUIInputComponent = core_.VxeUI.getComponent('VxeInput');
    const VxeUICheckboxComponent = core_.VxeUI.getComponent('VxeCheckbox');
    $xeTableExportPanel.$nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
      if (!VxeUIInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-input']);
      }
      if (!VxeUICheckboxComponent) {
        errLog('vxe.error.reqComp', ['vxe-checkbox']);
      }
    });
  },
  render(h) {
    const $xeTable = this.$xeTable;
    const $xeGrid = $xeTable.$xeGrid;
    const {
      _e,
      checkedAll,
      isAll: isAllChecked,
      isIndeterminate: isAllIndeterminate,
      showSheet,
      supportMerge,
      supportStyle,
      defaultOptions,
      storeData
    } = this;
    const {
      hasTree,
      hasMerge,
      isPrint,
      hasColgroup,
      columns
    } = storeData;
    const {
      isHeader
    } = defaultOptions;
    // const supportGroup = this.computeSupportGroup
    const slots = defaultOptions.slots || {};
    const topSlot = slots.top;
    const bottomSlot = slots.bottom;
    const defaultSlot = slots.default;
    const footerSlot = slots.footer;
    const parameterSlot = slots.parameter;
    const cols = [];
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
      const colTitle = formatText(column.getTitle(), 1);
      const isColGroup = column.children && column.children.length;
      const isChecked = column.checked;
      const indeterminate = column.halfChecked;
      const isHtml = column.type === 'html';
      cols.push(h('li', {
        class: ['vxe-table-export--panel-column-option', `level--${column.level}`, {
          'is--group': isColGroup,
          'is--checked': isChecked,
          'is--indeterminate': indeterminate,
          'is--disabled': column.disabled
        }],
        attrs: {
          title: colTitle
        },
        on: {
          click: () => {
            if (!column.disabled) {
              this.changeOption(column);
            }
          }
        }
      }, [h('span', {
        class: ['vxe-checkbox--icon', indeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }), isHtml ? h('span', {
        key: '1',
        class: 'vxe-checkbox--label',
        domProps: {
          innerHTML: colTitle
        }
      }) : h('span', {
        key: '0',
        class: 'vxe-checkbox--label'
      }, colTitle)]));
    });
    return h('vxe-modal', {
      ref: 'modal',
      props: {
        id: 'VXE_EXPORT_MODAL',
        value: storeData.visible,
        title: export_panel_getI18n(isPrint ? 'vxe.export.printTitle' : 'vxe.export.expTitle'),
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: this.loading
      },
      on: {
        input(value) {
          storeData.visible = value;
        },
        show: this.showEvent
      },
      scopedSlots: {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === 'empty';
          return h('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? h('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params, h)) : export_panel_renderEmptyElement(this), h('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params, h) : [h('table', {
            attrs: {
              class: 'vxe-table-export--panel-table',
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }
          }, [h('tbody', [[isPrint ? _e() : h('tr', [h('td', export_panel_getI18n('vxe.export.expName')), h('td', [h('vxe-input', {
            ref: 'filename',
            props: {
              value: defaultOptions.filename,
              type: 'text',
              clearable: true,
              placeholder: export_panel_getI18n('vxe.export.expNamePlaceholder')
            },
            on: {
              modelValue(value) {
                defaultOptions.filename = value;
              }
            }
          })])]), isPrint ? _e() : h('tr', [h('td', export_panel_getI18n('vxe.export.expType')), h('td', [h('vxe-select', {
            props: {
              value: defaultOptions.type,
              options: storeData.typeList
            },
            on: {
              modelValue(value) {
                defaultOptions.type = value;
              }
            }
          })])]), isPrint || showSheet ? h('tr', [h('td', export_panel_getI18n('vxe.export.expSheetName')), h('td', [h('vxe-input', {
            ref: 'sheetname',
            props: {
              value: defaultOptions.sheetName,
              type: 'text',
              clearable: true,
              placeholder: export_panel_getI18n('vxe.export.expSheetNamePlaceholder')
            },
            on: {
              modelValue(value) {
                defaultOptions.sheetName = value;
              }
            }
          })])]) : _e(), h('tr', [h('td', export_panel_getI18n('vxe.export.expMode')), h('td', [h('vxe-select', {
            props: {
              value: defaultOptions.mode,
              options: storeData.modeList
            },
            on: {
              modelValue(value) {
                defaultOptions.mode = value;
              }
            }
          })])]), h('tr', [h('td', [export_panel_getI18n('vxe.export.expColumn')]), h('td', [h('div', {
            class: 'vxe-table-export--panel-column'
          }, [h('ul', {
            class: 'vxe-table-export--panel-column-header'
          }, [h('li', {
            class: ['vxe-table-export--panel-column-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            attrs: {
              title: export_panel_getI18n('vxe.table.allTitle')
            },
            on: {
              click: this.allColumnEvent
            }
          }, [h('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          }), h('span', {
            class: 'vxe-checkbox--label'
          }, export_panel_getI18n('vxe.export.expCurrentColumn'))])]), h('ul', {
            class: 'vxe-table-export--panel-column-body'
          }, cols)])])]), h('tr', [h('td', export_panel_getI18n('vxe.export.expOpts')), parameterSlot ? h('td', [h('div', {
            class: 'vxe-table-export--panel-option-row'
          }, $xeTable.callSlot(parameterSlot, params, h))]) : h('td', [h('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [h('vxe-checkbox', {
            props: {
              value: hasEmptyData || isHeader,
              disabled: hasEmptyData,
              title: export_panel_getI18n('vxe.export.expHeaderTitle'),
              content: export_panel_getI18n('vxe.export.expOptHeader')
            },
            on: {
              input(value) {
                defaultOptions.isHeader = value;
              }
            }
          }), h('vxe-checkbox', {
            props: {
              value: isHeader ? defaultOptions.isTitle : false,
              disabled: !isHeader,
              title: export_panel_getI18n('vxe.export.expTitleTitle'),
              content: export_panel_getI18n('vxe.export.expOptTitle')
            },
            on: {
              input(value) {
                defaultOptions.isTitle = value;
              }
            }
          }), h('vxe-checkbox', {
            props: {
              value: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
              disabled: !isHeader || !hasColgroup || !supportMerge,
              title: export_panel_getI18n('vxe.export.expColgroupTitle'),
              content: export_panel_getI18n('vxe.export.expOptColgroup')
            },
            on: {
              input(value) {
                defaultOptions.isColgroup = value;
              }
            }
          })]), h('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [h('vxe-checkbox', {
            props: {
              value: hasEmptyData ? false : defaultOptions.original,
              disabled: hasEmptyData,
              title: export_panel_getI18n('vxe.export.expOriginalTitle'),
              content: export_panel_getI18n('vxe.export.expOptOriginal')
            },
            on: {
              input(value) {
                defaultOptions.original = value;
              }
            }
          }), h('vxe-checkbox', {
            props: {
              value: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
              disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
              title: export_panel_getI18n('vxe.export.expMergeTitle'),
              content: export_panel_getI18n('vxe.export.expOptMerge')
            },
            on: {
              input(value) {
                defaultOptions.isMerge = value;
              }
            }
          }), isPrint ? _e() : h('vxe-checkbox', {
            props: {
              value: supportStyle ? defaultOptions.useStyle : false,
              disabled: !supportStyle,
              title: export_panel_getI18n('vxe.export.expUseStyleTitle'),
              content: export_panel_getI18n('vxe.export.expOptUseStyle')
            },
            on: {
              input(value) {
                defaultOptions.useStyle = value;
              }
            }
          }), h('vxe-checkbox', {
            props: {
              value: hasTree ? defaultOptions.isAllExpand : false,
              disabled: hasEmptyData || !hasTree,
              title: export_panel_getI18n('vxe.export.expAllExpandTitle'),
              content: export_panel_getI18n('vxe.export.expOptAllExpand')
            },
            on: {
              input(value) {
                defaultOptions.isAllExpand = value;
              }
            }
          })]), h('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [h('vxe-checkbox', {
            props: {
              value: defaultOptions.isFooter,
              disabled: !storeData.hasFooter,
              title: export_panel_getI18n('vxe.export.expFooterTitle'),
              content: export_panel_getI18n('vxe.export.expOptFooter')
            },
            on: {
              input(value) {
                defaultOptions.isFooter = value;
              }
            }
          })])])])]])])]), bottomSlot ? h('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params, h)) : export_panel_renderEmptyElement(this)]);
        },
        footer: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params, h) : [h('div', {
            class: 'vxe-table-export--panel-btns'
          }, [h('vxe-button', {
            props: {
              content: export_panel_getI18n('vxe.export.expCancel')
            },
            on: {
              click: this.cancelEvent
            }
          }), h('vxe-button', {
            ref: 'confirmBtn',
            props: {
              status: 'primary',
              content: export_panel_getI18n(isPrint ? 'vxe.export.expPrint' : 'vxe.export.expConfirm')
            },
            on: {
              click: this.confirmEvent
            }
          })])]);
        }
      }
    });
  },
  methods: {
    changeOption(column) {
      const isChecked = !column.checked;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      this.handleOptionCheck(column);
      this.checkStatus();
    },
    handleOptionCheck(column) {
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(this.storeData.columns, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every(column => column.checked);
          parent.halfChecked = !parent.checked && parent.children.some(column => column.checked || column.halfChecked);
          this.handleOptionCheck(parent);
        }
      }
    },
    checkStatus() {
      const columns = this.storeData.columns;
      this.isAll = columns.every(column => column.disabled || column.checked);
      this.isIndeterminate = !this.isAll && columns.some(column => !column.disabled && (column.checked || column.halfChecked));
    },
    allColumnEvent() {
      const isAll = !this.isAll;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(this.storeData.columns, column => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      this.isAll = isAll;
      this.checkStatus();
    },
    showEvent() {
      this.$nextTick(() => {
        const {
          $refs
        } = this;
        const targetElem = $refs.filename || $refs.sheetname || $refs.confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      this.checkStatus();
    },
    getExportOption() {
      const {
        checkedAll,
        storeData,
        defaultOptions,
        supportMerge
      } = this;
      const {
        hasMerge,
        columns
      } = storeData;
      const expColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(columns, column => column.checked, {
        children: 'children',
        mapChildren: 'childNodes',
        original: true
      });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    },
    cancelEvent() {
      this.storeData.visible = false;
    },
    confirmEvent(evnt) {
      if (this.storeData.isPrint) {
        this.printEvent(evnt);
      } else {
        this.exportEvent(evnt);
      }
    },
    printEvent() {
      const $xeTable = this.$parent;
      this.storeData.visible = false;
      $xeTable.print(Object.assign({}, $xeTable.printOpts, this.getExportOption()));
    },
    exportEvent() {
      const $xeTable = this.$xeTable;
      const exportOpts = $xeTable.exportOpts;
      this.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, this.getExportOption())).then(() => {
        this.loading = false;
        this.storeData.visible = false;
      }).catch(() => {
        this.loading = false;
      });
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/menu/panel.ts


const {
  getIcon: menu_panel_getIcon
} = core_.VxeUI;
/* harmony default export */ var menu_panel = ({
  name: 'VxeTableMenuPanel',
  props: {
    ctxMenuStore: Object,
    ctxMenuOpts: Object
  },
  mounted() {
    document.body.appendChild(this.$el);
  },
  beforeDestroy() {
    const {
      $el
    } = this;
    if ($el.parentNode) {
      $el.parentNode.removeChild($el);
    }
  },
  render(h) {
    const $xeTable = this.$parent;
    const {
      _e,
      ctxMenuOpts,
      ctxMenuStore
    } = this;
    return h('div', {
      class: ['vxe-table--context-menu-wrapper', ctxMenuOpts.className, {
        'is--visible': ctxMenuStore.visible
      }],
      style: ctxMenuStore.style
    }, ctxMenuStore.list.map((options, gIndex) => {
      return options.every(item => item.visible === false) ? _e() : h('ul', {
        class: 'vxe-context-menu--option-wrapper',
        key: gIndex
      }, options.map((item, index) => {
        const hasChildMenus = item.children && item.children.some(child => child.visible !== false);
        const prefixOpts = Object.assign({}, item.prefixConfig);
        const suffixOpts = Object.assign({}, item.suffixConfig);
        const menuContent = getFuncText(item.name);
        return item.visible === false ? null : h('li', {
          class: [item.className, {
            'link--disabled': item.disabled,
            'link--active': item === ctxMenuStore.selected
          }],
          key: `${gIndex}_${index}`
        }, [h('a', {
          class: 'vxe-context-menu--link',
          on: {
            click(evnt) {
              $xeTable.ctxMenuLinkEvent(evnt, item);
            },
            mouseover(evnt) {
              $xeTable.ctxMenuMouseoverEvent(evnt, item);
            },
            mouseout(evnt) {
              $xeTable.ctxMenuMouseoutEvent(evnt, item);
            }
          }
        }, [h('div', {
          class: ['vxe-context-menu--link-prefix', prefixOpts.className || '']
        }, [h('i', {
          class: prefixOpts.icon || item.prefixIcon
        }), prefixOpts.content ? h('span', {}, `${prefixOpts.content}`) : _e()]), h('span', {
          class: 'vxe-context-menu--link-content',
          attrs: {
            title: menuContent
          }
        }, menuContent), h('div', {
          class: ['vxe-context-menu--link-suffix', suffixOpts.className || '']
        }, [h('i', {
          class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? menu_panel_getIcon().TABLE_MENU_OPTIONS : '')
        }), suffixOpts.content ? h('span', `${suffixOpts.content}`) : _e()])]), hasChildMenus ? h('ul', {
          class: ['vxe-table--context-menu-clild-wrapper', {
            'is--show': item === ctxMenuStore.selected && ctxMenuStore.showChild
          }]
        }, item.children.map((child, cIndex) => {
          const childPrefixOpts = Object.assign({}, child.prefixConfig);
          const childSuffixOpts = Object.assign({}, child.suffixConfig);
          const childMenuContent = getFuncText(child.name);
          return child.visible === false ? null : h('li', {
            class: [child.className, {
              'link--disabled': child.disabled,
              'link--active': child === ctxMenuStore.selectChild
            }],
            key: `${gIndex}_${index}_${cIndex}`
          }, [h('a', {
            class: 'vxe-context-menu--link',
            on: {
              click(evnt) {
                $xeTable.ctxMenuLinkEvent(evnt, child);
              },
              mouseover(evnt) {
                $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
              },
              mouseout(evnt) {
                $xeTable.ctxMenuMouseoutEvent(evnt, item);
              }
            }
          }, [h('div', {
            class: ['vxe-context-menu--link-prefix', childPrefixOpts.className || '']
          }, [h('i', {
            class: childPrefixOpts.icon || child.prefixIcon
          }), childPrefixOpts.content ? h('span', `${childPrefixOpts.content}`) : _e()]), h('span', {
            class: 'vxe-context-menu--link-content',
            attrs: {
              title: childMenuContent
            }
          }, childMenuContent), h('div', {
            class: ['vxe-context-menu--link-suffix', childSuffixOpts.className || '']
          }, [h('i', {
            class: childSuffixOpts.icon
          }), childSuffixOpts.content ? h('span', `${childSuffixOpts.content}`) : _e()])])]);
        })) : null]);
      }));
    }));
  }
});
;// CONCATENATED MODULE: ./packages/table/module/filter/mixin.ts






const {
  renderer: mixin_renderer
} = core_.VxeUI;
/* harmony default export */ var mixin = ({
  methods: {
    /**
     * 手动弹出筛选面板
     * @param column
     */
    _openFilter(fieldOrColumn) {
      const column = handleFieldOrColumn(this, fieldOrColumn);
      if (column && column.filters) {
        const {
          elemStore
        } = this;
        const {
          fixed
        } = column;
        return this.scrollToColumn(column).then(() => {
          const headerWrapperElem = elemStore[`${fixed || 'main'}-header-wrapper`] || elemStore['main-header-wrapper'];
          if (headerWrapperElem) {
            const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-cell--filter`);
            triggerEvent(filterBtnElem, 'click');
          }
        });
      }
      return this.$nextTick();
    },
    /**
     * 修改筛选条件列表
     * @param {ColumnInfo} fieldOrColumn 列
     * @param {Array} options 选项
     */
    _setFilter(fieldOrColumn, options, isUpdate) {
      const $xeTable = this;
      const column = handleFieldOrColumn(this, fieldOrColumn);
      if (column && column.filters) {
        column.filters = toFilters(options || []);
        if (isUpdate) {
          // 已废弃，即将去掉事件触发 new Event('click') -> null
          return $xeTable.handleColumnConfirmFilter(column, new Event('click'));
        }
      }
      return $xeTable.$nextTick();
    },
    checkFilterOptions() {
      const {
        filterStore
      } = this;
      filterStore.isAllSelected = filterStore.options.every(item => item._checked);
      filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some(item => item._checked);
    },
    /**
     * 点击筛选事件
     * 当筛选图标被点击时触发
     * 更新选项是否全部状态
     * 打开筛选面板
     * @param {Event} evnt 事件
     * @param {ColumnInfo} column 列配置
     * @param {Object} params 参数
     */
    triggerFilterEvent(evnt, column, params) {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        filterStore
      } = this;
      if (filterStore.column === column && filterStore.visible) {
        filterStore.visible = false;
      } else {
        const {
          initStore,
          filterStore
        } = reactData;
        const {
          elemStore
        } = internalData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const el = $xeTable.$refs.refElem;
          const {
            scrollTop,
            scrollLeft,
            visibleHeight,
            visibleWidth
          } = getDomNode();
          const filterOpts = $xeTable.computeFilterOpts;
          const {
            transfer
          } = filterOpts;
          const tableRect = el.getBoundingClientRect();
          const btnElem = evnt.currentTarget;
          const {
            filters,
            filterMultiple,
            filterRender
          } = column;
          const compConf = isEnableConf(filterRender) ? mixin_renderer.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          // 复原状态
          filterStore.options.forEach(option => {
            const {
              _checked,
              checked
            } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({
                  option,
                  column,
                  $table: $xeTable
                });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          $xeTable.$nextTick(() => {
            const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
            if (!headerScrollElem) {
              return;
            }
            const tableFilter = $xeTable.$refs.refTableFilter;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            if (!filterWrapperElem) {
              return;
            }
            const btnRect = btnElem.getBoundingClientRect();
            const filterHeadElem = filterWrapperElem.querySelector('.vxe-table--filter-header');
            const filterFootElem = filterWrapperElem.querySelector('.vxe-table--filter-footer');
            const filterWidth = filterWrapperElem.offsetWidth;
            const centerWidth = filterWidth / 2;
            let left = 0;
            let top = 0;
            let maxHeight = 0;
            if (transfer) {
              left = btnRect.left - centerWidth + scrollLeft;
              top = btnRect.top + btnElem.clientHeight + scrollTop;
              maxHeight = Math.min(Math.max(tableRect.height, Math.floor(visibleHeight / 2)), Math.max(80, visibleHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 28));
              if (left < 16) {
                left = 16;
              } else if (left > visibleWidth - filterWidth - 16) {
                left = visibleWidth - filterWidth - 16;
              }
            } else {
              left = btnRect.left - tableRect.left - centerWidth;
              top = btnRect.top - tableRect.top + btnElem.clientHeight;
              maxHeight = Math.max(40, el.clientHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 14);
              if (left < 1) {
                left = 1;
              } else if (left > el.clientWidth - filterWidth - 1) {
                left = el.clientWidth - filterWidth - 1;
              }
            }
            filterStore.style = {
              top: toCssUnit(top),
              left: toCssUnit(left)
            };
            // 判断面板不能大于表格高度
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent('filter-visible', {
          column,
          field: column.field,
          property: column.field,
          filterList: $xeTable.getCheckedFilters(),
          visible: filterStore.visible
        }, evnt);
      }
    },
    handleFilterConfirmFilter(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        filterStore
      } = reactData;
      filterStore.options.forEach(option => {
        option.checked = option._checked;
      });
      $xeTable.confirmFilterEvent(evnt);
    },
    _saveFilterPanel() {
      const $xeTable = this;
      $xeTable.handleFilterConfirmFilter(null);
      return $xeTable.$nextTick();
    },
    _saveFilterPanelByEvent(evnt) {
      const $xeTable = this;
      $xeTable.handleFilterConfirmFilter(evnt);
      return $xeTable.$nextTick();
    },
    _resetFilterPanel() {
      const $xeTable = this;
      $xeTable.handleFilterResetFilter(null);
      return $xeTable.$nextTick();
    },
    _resetFilterPanelByEvent(evnt) {
      const $xeTable = this;
      $xeTable.handleFilterResetFilter(evnt);
      return $xeTable.$nextTick();
    },
    _getCheckedFilters() {
      const {
        tableFullColumn
      } = this;
      const filterList = [];
      tableFullColumn.forEach(column => {
        const {
          field,
          filters
        } = column;
        const valueList = [];
        const dataList = [];
        if (filters && filters.length) {
          filters.forEach(item => {
            if (item.checked) {
              valueList.push(item.value);
              dataList.push(item.data);
            }
          });
          if (valueList.length) {
            filterList.push({
              column,
              field,
              property: field,
              values: valueList,
              datas: dataList
            });
          }
        }
      });
      return filterList;
    },
    handleColumnConfirmFilter(column, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const {
        mouseConfig
      } = props;
      const {
        scrollXLoad: oldScrollXLoad,
        scrollYLoad: oldScrollYLoad
      } = reactData;
      const filterOpts = $xeTable.computeFilterOpts;
      const mouseOpts = $xeTable.computeMouseOpts;
      const {
        field
      } = column;
      const values = [];
      const datas = [];
      column.filters.forEach(item => {
        if (item.checked) {
          values.push(item.value);
          datas.push(item.data);
        }
      });
      const filterList = this.getCheckedFilters();
      const params = {
        $table: this,
        $event: evnt,
        column,
        field,
        property: field,
        values,
        datas,
        filters: filterList,
        filterList
      };
      // 如果是服务端筛选，则跳过本地筛选处理
      if (!filterOpts.remote) {
        this.handleTableData(true);
        this.checkSelectionStatus();
      }
      if (mouseConfig && mouseOpts.area && this.handleFilterEvent) {
        $xeTable.handleFilterEvent(evnt, params);
      }
      if (evnt) {
        $xeTable.emitEvent('filter-change', params, evnt);
      }
      $xeTable.closeFilter();
      return $xeTable.updateFooter().then(() => {
        const {
          scrollXLoad,
          scrollYLoad
        } = this;
        if (oldScrollXLoad || scrollXLoad || oldScrollYLoad || scrollYLoad) {
          if (oldScrollXLoad || scrollXLoad) {
            $xeTable.updateScrollXSpace();
          }
          if (oldScrollYLoad || scrollYLoad) {
            $xeTable.updateScrollYSpace();
          }
          return $xeTable.refreshScroll();
        }
      }).then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate(true);
      }).then(() => {
        // 存在滚动行为未结束情况
        setTimeout(() => $xeTable.recalculate(), 50);
      });
    },
    /**
     * 确认筛选
     * 当筛选面板中的确定按钮被按下时触发
     * @param {Event} evnt 事件
     */
    confirmFilterEvent(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        filterStore
      } = reactData;
      const {
        column
      } = filterStore;
      $xeTable.handleColumnConfirmFilter(column, evnt);
    },
    handleClearFilter(column) {
      if (column) {
        const {
          filters,
          filterRender
        } = column;
        if (filters) {
          const compConf = isEnableConf(filterRender) ? mixin_renderer.get(filterRender.name) : null;
          const filterResetMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
          filters.forEach(item => {
            item._checked = false;
            item.checked = false;
            if (!filterResetMethod) {
              item.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.resetValue, true);
            }
          });
          if (filterResetMethod) {
            filterResetMethod({
              options: filters,
              column,
              $table: this
            });
          }
        }
      }
    },
    /**
     * 重置筛选
     * 当筛选面板中的重置按钮被按下时触发
     * @param {Event} evnt 事件
     */
    handleFilterResetFilter(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        filterStore
      } = reactData;
      $xeTable.handleClearFilter(filterStore.column);
      $xeTable.confirmFilterEvent(evnt);
      if (evnt) {
        $xeTable.dispatchEvent('clear-filter', {
          filterList: []
        }, evnt);
      }
    },
    /**
     * 清空指定列的筛选条件
     * 如果为空则清空所有列的筛选条件
     * @param {String} fieldOrColumn 列
     */
    _clearFilter(fieldOrColumn) {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        filterStore
      } = reactData;
      const {
        tableFullColumn
      } = internalData;
      let column;
      if (fieldOrColumn) {
        column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          $xeTable.handleClearFilter(column);
        }
      } else {
        tableFullColumn.forEach($xeTable.handleClearFilter);
      }
      if (!fieldOrColumn || column !== filterStore.column) {
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          style: null,
          options: [],
          column: null,
          multiple: false,
          visible: false
        });
      }
      return $xeTable.updateData();
    },
    _updateFilterOptionStatus(item, checked) {
      const $xeTable = this;
      item._checked = checked;
      item.checked = checked;
      return $xeTable.$nextTick();
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/menu/mixin.ts





const {
  menus: mixin_menus,
  globalEvents: mixin_globalEvents,
  GLOBAL_EVENT_KEYS
} = core_.VxeUI;
/* harmony default export */ var menu_mixin = ({
  methods: {
    /**
     * 关闭快捷菜单
     */
    _closeMenu() {
      Object.assign(this.ctxMenuStore, {
        visible: false,
        selected: null,
        selectChild: null,
        showChild: false
      });
      return this.$nextTick();
    },
    // 处理菜单的移动
    moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
      const $xeTable = this;
      let selectItem;
      const selectIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(menuList, item => ctxMenuStore[property] === item);
      if (hasOper) {
        if (operRest && hasChildrenList(ctxMenuStore.selected)) {
          ctxMenuStore.showChild = true;
        } else {
          ctxMenuStore.showChild = false;
          ctxMenuStore.selectChild = null;
        }
      } else if (mixin_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        for (let len = selectIndex - 1; len >= 0; len--) {
          if (menuList[len].visible !== false) {
            selectItem = menuList[len];
            break;
          }
        }
        ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
      } else if (mixin_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        for (let index = selectIndex + 1; index < menuList.length; index++) {
          if (menuList[index].visible !== false) {
            selectItem = menuList[index];
            break;
          }
        }
        ctxMenuStore[property] = selectItem || menuList[0];
      } else if (ctxMenuStore[property] && (mixin_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER) || mixin_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR))) {
        $xeTable.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
      }
    },
    /**
     * 快捷菜单事件处理
     */
    handleGlobalContextmenuEvent(evnt) {
      const $xeTable = this;
      const $xeGrid = $xeTable.$xeGrid;
      const internalData = $xeTable;
      const {
        $refs,
        tId,
        editStore,
        menuConfig,
        contextMenu,
        ctxMenuStore,
        ctxMenuOpts,
        mouseConfig,
        mouseOpts
      } = this;
      const {
        selected
      } = editStore;
      const tableFilter = $xeTable.$refs.refTableFilter;
      const layoutList = ['header', 'body', 'footer'];
      if (isEnableConf(menuConfig) || contextMenu) {
        if (ctxMenuStore.visible && $refs.refTableMenu && getEventTargetNode(evnt, $refs.refTableMenu.$el).flag) {
          evnt.preventDefault();
          return;
        }
        if (internalData._keyCtx) {
          const type = 'body';
          const params = {
            type,
            $grid: $xeGrid,
            $table: this,
            keyboard: true,
            columns: this.visibleColumn.slice(0),
            $event: evnt
          };
          // 如果开启单元格区域
          if (mouseConfig && mouseOpts.area) {
            const activeArea = this.getActiveCellArea();
            if (activeArea && activeArea.row && activeArea.column) {
              params.row = activeArea.row;
              params.column = activeArea.column;
              this.handleOpenMenuEvent(evnt, type, params);
              return;
            }
          } else if (mouseConfig && mouseOpts.selected) {
            // 如果启用键盘导航且已选中单元格
            if (selected.row && selected.column) {
              params.row = selected.row;
              params.column = selected.column;
              this.handleOpenMenuEvent(evnt, type, params);
              return;
            }
          }
        }
        // 分别匹配表尾、内容、表尾的快捷菜单
        for (let index = 0; index < layoutList.length; index++) {
          const layout = layoutList[index];
          const columnTargetNode = getEventTargetNode(evnt, this.$el, `vxe-${layout}--column`, target => {
            // target=td|th，直接向上找 table 去匹配即可
            return target.parentNode.parentNode.parentNode.getAttribute('xid') === tId;
          });
          const params = {
            type: layout,
            $grid: $xeGrid,
            $table: this,
            columns: this.visibleColumn.slice(0),
            $event: evnt
          };
          if (columnTargetNode.flag) {
            const cell = columnTargetNode.targetElem;
            const column = this.getColumnNode(cell).item;
            let typePrefix = `${layout}-`;
            Object.assign(params, {
              column,
              columnIndex: this.getColumnIndex(column),
              cell
            });
            if (layout === 'body') {
              const row = this.getRowNode(cell.parentNode).item;
              typePrefix = '';
              params.row = row;
              params.rowIndex = this.getRowIndex(row);
            }
            this.handleOpenMenuEvent(evnt, layout, params);
            // 在 v4 中废弃事件 cell-context-menu、header-cell-context-menu、footer-cell-context-menu
            if (this.$listeners[`${typePrefix}cell-context-menu`]) {
              warnLog('vxe.error.delEvent', [`${typePrefix}cell-context-menu`, `${typePrefix}cell-menu`]);
              this.emitEvent(`${typePrefix}cell-context-menu`, params, evnt);
            } else {
              this.emitEvent(`${typePrefix}cell-menu`, params, evnt);
            }
            return;
          } else if (getEventTargetNode(evnt, this.$el, `vxe-table--${layout}-wrapper`, target => target.getAttribute('xid') === tId).flag) {
            if (ctxMenuOpts.trigger === 'cell') {
              evnt.preventDefault();
            } else {
              this.handleOpenMenuEvent(evnt, layout, params);
            }
            return;
          }
        }
      }
      if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
        this.closeFilter();
      }
      this.closeMenu();
    },
    /**
     * 显示快捷菜单
     */
    handleOpenMenuEvent(evnt, type, params) {
      const {
        isCtxMenu,
        ctxMenuStore,
        ctxMenuOpts
      } = this;
      const config = ctxMenuOpts[type];
      const visibleMethod = ctxMenuOpts.visibleMethod;
      if (config) {
        const {
          options,
          disabled
        } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isCtxMenu && options && options.length) {
          params.options = options;
          this.preventEvent(evnt, 'event.showMenu', params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              this.updateZindex();
              const {
                scrollTop,
                scrollLeft,
                visibleHeight,
                visibleWidth
              } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                Object.assign(ctxMenuStore, {
                  args: params,
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: this.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                this.$nextTick(() => {
                  const ctxElem = this.$refs.refTableMenu.$el;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const {
                    boundingTop,
                    boundingLeft
                  } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const {
                keyboard,
                row,
                column
              } = params;
              if (keyboard && row && column) {
                this.scrollToRow(row, column).then(() => {
                  const cell = this.getCellElement(row, column);
                  const {
                    boundingTop,
                    boundingLeft
                  } = getAbsolutePos(cell);
                  top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                  left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              this.closeMenu();
            }
          });
        }
      }
      this.closeFilter();
    },
    ctxMenuMouseoverEvent(evnt, item, child) {
      const menuElem = evnt.currentTarget;
      const ctxMenuStore = this.ctxMenuStore;
      evnt.preventDefault();
      evnt.stopPropagation();
      ctxMenuStore.selected = item;
      ctxMenuStore.selectChild = child;
      if (!child) {
        ctxMenuStore.showChild = hasChildrenList(item);
        if (ctxMenuStore.showChild) {
          this.$nextTick(() => {
            const childWrapperElem = menuElem.nextElementSibling;
            if (childWrapperElem) {
              const {
                boundingTop,
                boundingLeft,
                visibleHeight,
                visibleWidth
              } = getAbsolutePos(menuElem);
              const posTop = boundingTop + menuElem.offsetHeight;
              const posLeft = boundingLeft + menuElem.offsetWidth;
              let left = '';
              let right = '';
              // 是否超出右侧
              if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                left = 'auto';
                right = `${menuElem.offsetWidth}px`;
              }
              // 是否超出底部
              let top = '';
              let bottom = '';
              if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                top = 'auto';
                bottom = '0';
              }
              childWrapperElem.style.left = left;
              childWrapperElem.style.right = right;
              childWrapperElem.style.top = top;
              childWrapperElem.style.bottom = bottom;
            }
          });
        }
      }
    },
    ctxMenuMouseoutEvent(evnt, item) {
      const ctxMenuStore = this.ctxMenuStore;
      if (!item.children) {
        ctxMenuStore.selected = null;
      }
      ctxMenuStore.selectChild = null;
    },
    /**
     * 快捷菜单点击事件
     */
    ctxMenuLinkEvent(evnt, menu) {
      const $xeTable = this;
      const $xeGrid = $xeTable.$xeGrid;
      // 如果一级菜单有配置 code 则允许点击，否则不能点击
      if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
        const gMenuOpts = mixin_menus.get(menu.code);
        const params = Object.assign({
          menu,
          $grid: $xeGrid,
          $table: this,
          $event: evnt
        }, this.ctxMenuStore.args);
        if (gMenuOpts && gMenuOpts.menuMethod) {
          gMenuOpts.menuMethod(params, evnt);
        }
        // 在 v4 中废弃事件 context-menu-click
        if (this.$listeners['context-menu-click']) {
          warnLog('vxe.error.delEvent', ['context-menu-click', 'menu-click']);
          this.emitEvent('context-menu-click', params, evnt);
        } else {
          this.emitEvent('menu-click', params, evnt);
        }
        this.closeMenu();
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/edit/mixin.ts







const {
  getConfig: mixin_getConfig,
  renderer: edit_mixin_renderer,
  getI18n: mixin_getI18n
} = core_.VxeUI;
const mixin_browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
function getEditColumnModel(row, column) {
  const {
    model,
    editRender
  } = column;
  if (editRender) {
    model.value = getCellValue(row, column);
    model.update = false;
  }
}
function setEditColumnModel(row, column) {
  const {
    model,
    editRender
  } = column;
  if (editRender && model.update) {
    setCellValue(row, column, model.value);
    model.update = false;
    model.value = null;
  }
}
function removeCellSelectedClass($xeTable) {
  const el = $xeTable.$refs.refElem;
  if (el) {
    const cell = el.querySelector('.col--selected');
    if (cell) {
      removeClass(cell, 'col--selected');
    }
  }
}
function syncActivedCell($xeTable) {
  const reactData = $xeTable;
  const {
    editStore,
    tableColumn
  } = reactData;
  const editOpts = $xeTable.computeEditOpts;
  const {
    actived
  } = editStore;
  const {
    row,
    column
  } = actived;
  if (row || column) {
    if (editOpts.mode === 'row') {
      tableColumn.forEach(column => setEditColumnModel(row, column));
    } else {
      setEditColumnModel(row, column);
    }
  }
}
function insertTreeRow($xeTable, newRecords, isAppend) {
  const internalData = $xeTable;
  const {
    tableFullTreeData,
    afterFullData,
    fullDataRowIdData,
    fullAllDataRowIdData
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    rowField,
    parentField,
    mapChildrenField
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const funcName = isAppend ? 'push' : 'unshift';
  newRecords.forEach(item => {
    const parentRowId = item[parentField];
    const rowid = getRowid($xeTable, item);
    const matchObj = parentRowId ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => parentRowId === item[rowField], {
      children: mapChildrenField
    }) : null;
    if (matchObj) {
      const {
        item: parentRow
      } = matchObj;
      const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
      const parentLevel = parentRest ? parentRest.level : 0;
      let parentChilds = parentRow[childrenField];
      let mapChilds = parentRow[mapChildrenField];
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(parentChilds)) {
        parentChilds = parentRow[childrenField] = [];
      }
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(mapChilds)) {
        mapChilds = parentRow[childrenField] = [];
      }
      parentChilds[funcName](item);
      mapChilds[funcName](item);
      const rest = {
        row: item,
        rowid,
        seq: -1,
        index: -1,
        _index: -1,
        $index: -1,
        treeIndex: -1,
        items: parentChilds,
        parent: parentRow,
        level: parentLevel + 1,
        height: 0,
        resizeHeight: 0,
        oTop: 0,
        expandHeight: 0
      };
      fullDataRowIdData[rowid] = rest;
      fullAllDataRowIdData[rowid] = rest;
    } else {
      if (parentRowId) {
        warnLog('vxe.error.unableInsert');
      }
      afterFullData[funcName](item);
      tableFullTreeData[funcName](item);
      const rest = {
        row: item,
        rowid,
        seq: -1,
        index: -1,
        _index: -1,
        $index: -1,
        treeIndex: -1,
        items: tableFullTreeData,
        parent: null,
        level: 0,
        height: 0,
        resizeHeight: 0,
        oTop: 0,
        expandHeight: 0
      };
      fullDataRowIdData[rowid] = rest;
      fullAllDataRowIdData[rowid] = rest;
    }
  });
}
function handleInsertRowAt($xeTable, records, targetRow, isInsertNextRow) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    treeConfig
  } = props;
  const {
    tableFullTreeData,
    afterFullData,
    mergeBodyList,
    tableFullData,
    fullDataRowIdData,
    fullAllDataRowIdData,
    insertRowMaps
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    transform,
    rowField,
    mapChildrenField
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
    records = [records];
  }
  const newRecords = $xeTable.defineField(records.map(record => Object.assign(treeConfig && transform ? {
    [mapChildrenField]: [],
    [childrenField]: []
  } : {}, record)));
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(targetRow)) {
    // 如果为虚拟树
    if (treeConfig && transform) {
      insertTreeRow($xeTable, newRecords, false);
    } else {
      newRecords.forEach(item => {
        const rowid = getRowid($xeTable, item);
        const rest = {
          row: item,
          rowid,
          seq: -1,
          index: -1,
          _index: -1,
          $index: -1,
          treeIndex: -1,
          items: afterFullData,
          parent: null,
          level: 0,
          height: 0,
          resizeHeight: 0,
          oTop: 0,
          expandHeight: 0
        };
        fullDataRowIdData[rowid] = rest;
        fullAllDataRowIdData[rowid] = rest;
        afterFullData.unshift(item);
        tableFullData.unshift(item);
      });
      // 刷新单元格合并
      mergeBodyList.forEach(mergeItem => {
        const {
          row: mergeRowIndex
        } = mergeItem;
        if (mergeRowIndex > 0) {
          mergeItem.row = mergeRowIndex + newRecords.length;
        }
      });
    }
  } else {
    if (targetRow === -1) {
      // 如果为虚拟树
      if (treeConfig && transform) {
        insertTreeRow($xeTable, newRecords, true);
      } else {
        newRecords.forEach(item => {
          const rowid = getRowid($xeTable, item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            treeIndex: -1,
            items: afterFullData,
            parent: null,
            level: 0,
            height: 0,
            resizeHeight: 0,
            oTop: 0,
            expandHeight: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
          afterFullData.push(item);
          tableFullData.push(item);
        });
        // 刷新单元格合并
        mergeBodyList.forEach(mergeItem => {
          const {
            row: mergeRowIndex,
            rowspan: mergeRowspan
          } = mergeItem;
          if (mergeRowIndex + mergeRowspan > afterFullData.length) {
            mergeItem.rowspan = mergeRowspan + newRecords.length;
          }
        });
      }
    } else {
      // 如果为虚拟树
      if (treeConfig && transform) {
        const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
          children: mapChildrenField
        });
        if (matchMapObj) {
          const {
            parent: parentRow
          } = matchMapObj;
          const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          newRecords.forEach((item, i) => {
            const rowid = getRowid($xeTable, item);
            if (item[treeOpts.parentField]) {
              if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                errLog('vxe.error.errProp', [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
              }
            }
            if (parentRow) {
              item[treeOpts.parentField] = parentRow[rowField];
            }
            let targetIndex = matchMapObj.index + i;
            if (isInsertNextRow) {
              targetIndex = targetIndex + 1;
            }
            parentMapChilds.splice(targetIndex, 0, item);
            const rest = {
              row: item,
              rowid,
              seq: -1,
              index: -1,
              _index: -1,
              $index: -1,
              treeIndex: -1,
              items: parentMapChilds,
              parent: parentRow,
              level: parentLevel + 1,
              height: 0,
              resizeHeight: 0,
              oTop: 0,
              expandHeight: 0
            };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          });
          // 源
          if (parentRow) {
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
              children: childrenField
            });
            if (matchObj) {
              const parentChilds = matchObj.items;
              let targetIndex = matchObj.index;
              if (isInsertNextRow) {
                targetIndex = targetIndex + 1;
              }
              parentChilds.splice(targetIndex, 0, ...newRecords);
            }
          }
        } else {
          warnLog('vxe.error.unableInsert');
          insertTreeRow($xeTable, newRecords, true);
        }
      } else {
        if (treeConfig) {
          throw new Error(mixin_getI18n('vxe.error.noTree', ['insert']));
        }
        let afIndex = -1;
        // 如果是可视索引
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRow)) {
          if (targetRow < afterFullData.length) {
            afIndex = targetRow;
          }
        } else {
          afIndex = $xeTable.findRowIndexOf(afterFullData, targetRow);
        }
        // 如果是插入指定行的下一行
        if (isInsertNextRow) {
          afIndex = Math.min(afterFullData.length, afIndex + 1);
        }
        if (afIndex === -1) {
          throw new Error(errLog('vxe.error.unableInsert'));
        }
        afterFullData.splice(afIndex, 0, ...newRecords);
        const tfIndex = $xeTable.findRowIndexOf(tableFullData, targetRow);
        if (tfIndex > -1) {
          tableFullData.splice(tfIndex + (isInsertNextRow ? 1 : 0), 0, ...newRecords);
        } else {
          tableFullData.push(...newRecords);
        }
        // 刷新单元格合并
        mergeBodyList.forEach(mergeItem => {
          const {
            row: mergeRowIndex,
            rowspan: mergeRowspan
          } = mergeItem;
          if (mergeRowIndex > afIndex) {
            mergeItem.row = mergeRowIndex + newRecords.length;
          } else if (mergeRowIndex + mergeRowspan > afIndex) {
            mergeItem.rowspan = mergeRowspan + newRecords.length;
          }
        });
      }
    }
  }
  newRecords.forEach(newRow => {
    const rowid = getRowid($xeTable, newRow);
    insertRowMaps[rowid] = newRow;
  });
  reactData.insertRowFlag++;
  $xeTable.cacheRowMap(false);
  $xeTable.updateScrollYStatus();
  $xeTable.handleTableData(treeConfig && transform);
  if (!(treeConfig && transform)) {
    $xeTable.updateAfterDataIndex();
  }
  $xeTable.updateFooter();
  $xeTable.handleUpdateBodyMerge();
  $xeTable.checkSelectionStatus();
  if (reactData.scrollYLoad) {
    $xeTable.updateScrollYSpace();
  }
  return $xeTable.$nextTick().then(() => {
    $xeTable.updateCellAreas();
    return $xeTable.recalculate();
  }).then(() => {
    return {
      row: newRecords.length ? newRecords[newRecords.length - 1] : null,
      rows: newRecords
    };
  });
}
function handleInsertChildRowAt($xeTable, records, parentRow, targetRow, isInsertNextRow) {
  const props = $xeTable;
  const {
    treeConfig
  } = props;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    transform,
    rowField,
    parentField
  } = treeOpts;
  if (treeConfig && transform) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
      records = [records];
    }
    return handleInsertRowAt($xeTable, records.map(item => Object.assign({}, item, {
      [parentField]: parentRow[rowField]
    })), targetRow, isInsertNextRow);
  } else {
    errLog('vxe.error.errProp', ['tree-config.transform=false', 'tree-config.transform=true']);
  }
  return Promise.resolve({
    row: null,
    rows: []
  });
}
function handleClearEdit($xeTable, evnt, targetRow) {
  const reactData = $xeTable;
  const {
    editStore
  } = reactData;
  const {
    actived,
    focused
  } = editStore;
  const {
    row,
    column
  } = actived;
  const validOpts = $xeTable.computeValidOpts;
  if (row || column) {
    if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
      return $xeTable.$nextTick();
    }
    syncActivedCell($xeTable);
    actived.args = null;
    actived.row = null;
    actived.column = null;
    $xeTable.updateFooter();
    $xeTable.dispatchEvent('edit-closed', {
      row,
      rowIndex: $xeTable.getRowIndex(row),
      $rowIndex: $xeTable.getVMRowIndex(row),
      column,
      columnIndex: $xeTable.getColumnIndex(column),
      $columnIndex: $xeTable.getVMColumnIndex(column)
    }, evnt || null);
  }
  focused.row = null;
  focused.column = null;
  if (validOpts.autoClear) {
    if (validOpts.msgMode !== 'full' || mixin_getConfig().cellVaildMode === 'obsolete') {
      if ($xeTable.clearValidate) {
        return $xeTable.clearValidate();
      }
    }
  }
  return $xeTable.$nextTick().then(() => $xeTable.updateCellAreas());
}
function handleEditActive($xeTable, params, evnt, isFocus, isPos) {
  const props = $xeTable;
  const reactData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    editConfig,
    mouseConfig
  } = props;
  const {
    editStore,
    tableColumn
  } = reactData;
  const editOpts = $xeTable.computeEditOpts;
  const {
    mode
  } = editOpts;
  const {
    actived,
    focused
  } = editStore;
  const {
    row,
    column
  } = params;
  const {
    editRender
  } = column;
  const cell = params.cell || $xeTable.getCellElement(row, column);
  const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
  params.cell = cell;
  if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
    // 激活编辑
    if (!$xeTable.isPendingByRow(row) && !$xeTable.isAggregateRecord(row)) {
      if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {
        // 判断是否禁用编辑
        let type = 'edit-disabled';
        if (!beforeEditMethod || beforeEditMethod({
          ...params,
          $table: $xeTable,
          $grid: $xeGrid
        })) {
          if (mouseConfig) {
            $xeTable.clearSelected();
            if ($xeTable.clearCellAreas) {
              $xeTable.clearCellAreas();
              $xeTable.clearCopyCellArea();
            }
          }
          $xeTable.closeTooltip();
          if (actived.column) {
            handleClearEdit($xeTable, evnt);
          }
          type = 'edit-activated';
          column.renderHeight = cell.offsetHeight;
          actived.args = params;
          actived.row = row;
          actived.column = column;
          if (mode === 'row') {
            tableColumn.forEach(column => getEditColumnModel(row, column));
          } else {
            getEditColumnModel(row, column);
          }
          const afterEditMethod = editOpts.afterEditMethod;
          $xeTable.$nextTick(() => {
            if (isFocus) {
              $xeTable.handleFocus(params, evnt);
            }
            if (afterEditMethod) {
              afterEditMethod({
                ...params,
                $table: $xeTable,
                $grid: $xeGrid
              });
            }
          });
        }
        $xeTable.dispatchEvent(type, {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt);
        // v4已废弃
        if (type === 'edit-activated') {
          $xeTable.dispatchEvent('edit-actived', {
            row,
            rowIndex: $xeTable.getRowIndex(row),
            $rowIndex: $xeTable.getVMRowIndex(row),
            column,
            columnIndex: $xeTable.getColumnIndex(column),
            $columnIndex: $xeTable.getVMColumnIndex(column)
          }, evnt);
        }
      } else {
        const {
          column: oldColumn
        } = actived;
        if (mouseConfig) {
          $xeTable.clearSelected();
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        if (oldColumn !== column) {
          const {
            model: oldModel
          } = oldColumn;
          if (oldModel.update) {
            setCellValue(row, oldColumn, oldModel.value);
          }
          if ($xeTable.clearValidate) {
            $xeTable.clearValidate(row, column);
          }
        }
        column.renderHeight = cell.offsetHeight;
        actived.args = params;
        actived.column = column;
        if (isPos) {
          setTimeout(() => {
            $xeTable.handleFocus(params, evnt);
          });
        }
      }
      focused.column = null;
      focused.row = null;
      $xeTable.focus();
    }
  }
  return $xeTable.$nextTick();
}
function handleEditCell($xeTable, row, fieldOrColumn, isPos) {
  const props = $xeTable;
  const internalData = $xeTable;
  const {
    editConfig
  } = props;
  const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender) && !$xeTable.isAggregateRecord(row)) {
    return Promise.resolve(isPos ? $xeTable.scrollToRow(row, column) : null).then(() => {
      const cell = $xeTable.getCellElement(row, column);
      if (cell) {
        handleEditActive($xeTable, {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          cell,
          $table: $xeTable
        }, null, isPos, isPos);
        internalData._lastCallTime = Date.now();
      }
      return $xeTable.$nextTick();
    });
  }
  return $xeTable.$nextTick();
}
/* harmony default export */ var edit_mixin = ({
  methods: {
    /**
     * 往表格中插入临时数据
     *
     * @param {*} records
     */
    _insert(records) {
      return handleInsertRowAt(this, records, null);
    },
    /**
     * 往表格指定行中插入临时数据
     * 如果 row 为空则从插入到顶部
     * 如果 row 为 -1 则从插入到底部
     * 如果 row 为有效行则插入到该行的位置
     * @param {Object/Array} records 新的数据
     * @param {Row} targetRow 指定行
     * @returns
     */
    _insertAt(records, targetRow) {
      return handleInsertRowAt(this, records, targetRow);
    },
    _insertNextAt(records, targetRow) {
      return handleInsertRowAt(this, records, targetRow, true);
    },
    _insertChild(records, parentRow) {
      return handleInsertChildRowAt(this, records, parentRow, null);
    },
    _insertChildAt(records, parentRow, targetRow) {
      return handleInsertChildRowAt(this, records, parentRow, targetRow);
    },
    _insertChildNextAt(records, parentRow, targetRow) {
      return handleInsertChildRowAt(this, records, parentRow, targetRow, true);
    },
    /**
     * 删除指定行数据
     * 如果传 row 则删除一行
     * 如果传 rows 则删除多行
     * 如果为空则删除所有
     */
    _remove(rows) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        treeConfig
      } = props;
      const {
        editStore
      } = reactData;
      const {
        tableFullTreeData,
        selectCheckboxMaps,
        afterFullData,
        mergeBodyList,
        tableFullData,
        pendingRowMaps,
        insertRowMaps,
        removeRowMaps
      } = internalData;
      const checkboxOpts = $xeTable.computeCheckboxOpts;
      const treeOpts = $xeTable.computeTreeOpts;
      const {
        transform,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const {
        actived
      } = editStore;
      const {
        checkField
      } = checkboxOpts;
      let delList = [];
      if (!rows) {
        rows = tableFullData;
      } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      // 如果是新增，则保存记录
      rows.forEach(row => {
        if (!$xeTable.isInsertByRow(row)) {
          const rowid = getRowid($xeTable, row);
          removeRowMaps[rowid] = row;
        }
      });
      // 如果绑定了多选属性，则更新状态
      if (!checkField) {
        rows.forEach(row => {
          const rowid = getRowid(this, row);
          if (selectCheckboxMaps[rowid]) {
            delete selectCheckboxMaps[rowid];
          }
        });
        reactData.updateCheckboxFlag++;
      }
      // 从数据源中移除
      if (tableFullData === rows) {
        rows = delList = tableFullData.slice(0);
        this.tableFullData = [];
        this.afterFullData = [];
        this.clearMergeCells();
      } else {
        // 如果为虚拟树
        if (treeConfig && transform) {
          rows.forEach(row => {
            const rowid = getRowid(this, row);
            const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid(this, item), {
              children: mapChildrenField
            });
            if (matchMapObj) {
              const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
              delList.push(rItems[0]);
            }
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid(this, item), {
              children: childrenField
            });
            if (matchObj) {
              matchObj.items.splice(matchObj.index, 1);
            }
            const afIndex = this.findRowIndexOf(afterFullData, row);
            if (afIndex > -1) {
              afterFullData.splice(afIndex, 1);
            }
          });
        } else {
          rows.forEach(row => {
            const tfIndex = this.findRowIndexOf(tableFullData, row);
            if (tfIndex > -1) {
              const rItems = tableFullData.splice(tfIndex, 1);
              delList.push(rItems[0]);
            }
            const afIndex = this.findRowIndexOf(afterFullData, row);
            if (afIndex > -1) {
              // 刷新单元格合并
              mergeBodyList.forEach(mergeItem => {
                const {
                  row: mergeRowIndex,
                  rowspan: mergeRowspan
                } = mergeItem;
                if (mergeRowIndex > afIndex) {
                  mergeItem.row = mergeRowIndex - 1;
                } else if (mergeRowIndex + mergeRowspan > afIndex) {
                  mergeItem.rowspan = mergeRowspan - 1;
                }
              });
              afterFullData.splice(afIndex, 1);
            }
          });
        }
      }
      // 如果当前行被激活编辑，则清除激活状态
      if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
        $xeTable.clearEdit();
      }
      // 从新增中移除已删除的数据
      rows.forEach(row => {
        const rowid = getRowid($xeTable, row);
        if (insertRowMaps[rowid]) {
          delete insertRowMaps[rowid];
        }
        if (pendingRowMaps[rowid]) {
          delete pendingRowMaps[rowid];
        }
      });
      reactData.removeRowFlag++;
      reactData.insertRowFlag++;
      reactData.pendingRowFlag++;
      $xeTable.cacheRowMap(false);
      $xeTable.handleTableData(treeConfig && transform);
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      if (!(treeConfig && transform)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return this.$nextTick().then(() => {
        this.updateCellAreas();
        return this.recalculate();
      }).then(() => {
        return {
          row: delList.length ? delList[delList.length - 1] : null,
          rows: delList
        };
      });
    },
    /**
     * 删除复选框选中的数据
     */
    _removeCheckboxRow() {
      return this.remove(this.getCheckboxRecords()).then(params => {
        this.clearCheckboxRow();
        return params;
      });
    },
    /**
     * 删除单选框选中的数据
     */
    _removeRadioRow() {
      const radioRecord = this.getRadioRecord();
      return this.remove(radioRecord || []).then(params => {
        this.clearRadioRow();
        return params;
      });
    },
    /**
     * 删除当前行选中的数据
     */
    _removeCurrentRow() {
      const currentRecord = this.getCurrentRecord();
      return this.remove(currentRecord || []).then(params => {
        this.clearCurrentRow();
        return params;
      });
    },
    /**
     * 获取表格数据集，包含新增、删除、修改
     */
    _getRecordset() {
      const removeRecords = this.getRemoveRecords();
      const pendingRecords = this.getPendingRecords();
      const delRecords = removeRecords.concat(pendingRecords);
      // 如果已经被删除，则无需放到更新数组
      const updateRecords = this.getUpdateRecords().filter(row => {
        return !delRecords.some(item => this.eqRow(item, row));
      });
      return {
        insertRecords: this.getInsertRecords(),
        removeRecords,
        updateRecords,
        pendingRecords
      };
    },
    /**
     * 获取新增的临时数据
     */
    _getInsertRecords() {
      const $xeTable = this;
      const internalData = $xeTable;
      const {
        fullAllDataRowIdData,
        insertRowMaps
      } = internalData;
      const insertRecords = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(insertRowMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          insertRecords.push(row);
        }
      });
      return insertRecords;
    },
    /**
     * 获取已删除的数据
     */
    _getRemoveRecords() {
      const $xeTable = this;
      const internalData = $xeTable;
      const {
        removeRowMaps
      } = internalData;
      const removeRecords = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(removeRowMaps, row => {
        removeRecords.push(row);
      });
      return removeRecords;
    },
    /**
     * 获取更新数据
     * 只精准匹配 row 的更改
     * 如果是树表格，子节点更改状态不会影响父节点的更新状态
     */
    _getUpdateRecords() {
      const $xeTable = this;
      const props = $xeTable;
      const internalData = $xeTable;
      const {
        keepSource,
        treeConfig
      } = props;
      const {
        tableFullData
      } = internalData;
      const treeOpts = $xeTable.computeTreeOpts;
      if (keepSource) {
        syncActivedCell($xeTable);
        if (treeConfig) {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(tableFullData, row => $xeTable.isUpdateByRow(row), treeOpts);
        }
        return tableFullData.filter(row => $xeTable.isUpdateByRow(row));
      }
      return [];
    },
    /**
     * 处理激活编辑
     */
    handleEdit(params, evnt) {
      const $xeTable = this;
      return handleEditActive($xeTable, params, evnt, true, true);
    },
    /**
     * @deprecated
     */
    handleActived(params, evnt) {
      return this.handleEdit(params, evnt);
    },
    _getColumnModel(row, column) {
      getEditColumnModel(row, column);
    },
    _setColumnModel(row, column) {
      setEditColumnModel(row, column);
    },
    _syncActivedCell() {
      const $xeTable = this;
      syncActivedCell($xeTable);
    },
    _clearActived(row) {
      warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit']);
      // 即将废弃
      return this.clearEdit(row);
    },
    /**
     * 清除激活的编辑
     */
    _clearEdit(row) {
      const $xeTable = this;
      return handleClearEdit($xeTable, null, row);
    },
    /**
     * 取消编辑
     */
    handleClearEdit(evnt, targetRow) {
      const $xeTable = this;
      return handleClearEdit($xeTable, evnt, targetRow);
    },
    _getActiveRecord() {
      const $xeTable = this;
      warnLog('vxe.error.delFunc', ['getActiveRecord', 'getEditRecord']);
      // 即将废弃
      return $xeTable.getEditRecord();
    },
    _getEditRecord() {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        editStore
      } = reactData;
      const {
        afterFullData
      } = internalData;
      const el = $xeTable.$refs.refElem;
      const {
        args,
        row
      } = editStore.actived;
      if (args && $xeTable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll('.vxe-body--column.col--active').length) {
        return Object.assign({}, args);
      }
      return null;
    },
    _isActiveByRow(row) {
      const $xeTable = this;
      warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow']);
      // 即将废弃
      return $xeTable.isEditByRow(row);
    },
    /**
     * 判断行是否为激活编辑状态
     * @param {Row} row 行对象
     */
    _isEditByRow(row) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        editStore
      } = reactData;
      return editStore.actived.row === row;
    },
    /**
     * 处理聚焦
     */
    handleFocus(params) {
      const $xeTable = this;
      const {
        row,
        column,
        cell
      } = params;
      const {
        editRender
      } = column;
      const editOpts = $xeTable.computeEditOpts;
      if (isEnableConf(editRender)) {
        const compRender = edit_mixin_renderer.get(editRender.name);
        let autoFocus = editRender.autofocus || editRender.autoFocus;
        let autoSelect = editRender.autoSelect || editRender.autoselect;
        let inputElem;
        // 是否启用聚焦
        if (editOpts.autoFocus) {
          if (!autoFocus && compRender) {
            autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autoFocus || compRender.autofocus;
          }
          if (!autoSelect && compRender) {
            autoSelect = compRender.tableAutoSelect || compRender.autoSelect || compRender.autoselect;
          }
          // 如果指定了聚焦 class
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
            inputElem = autoFocus.call($xeTable, params);
          } else if (autoFocus) {
            if (autoFocus === true) {
              // 自动匹配模式，会自动匹配第一个可输入元素
              inputElem = cell.querySelector('input,textarea');
            } else {
              inputElem = cell.querySelector(autoFocus);
            }
            if (inputElem) {
              inputElem.focus();
            }
          }
        }
        if (inputElem) {
          if (autoSelect) {
            inputElem.select();
          } else {
            // 保持一致行为，光标移到末端
            if (mixin_browseObj.msie) {
              const textRange = inputElem.createTextRange();
              textRange.collapse(false);
              textRange.select();
            }
          }
        } else {
          // 是否自动定位
          if (editOpts.autoPos) {
            if (!column.fixed) {
              // 显示到可视区中
              $xeTable.scrollToRow(row, column);
            }
          }
        }
      }
    },
    _setActiveRow(row) {
      const $xeTable = this;
      warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow']);
      // 即将废弃
      return $xeTable.setEditRow(row);
    },
    /**
     * 激活行编辑
     */
    _setEditRow(row, fieldOrColumn) {
      const $xeTable = this;
      let column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(this.visibleColumn, column => isEnableConf(column.editRender));
      let isPos = false;
      if (fieldOrColumn) {
        isPos = true;
        if (fieldOrColumn !== true) {
          column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
      }
      return handleEditCell($xeTable, row, column, isPos);
    },
    _setActiveCell(row, fieldOrColumn) {
      warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell']);
      // 即将废弃
      return this.setEditCell(row, fieldOrColumn);
    },
    /**
     * 激活单元格编辑
     */
    _setEditCell(row, fieldOrColumn) {
      const $xeTable = this;
      return handleEditCell($xeTable, row, fieldOrColumn, true);
    },
    /**
     * 只对 trigger=dblclick 有效，选中单元格
     */
    _setSelectCell(row, fieldOrColumn) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        tableData
      } = reactData;
      const editOpts = $xeTable.computeEditOpts;
      const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
      if (row && column && editOpts.trigger !== 'manual') {
        const rowIndex = $xeTable.findRowIndexOf(tableData, row);
        if (rowIndex > -1) {
          const cell = $xeTable.getCellElement(row, column);
          const params = {
            row,
            rowIndex,
            column,
            columnIndex: $xeTable.getColumnIndex(column),
            cell
          };
          $xeTable.handleSelected(params, {});
        }
      }
      return $xeTable.$nextTick();
    },
    /**
     * 处理选中源
     */
    handleSelected(params, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const {
        mouseConfig
      } = props;
      const {
        editStore
      } = reactData;
      const mouseOpts = $xeTable.computeMouseOpts;
      const editOpts = $xeTable.computeEditOpts;
      const {
        actived,
        selected
      } = editStore;
      const {
        row,
        column
      } = params;
      const isMouseSelected = mouseConfig && mouseOpts.selected;
      const selectMethod = () => {
        if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
          if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {
            handleClearEdit($xeTable, evnt);
            $xeTable.clearSelected();
            if ($xeTable.clearCellAreas) {
              $xeTable.clearCellAreas();
              $xeTable.clearCopyCellArea();
            }
            selected.args = params;
            selected.row = row;
            selected.column = column;
            if (isMouseSelected) {
              this.addCellSelectedClass();
            }
            $xeTable.focus();
            if (evnt) {
              $xeTable.dispatchEvent('cell-selected', params, evnt);
            }
          }
        }
        return $xeTable.$nextTick();
      };
      return selectMethod();
    },
    /**
     * 获取选中的单元格
     */
    _getSelectedCell() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        editStore
      } = reactData;
      const {
        args,
        column
      } = editStore.selected;
      if (args && column) {
        return Object.assign({}, args);
      }
      return null;
    },
    /**
     * 清除所选中源状态
     */
    _clearSelected() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        editStore
      } = reactData;
      const {
        selected
      } = editStore;
      selected.row = null;
      selected.column = null;
      removeCellSelectedClass($xeTable);
      return $xeTable.$nextTick();
    },
    reColTitleSdCls() {
      const headerElem = this.elemStore['main-header-list'];
      if (headerElem) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(headerElem.querySelectorAll('.col--title-selected'), elem => removeClass(elem, 'col--title-selected'));
      }
    },
    addCellSelectedClass() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        editStore
      } = reactData;
      const {
        selected
      } = editStore;
      const {
        row,
        column
      } = selected;
      removeCellSelectedClass($xeTable);
      if (row && column) {
        const cell = $xeTable.getCellElement(row, column);
        if (cell) {
          addClass(cell, 'col--selected');
        }
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/export/util.ts
// 默认导出或打印的 HTML 样式
const defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
function createHtmlPage(opts, content) {
  const {
    style
  } = opts;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.sheetName}</title>`, '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>', `<style>${defaultHtmlStyle}</style>`, style ? `<style>${style}</style>` : '', '</head>', `<body>${content}</body>`, '</html>'].join('');
}
;// CONCATENATED MODULE: ./packages/table/module/export/mixin.ts








const {
  getI18n: export_mixin_getI18n,
  renderer: export_mixin_renderer
} = core_.VxeUI;
let htmlCellElem;
const csvBOM = '\ufeff';
const enterSymbol = '\r\n';
function hasTreeChildren($xeTable, row) {
  const treeOpts = $xeTable.computeTreeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  return row[childrenField] && row[childrenField].length;
}
function getSeq($xeTable, cellValue, row, $rowIndex, column, $columnIndex) {
  const seqOpts = $xeTable.computeSeqOpts;
  const seqMethod = seqOpts.seqMethod || column.seqMethod;
  if (seqMethod) {
    return seqMethod({
      $table: $xeTable,
      row,
      rowIndex: $xeTable.getRowIndex(row),
      $rowIndex,
      column,
      columnIndex: $xeTable.getColumnIndex(column),
      $columnIndex
    });
  }
  return cellValue;
}
function defaultFilterExportColumn(column) {
  return !!column.field || ['seq', 'checkbox', 'radio'].indexOf(column.type || '') === -1;
}
function toTableBorder(border) {
  if (border === true) {
    return 'full';
  }
  if (border) {
    return border;
  }
  return 'default';
}
function toBooleanValue(cellValue) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(cellValue) ? cellValue ? 'TRUE' : 'FALSE' : cellValue;
}
const toStringValue = cellValue => {
  return eqEmptyValue(cellValue) ? '' : `${cellValue}`;
};
function getBodyLabelData($xeTable, opts, columns, datas) {
  const props = $xeTable;
  const {
    isAllExpand,
    mode
  } = opts;
  const {
    treeConfig
  } = props;
  const radioOpts = $xeTable.computeRadioOpts;
  const checkboxOpts = $xeTable.computeCheckboxOpts;
  const treeOpts = $xeTable.computeTreeOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  if (!htmlCellElem) {
    htmlCellElem = document.createElement('div');
  }
  if (treeConfig) {
    const childrenField = treeOpts.children || treeOpts.childrenField;
    // 如果是树表格只允许导出数据源
    const rest = [];
    const expandMaps = new Map();
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
      const row = item._row || item;
      const parentRow = parent && parent._row ? parent._row : parent;
      if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xeTable.isTreeExpandByRow(parentRow)) {
        const hasRowChild = hasTreeChildren($xeTable, row);
        const item = {
          _row: row,
          _level: nodes.length - 1,
          _hasChild: hasRowChild,
          _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = '';
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = export_mixin_renderer.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
            }
          }
          if (!bodyExportMethod) {
            bodyExportMethod = columnOpts.exportMethod;
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({
              $table: $xeTable,
              row,
              column,
              options: opts
            });
          } else {
            switch (column.type) {
              case 'seq':
                {
                  const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
                  cellValue = mode === 'all' ? seqVal : getSeq($xeTable, seqVal, row, $rowIndex, column, $columnIndex);
                  break;
                }
              case 'checkbox':
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              case 'radio':
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xeTable.getCellLabel(row, column);
                  if (column.type === 'html') {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell && !hasClass(cell, 'is--progress')) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = toStringValue(cellValue);
        });
        expandMaps.set(row, 1);
        rest.push(Object.assign(item, row));
      }
    }, {
      children: childrenField
    });
    return rest;
  }
  return datas.map((row, $rowIndex) => {
    const item = {
      _row: row
    };
    columns.forEach((column, $columnIndex) => {
      let cellValue = '';
      const renderOpts = column.editRender || column.cellRender;
      let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
      if (!bodyExportMethod && renderOpts && renderOpts.name) {
        const compConf = export_mixin_renderer.get(renderOpts.name);
        if (compConf) {
          bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
        }
      }
      if (bodyExportMethod) {
        cellValue = bodyExportMethod({
          $table: $xeTable,
          row,
          column,
          options: opts
        });
      } else {
        switch (column.type) {
          case 'seq':
            {
              const seqValue = $rowIndex + 1;
              cellValue = mode === 'all' ? seqValue : getSeq($xeTable, seqValue, row, $rowIndex, column, $columnIndex);
              break;
            }
          case 'checkbox':
            cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
            item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
            item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
              $table: $xeTable,
              row
            });
            break;
          case 'radio':
            cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
            item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
            item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
              $table: $xeTable,
              row
            });
            break;
          default:
            if (opts.original) {
              cellValue = getCellValue(row, column);
            } else {
              cellValue = $xeTable.getCellLabel(row, column);
              if (column.type === 'html') {
                htmlCellElem.innerHTML = cellValue;
                cellValue = htmlCellElem.innerText.trim();
              } else {
                const cell = $xeTable.getCellElement(row, column);
                if (cell && !hasClass(cell, 'is--progress')) {
                  cellValue = cell.innerText.trim();
                }
              }
            }
        }
      }
      item[column.id] = toStringValue(cellValue);
    });
    return item;
  });
}
function getExportData($xeTable, opts) {
  const {
    columns,
    dataFilterMethod
  } = opts;
  let datas = opts.data;
  if (dataFilterMethod) {
    datas = datas.filter((row, index) => dataFilterMethod({
      $table: $xeTable,
      row,
      $rowIndex: index
    }));
  }
  return getBodyLabelData($xeTable, opts, columns, datas);
}
function getBooleanValue(cellValue) {
  return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;
}
function getHeaderTitle($xeTable, opts, column) {
  const columnOpts = $xeTable.computeColumnOpts;
  const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
  return headExportMethod ? headExportMethod({
    column,
    options: opts,
    $table: $xeTable
  }) : (opts.isTitle ? column.getTitle() : column.field) || '';
}
function getFooterCellValue($xeTable, opts, row, column) {
  const columnOpts = $xeTable.computeColumnOpts;
  const renderOpts = column.editRender || column.cellRender;
  let footLabelMethod = column.footerExportMethod;
  if (!footLabelMethod && renderOpts && renderOpts.name) {
    const compConf = export_mixin_renderer.get(renderOpts.name);
    if (compConf) {
      footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod || compConf.footerCellExportMethod;
    }
  }
  if (!footLabelMethod) {
    footLabelMethod = columnOpts.footerExportMethod;
  }
  const _columnIndex = $xeTable.getVTColumnIndex(column);
  if (footLabelMethod) {
    return footLabelMethod({
      $table: $xeTable,
      items: row,
      itemIndex: _columnIndex,
      row,
      _columnIndex,
      column,
      options: opts
    });
  }
  // 兼容老模式
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(row[_columnIndex]);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
}
function getFooterData($xeTable, opts, footerTableData) {
  const {
    footerFilterMethod
  } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({
    $table: $xeTable,
    items,
    $rowIndex: index
  })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === 'seq') {
      return `\t${cellValue}`;
    }
    switch (column.cellType) {
      case 'string':
        if (!isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
      case 'number':
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function toCsv($xeTable, opts, columns, datas) {
  const reactData = $xeTable;
  let content = csvBOM;
  if (opts.isHeader) {
    content += columns.map(column => toTxtCellLabel(getHeaderTitle($xeTable, opts, column))).join(',') + enterSymbol;
  }
  datas.forEach(row => {
    content += columns.map(column => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(',') + enterSymbol;
  });
  if (opts.isFooter) {
    const {
      footerTableData
    } = reactData;
    const footers = getFooterData($xeTable, opts, footerTableData);
    footers.forEach(row => {
      content += columns.map(column => toTxtCellLabel(getFooterCellValue($xeTable, opts, row, column))).join(',') + enterSymbol;
    });
  }
  return content;
}
function toTxt($xeTable, opts, columns, datas) {
  const reactData = $xeTable;
  let content = '';
  if (opts.isHeader) {
    content += columns.map(column => toTxtCellLabel(getHeaderTitle($xeTable, opts, column))).join('\t') + enterSymbol;
  }
  datas.forEach(row => {
    content += columns.map(column => toTxtCellLabel(row[column.id])).join('\t') + enterSymbol;
  });
  if (opts.isFooter) {
    const {
      footerTableData
    } = reactData;
    const footers = getFooterData($xeTable, opts, footerTableData);
    footers.forEach(row => {
      content += columns.map(column => toTxtCellLabel(getFooterCellValue($xeTable, opts, row, column))).join('\t') + enterSymbol;
    });
  }
  return content;
}
function hasEllipsis($xeTable, column, property, allColumnOverflow) {
  const reactData = $xeTable;
  const columnOverflow = column[property];
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
  const showEllipsis = headOverflow === 'ellipsis';
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  let isEllipsis = showTitle || showTooltip || showEllipsis;
  // 虚拟滚动不支持动态高度
  const {
    scrollXLoad,
    scrollYLoad
  } = reactData;
  if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
    isEllipsis = true;
  }
  return isEllipsis;
}
function toHtml($xeTable, opts, columns, datas) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    id,
    border,
    treeConfig,
    headerAlign: allHeaderAlign,
    align: allAlign,
    footerAlign: allFooterAlign,
    showOverflow: allColumnOverflow,
    showHeaderOverflow: allColumnHeaderOverflow
  } = props;
  const {
    isAllSelected,
    isIndeterminate
  } = reactData;
  const {
    mergeBodyCellMaps
  } = internalData;
  const treeOpts = $xeTable.computeTreeOpts;
  const {
    print: isPrint,
    isHeader,
    isFooter,
    isColgroup,
    isMerge,
    colgroups,
    original
  } = opts;
  const allCls = 'check-all';
  const clss = ['vxe-table', `border--${toTableBorder(border)}`, isPrint ? 'is--print' : '', isHeader ? 'is--header' : ''].filter(cls => cls);
  const tables = [`<table class="${clss.join(' ')}" border="0" cellspacing="0" cellpadding="0">`, `<colgroup>${columns.map(column => `<col style="width:${column.renderWidth}px">`).join('')}</colgroup>`];
  if (isHeader) {
    tables.push('<thead>');
    if (isColgroup && !original) {
      colgroups.forEach(cols => {
        tables.push(`<tr>${cols.map(column => {
          const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
          const classNames = hasEllipsis($xeTable, column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
          const cellTitle = getHeaderTitle($xeTable, opts, column);
          let childWidth = 0;
          let countChild = 0;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
            if (!item.childNodes || !column.childNodes.length) {
              countChild++;
            }
            childWidth += item.renderWidth;
          }, {
            children: 'childNodes'
          });
          const cellWidth = childWidth - countChild;
          if (headAlign) {
            classNames.push(`col--${headAlign}`);
          }
          if (column.type === 'checkbox') {
            return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
          }
          return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
        }).join('')}</tr>`);
      });
    } else {
      tables.push(`<tr>${columns.map(column => {
        const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
        const classNames = hasEllipsis($xeTable, column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
        const cellTitle = getHeaderTitle($xeTable, opts, column);
        if (headAlign) {
          classNames.push(`col--${headAlign}`);
        }
        if (column.type === 'checkbox') {
          return `<th class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
        }
        return `<th class="${classNames.join(' ')}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
      }).join('')}</tr>`);
    }
    tables.push('</thead>');
  }
  if (datas.length) {
    tables.push('<tbody>');
    if (treeConfig) {
      datas.forEach(item => {
        tables.push('<tr>' + columns.map(column => {
          const cellAlign = column.align || allAlign;
          const classNames = hasEllipsis($xeTable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
          const cellValue = item[column.id];
          if (cellAlign) {
            classNames.push(`col--${cellAlign}`);
          }
          if (column.treeNode) {
            let treeIcon = '';
            if (item._hasChild) {
              treeIcon = `<i class="${item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon'}"></i>`;
            }
            classNames.push('vxe-table--tree-node');
            if (column.type === 'radio') {
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></div></div></td>`;
            } else if (column.type === 'checkbox') {
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></div></div></td>`;
            }
            return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
          }
          if (column.type === 'radio') {
            return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
          } else if (column.type === 'checkbox') {
            return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
          }
          return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
        }).join('') + '</tr>');
      });
    } else {
      datas.forEach(item => {
        tables.push('<tr>' + columns.map(column => {
          const colid = column.id;
          const cellAlign = column.align || allAlign;
          const classNames = hasEllipsis($xeTable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
          const cellValue = item[colid];
          let rowSpan = 1;
          let colSpan = 1;
          if (isMerge) {
            const _rowIndex = $xeTable.getVTRowIndex(item._row);
            const _columnIndex = $xeTable.getVTColumnIndex(column);
            const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
            if (spanRest) {
              const {
                rowspan,
                colspan
              } = spanRest;
              if (!rowspan || !colspan) {
                return '';
              }
              if (rowspan > 1) {
                rowSpan = rowspan;
              }
              if (colspan > 1) {
                colSpan = colspan;
              }
            }
          }
          if (cellAlign) {
            classNames.push(`col--${cellAlign}`);
          }
          if (column.type === 'radio') {
            return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
          } else if (column.type === 'checkbox') {
            return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
          }
          return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
        }).join('') + '</tr>');
      });
    }
    tables.push('</tbody>');
  }
  if (isFooter) {
    const {
      footerTableData
    } = reactData;
    const footers = getFooterData($xeTable, opts, footerTableData);
    if (footers.length) {
      tables.push('<tfoot>');
      footers.forEach(row => {
        tables.push(`<tr>${columns.map(column => {
          const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
          const classNames = hasEllipsis($xeTable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
          const cellValue = getFooterCellValue($xeTable, opts, row, column);
          if (footAlign) {
            classNames.push(`col--${footAlign}`);
          }
          return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
        }).join('')}</tr>`);
      });
      tables.push('</tfoot>');
    }
  }
  // 是否半选状态
  const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()</script>` : '';
  tables.push('</table>', script);
  return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));
}
function toXML($xeTable, opts, columns, datas) {
  const reactData = $xeTable;
  let xml = ['<?xml version="1.0"?>', '<?mso-application progid="Excel.Sheet"?>', '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">', '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', `<Worksheet ss:Name="${opts.sheetName}">`, '<Table>', columns.map(column => `<Column ss:Width="${column.renderWidth}"/>`).join('')].join('');
  if (opts.isHeader) {
    xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getHeaderTitle($xeTable, opts, column)}</Data></Cell>`).join('')}</Row>`;
  }
  datas.forEach(row => {
    xml += '<Row>' + columns.map(column => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join('') + '</Row>';
  });
  if (opts.isFooter) {
    const {
      footerTableData
    } = reactData;
    const footers = getFooterData($xeTable, opts, footerTableData);
    footers.forEach(row => {
      xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getFooterCellValue($xeTable, opts, row, column)}</Data></Cell>`).join('')}</Row>`;
    });
  }
  return `${xml}</Table></Worksheet></Workbook>`;
}
function getContent($xeTable, opts, columns, datas) {
  if (columns.length) {
    switch (opts.type) {
      case 'csv':
        return toCsv($xeTable, opts, columns, datas);
      case 'txt':
        return toTxt($xeTable, opts, columns, datas);
      case 'html':
        return toHtml($xeTable, opts, columns, datas);
      case 'xml':
        return toXML($xeTable, opts, columns, datas);
    }
  }
  return '';
}
function downloadFile($xeTable, opts, content) {
  const {
    filename,
    type,
    download
  } = opts;
  if (!download) {
    const blob = getExportBlobByContent(content, opts);
    return Promise.resolve({
      type,
      content,
      blob
    });
  }
  if (core_.VxeUI.saveFile) {
    core_.VxeUI.saveFile({
      filename,
      type,
      content
    }).then(() => {
      if (opts.message !== false) {
        if (core_.VxeUI.modal) {
          core_.VxeUI.modal.message({
            content: export_mixin_getI18n('vxe.table.expSuccess'),
            status: 'success'
          });
        }
      }
    });
  }
}
function clearColumnConvert(columns) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, {
    children: 'children'
  });
}
function handleExport($xeTable, opts) {
  const $xeGrid = $xeTable.$xeGrid;
  const {
    remote,
    columns,
    colgroups,
    exportMethod,
    afterExportMethod
  } = opts;
  return new Promise(resolve => {
    if (remote) {
      const params = {
        options: opts,
        $table: $xeTable,
        $grid: $xeGrid
      };
      resolve(exportMethod ? exportMethod(params) : params);
    } else {
      const datas = getExportData($xeTable, opts);
      resolve($xeTable.preventEvent(null, 'event.export', {
        options: opts,
        columns,
        colgroups,
        datas
      }, () => {
        return downloadFile($xeTable, opts, getContent($xeTable, opts, columns, datas));
      }));
    }
  }).then(params => {
    clearColumnConvert(columns);
    if (!opts.print) {
      if (afterExportMethod) {
        afterExportMethod({
          status: true,
          options: opts,
          $table: $xeTable,
          $grid: $xeGrid
        });
      }
    }
    return Object.assign({
      status: true
    }, params);
  }).catch(() => {
    clearColumnConvert(columns);
    if (!opts.print) {
      if (afterExportMethod) {
        afterExportMethod({
          status: false,
          options: opts,
          $table: $xeTable,
          $grid: $xeGrid
        });
      }
    }
    const params = {
      status: false
    };
    return Promise.reject(params);
  });
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, key => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, qVal => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function toExportField(tableConf, field) {
  const {
    fieldMaps,
    titleMaps
  } = tableConf;
  // title 转 field
  if (!fieldMaps[field]) {
    const teCol = titleMaps[field];
    if (teCol && teCol.field) {
      field = teCol.field;
    }
  }
  return field;
}
function parseCsvAndTxt(tableConf, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach(rVal => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : '\n';
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map(val => toExportField(tableConf, getTxtCellValue(val.trim(), vMaps)));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return {
    fields,
    rows
  };
}
function parseCsv(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, ',');
}
function parseTxt(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, '\t');
}
function parseHTML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'text/html');
  const bodyNodes = getElementsByTagName(xmlDoc, 'body');
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], 'table');
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], 'thead');
      if (theadNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(theadNodes[0], 'tr'), rowNode => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'th'), cellNode => {
            fields.push(toExportField(tableConf, cellNode.textContent || ''));
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');
        if (tbodyNodes.length) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), rowNode => {
            const item = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'td'), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || '';
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return {
    fields,
    rows
  };
}
function parseXML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'application/xml');
  const sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], 'Table');
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], 'Row');
      if (rowNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), cellNode => {
          fields.push(toExportField(tableConf, cellNode.textContent || ''));
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, 'Cell');
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return {
    fields,
    rows
  };
}
function handleImport($xeTable, content, opts) {
  const internalData = $xeTable;
  const {
    tableFullColumn,
    _importResolve,
    _importReject
  } = internalData;
  let rest = {
    fields: [],
    rows: []
  };
  const tableFieldMaps = {};
  const tableTitleMaps = {};
  tableFullColumn.forEach(column => {
    const field = column.field;
    const title = column.getTitle();
    if (field) {
      tableFieldMaps[field] = column;
    }
    if (title) {
      tableTitleMaps[column.getTitle()] = column;
    }
  });
  const tableConf = {
    fieldMaps: tableFieldMaps,
    titleMaps: tableTitleMaps
  };
  switch (opts.type) {
    case 'csv':
      rest = parseCsv(tableConf, content);
      break;
    case 'txt':
      rest = parseTxt(tableConf, content);
      break;
    case 'html':
      rest = parseHTML(tableConf, content);
      break;
    case 'xml':
      rest = parseXML(tableConf, content);
      break;
  }
  const {
    fields,
    rows
  } = rest;
  const status = fields.some(field => tableFieldMaps[field] || tableTitleMaps[field]);
  if (status) {
    $xeTable.createData(rows).then(data => {
      let loadRest;
      if (opts.mode === 'insert' || opts.mode === 'insertBottom') {
        loadRest = $xeTable.insertAt(data, -1);
      }
      if (opts.mode === 'insertTop') {
        loadRest = $xeTable.insert(data);
      } else {
        loadRest = $xeTable.reloadData(data);
      }
      if (opts.message !== false) {
        // 检测弹窗模块
        if (!core_.VxeUI.modal) {
          errLog('vxe.error.reqModule', ['Modal']);
        }
        core_.VxeUI.modal.message({
          content: export_mixin_getI18n('vxe.table.impSuccess', [rows.length]),
          status: 'success'
        });
      }
      return loadRest.then(() => {
        if (_importResolve) {
          _importResolve({
            status: true
          });
        }
      });
    });
  } else if (opts.message !== false) {
    // 检测弹窗模块
    if (!core_.VxeUI.modal) {
      errLog('vxe.error.reqModule', ['Modal']);
    }
    core_.VxeUI.modal.message({
      content: export_mixin_getI18n('vxe.error.impFields'),
      status: 'error'
    });
    if (_importReject) {
      _importReject({
        status: false
      });
    }
  }
}
function handleFileImport($xeTable, file, opts) {
  const internalData = $xeTable;
  const importOpts = $xeTable.computeImportOpts;
  const {
    importMethod,
    afterImportMethod
  } = opts;
  const {
    type,
    filename
  } = parseFile(file);
  // 检查类型，如果为自定义导出，则不需要校验类型
  if (!importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps), type)) {
    if (opts.message !== false) {
      // 检测弹窗模块
      if (!core_.VxeUI.modal) {
        errLog('vxe.error.reqModule', ['Modal']);
      }
      core_.VxeUI.modal.message({
        content: export_mixin_getI18n('vxe.error.notType', [type]),
        status: 'error'
      });
    }
    const params = {
      status: false
    };
    return Promise.reject(params);
  }
  const rest = new Promise((resolve, reject) => {
    const _importResolve = params => {
      resolve(params);
      $xeTable._importResolve = null;
      $xeTable._importReject = null;
    };
    const _importReject = params => {
      reject(params);
      $xeTable._importResolve = null;
      $xeTable._importReject = null;
    };
    $xeTable._importResolve = _importResolve;
    $xeTable._importReject = _importReject;
    if (window.FileReader) {
      const options = Object.assign({
        mode: 'insertTop'
      }, opts, {
        type,
        filename
      });
      if (options.remote) {
        if (importMethod) {
          Promise.resolve(importMethod({
            file,
            options,
            $table: $xeTable
          })).then(() => {
            _importResolve({
              status: true
            });
          }).catch(() => {
            _importResolve({
              status: true
            });
          });
        } else {
          _importResolve({
            status: true
          });
        }
      } else {
        const {
          tableFullColumn
        } = internalData;
        $xeTable.preventEvent(null, 'event.import', {
          file,
          options,
          columns: tableFullColumn
        }, () => {
          const reader = new FileReader();
          reader.onerror = () => {
            errLog('vxe.error.notType', [type]);
            _importReject({
              status: false
            });
          };
          reader.onload = e => {
            handleImport($xeTable, e.target.result, options);
          };
          reader.readAsText(file, options.encoding || 'UTF-8');
        });
      }
    } else {
      // 不支持的浏览器
      errLog('vxe.error.notExp');
      _importResolve({
        status: true
      });
    }
  });
  return rest.then(() => {
    if (afterImportMethod) {
      afterImportMethod({
        status: true,
        options: opts,
        $table: $xeTable
      });
    }
  }).catch(e => {
    if (afterImportMethod) {
      afterImportMethod({
        status: false,
        options: opts,
        $table: $xeTable
      });
    }
    return Promise.reject(e);
  });
}
function handleCloseExport() {
  if (core_.VxeUI.modal) {
    return core_.VxeUI.modal.close('VXE_EXPORT_MODAL');
  }
  return Promise.resolve();
}
function handleFilterColumns(exportOpts, column, columns) {
  return columns.some(item => {
    if (isColumnInfo(item)) {
      return column.id === item.id;
    } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
      return column.field === item;
    } else {
      const colid = item.id || item.colId;
      const type = item.type;
      const field = item.field;
      if (colid) {
        return column.id === colid;
      } else if (field && type) {
        return column.field === field && column.type === type;
      } else if (field) {
        return column.field === field;
      } else if (type) {
        return column.type === type;
      }
    }
    return false;
  });
}
function handleFilterFields(exportOpts, column, includeFields, excludeFields) {
  if (excludeFields) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
      return false;
    }
  }
  if (includeFields) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
      return true;
    }
    return false;
  }
  return exportOpts.original ? !!column.field : defaultFilterExportColumn(column);
}
function handleExportAndPrint($xeTable, options, isPrint) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    treeConfig,
    showHeader,
    showFooter
  } = props;
  const {
    initStore,
    isGroup,
    footerTableData,
    exportStore,
    exportParams
  } = reactData;
  const {
    collectColumn,
    mergeBodyList,
    mergeFooterList
  } = internalData;
  const exportOpts = $xeTable.computeExportOpts;
  const hasTree = treeConfig;
  const customOpts = $xeTable.computeCustomOpts;
  const selectRecords = $xeTable.getCheckboxRecords();
  const proxyOpts = $xeGrid ? $xeGrid.computeProxyOpts : {};
  const hasFooter = !!footerTableData.length;
  const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
  const defOpts = Object.assign({
    message: true,
    isHeader: showHeader,
    isTitle: showHeader,
    isFooter: showFooter,
    isColgroup: isGroup,
    isMerge: hasMerge,
    useStyle: true,
    current: 'current',
    modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty'])
  }, options);
  const types = defOpts.types || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps);
  const modes = defOpts.modes || [];
  const checkMethod = customOpts.checkMethod;
  const exportColumns = collectColumn.slice(0);
  const {
    columns,
    excludeFields,
    includeFields
  } = defOpts;
  // 处理类型
  const typeList = types.map(value => {
    return {
      value,
      label: export_mixin_getI18n(`vxe.export.types.${value}`)
    };
  });
  const modeList = modes.map(item => {
    if (item && item.value) {
      return {
        value: item.value,
        label: item.label || item.value
      };
    }
    return {
      value: item,
      label: export_mixin_getI18n(`vxe.export.modes.${item}`)
    };
  });
  // 默认选中
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(exportColumns, (column, index, items, path, parent) => {
    const isColGroup = column.children && column.children.length > 0;
    let isChecked = false;
    if (columns && columns.length) {
      isChecked = handleFilterColumns(defOpts, column, columns);
    } else if (excludeFields || includeFields) {
      isChecked = handleFilterFields(defOpts, column, includeFields, excludeFields);
    } else {
      isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
    }
    column.checked = isChecked;
    column.halfChecked = false;
    column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({
      $table: $xeTable,
      column
    }) : false);
  });
  // 更新条件
  Object.assign(exportStore, {
    columns: exportColumns,
    typeList,
    modeList,
    hasFooter,
    hasMerge,
    hasTree,
    isPrint,
    hasColgroup: isGroup,
    visible: true
  });
  // 默认参数
  Object.assign(exportParams, {
    mode: selectRecords.length ? 'selected' : 'current'
  }, defOpts);
  const {
    filename,
    sheetName,
    mode,
    type
  } = exportParams;
  if (filename) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
      exportParams.filename = filename({
        options: defOpts,
        $table: $xeTable,
        $grid: $xeGrid
      });
    } else {
      exportParams.filename = `${filename}`;
    }
  }
  if (sheetName) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
      exportParams.sheetName = sheetName({
        options: defOpts,
        $table: $xeTable,
        $grid: $xeGrid
      });
    } else {
      exportParams.sheetName = `${sheetName}`;
    }
  }
  if (!modeList.some(item => item.value === mode)) {
    exportParams.mode = modeList[0].value;
  }
  if (!typeList.some(item => item.value === type)) {
    exportParams.type = typeList[0].value;
  }
  initStore.export = true;
  return $xeTable.$nextTick();
}
const getConvertColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
/* harmony default export */ var export_mixin = ({
  methods: {
    /**
     * 导出文件，支持 csv/html/xml/txt
     * 如果是树表格，则默认是导出所有节点
     * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数转换数据
     * @param {Object} options 参数
     */
    _exportData(options) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const $xeGrid = $xeTable.$xeGrid;
      const {
        treeConfig,
        showHeader,
        showFooter
      } = props;
      const {
        isGroup
      } = reactData;
      const {
        tableFullColumn,
        afterFullData,
        collectColumn,
        mergeBodyList,
        mergeFooterList
      } = internalData;
      const exportOpts = $xeTable.computeExportOpts;
      const treeOpts = $xeTable.computeTreeOpts;
      const proxyOpts = $xeGrid ? $xeGrid.computeProxyOpts : {};
      const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
      const opts = Object.assign({
        message: true,
        isHeader: showHeader,
        isTitle: showHeader,
        isFooter: showFooter,
        isColgroup: isGroup,
        isMerge: hasMerge,
        useStyle: true,
        current: 'current',
        modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty']),
        download: true,
        type: 'csv'
        // filename: '',
        // sheetName: '',
        // original: false,
        // isAllExpand: false,
        // data: null,
        // remote: false,
        // dataFilterMethod: null,
        // footerFilterMethod: null,
        // exportMethod: null,
        // columnFilterMethod: null,
        // beforeExportMethod: null,
        // afterExportMethod: null
      }, exportOpts, options);
      let {
        filename,
        sheetName,
        type,
        mode,
        columns,
        original,
        columnFilterMethod,
        beforeExportMethod,
        includeFields,
        excludeFields
      } = opts;
      let groups = [];
      const selectRecords = $xeTable.getCheckboxRecords();
      if (!mode) {
        mode = selectRecords.length ? 'selected' : 'current';
      }
      let isCustomCol = false;
      let customCols = [];
      if (columns && columns.length) {
        isCustomCol = true;
        customCols = columns;
      } else {
        customCols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(collectColumn, column => {
          const isColGroup = column.children && column.children.length > 0;
          let isChecked = false;
          if (columns && columns.length) {
            isChecked = handleFilterColumns(opts, column, columns);
          } else if (excludeFields || includeFields) {
            isChecked = handleFilterFields(opts, column, includeFields, excludeFields);
          } else {
            isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
          }
          return isChecked;
        }, {
          children: 'children',
          mapChildren: 'childNodes',
          original: true
        });
      }
      const handleOptions = Object.assign({}, opts, {
        filename: '',
        sheetName: ''
      });
      // 如果设置源数据，则默认导出设置了字段的列
      if (!isCustomCol && !columnFilterMethod) {
        columnFilterMethod = ({
          column
        }) => {
          if (excludeFields) {
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
              return false;
            }
          }
          if (includeFields) {
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
              return true;
            }
            return false;
          }
          return original ? !!column.field : defaultFilterExportColumn(column);
        };
        handleOptions.columnFilterMethod = columnFilterMethod;
      }
      if (customCols) {
        handleOptions._isCustomColumn = true;
        groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(customCols, item => {
          let targetColumn;
          if (item) {
            if (isColumnInfo(item)) {
              targetColumn = item;
            } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
              targetColumn = $xeTable.getColumnByField(item);
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.field;
              if (colid) {
                targetColumn = $xeTable.getColumnById(colid);
              } else if (field && type) {
                targetColumn = tableFullColumn.find(column => column.field === field && column.type === type);
              } else if (field) {
                targetColumn = $xeTable.getColumnByField(field);
              } else if (type) {
                targetColumn = tableFullColumn.find(column => column.type === type);
              }
            }
            return targetColumn || {};
          }
        }, {
          children: 'childNodes',
          mapChildren: '_children'
        }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({
          $table: $xeTable,
          column: column,
          $columnIndex: index
        })), {
          children: '_children',
          mapChildren: 'childNodes',
          original: true
        });
      } else {
        groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(isGroup ? collectColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({
          $table: $xeTable,
          column,
          $columnIndex: index
        })), {
          children: 'children',
          mapChildren: 'childNodes',
          original: true
        });
      }
      // 获取所有列
      const cols = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(groups, column => {
        const isColGroup = column.children && column.children.length;
        if (!isColGroup) {
          cols.push(column);
        }
      }, {
        children: 'childNodes'
      });
      // 构建分组层级
      handleOptions.columns = cols;
      handleOptions.colgroups = convertToRows(groups);
      if (filename) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
          handleOptions.filename = filename({
            options: opts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          handleOptions.filename = `${filename}`;
        }
      }
      if (!handleOptions.filename) {
        handleOptions.filename = export_mixin_getI18n(handleOptions.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(Date.now(), 'yyyyMMddHHmmss')]);
      }
      if (sheetName) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
          handleOptions.sheetName = sheetName({
            options: opts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          handleOptions.sheetName = `${sheetName}`;
        }
      }
      if (!handleOptions.sheetName) {
        handleOptions.sheetName = document.title || '';
      }
      // 检查类型，如果为自定义导出，则不需要校验类型
      if (!handleOptions.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps), type)) {
        errLog('vxe.error.notType', [type]);
        if (['xlsx', 'pdf'].includes(type)) {
          warnLog('vxe.error.reqPlugin', [4, 'plugin-export-xlsx']);
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      }
      if (!handleOptions.print) {
        if (beforeExportMethod) {
          beforeExportMethod({
            options: handleOptions,
            $table: $xeTable,
            $grid: $xeGrid
          });
        }
      }
      if (!handleOptions.data) {
        handleOptions.data = [];
        if (mode === 'selected') {
          if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {
            handleOptions.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree($xeTable.getTableData().fullData, item => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, {
              data: '_row'
            }));
          } else {
            handleOptions.data = selectRecords;
          }
        } else if (mode === 'all') {
          if (!$xeGrid) {
            errLog('vxe.error.errProp', ['all', 'mode=current,selected']);
          }
          if ($xeGrid && !handleOptions.remote) {
            const gridReactData = $xeGrid;
            const proxyOpts = $xeGrid.computeProxyOpts;
            const {
              sortData
            } = gridReactData;
            const {
              beforeQueryAll,
              afterQueryAll,
              ajax = {}
            } = proxyOpts;
            const resConfigs = proxyOpts.response || proxyOpts.props || {};
            const ajaxMethods = ajax.queryAll;
            const queryAllSuccessMethods = ajax.queryAllSuccess;
            const queryAllErrorMethods = ajax.queryAllError;
            if (!ajaxMethods) {
              errLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);
            }
            if (ajaxMethods) {
              const params = {
                $table: $xeTable,
                $grid: $xeGrid,
                sort: sortData.length ? sortData[0] : {},
                sorts: sortData,
                filters: gridReactData.filterData,
                form: gridReactData.formData,
                options: handleOptions
              };
              return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then(rest => {
                const listProp = resConfigs.list;
                handleOptions.data = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                  data: rest,
                  $grid: $xeGrid
                }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                if (afterQueryAll) {
                  afterQueryAll(params);
                }
                if (queryAllSuccessMethods) {
                  queryAllSuccessMethods({
                    ...params,
                    response: rest
                  });
                }
                return handleExport($xeTable, handleOptions);
              }).catch(rest => {
                if (queryAllErrorMethods) {
                  queryAllErrorMethods({
                    ...params,
                    response: rest
                  });
                }
              });
            }
          }
        } else if (mode === 'current') {
          handleOptions.data = afterFullData;
        }
      }
      return handleExport($xeTable, handleOptions);
    },
    _importByFile(file, options) {
      const $xeTable = this;
      const opts = Object.assign({}, options);
      const {
        beforeImportMethod
      } = opts;
      if (beforeImportMethod) {
        beforeImportMethod({
          options: opts,
          $table: $xeTable
        });
      }
      return handleFileImport($xeTable, file, opts);
    },
    _importData(options) {
      const $xeTable = this;
      const {
        importOpts
      } = this;
      const opts = Object.assign({
        types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps)
        // beforeImportMethod: null,
        // afterImportMethod: null
      }, importOpts, options);
      const {
        beforeImportMethod,
        afterImportMethod
      } = opts;
      if (beforeImportMethod) {
        beforeImportMethod({
          options: opts,
          $table: this
        });
      }
      return core_.VxeUI.readFile(opts).catch(e => {
        if (afterImportMethod) {
          afterImportMethod({
            status: false,
            options: opts,
            $table: $xeTable
          });
        }
        return Promise.reject(e);
      }).then(params => {
        const {
          file
        } = params;
        return handleFileImport($xeTable, file, opts);
      });
    },
    _saveFile(options) {
      return core_.VxeUI.saveFile(options);
    },
    _readFile(options) {
      return core_.VxeUI.readFile(options);
    },
    _print(options) {
      const $xeTable = this;
      const $xeGrid = $xeTable.$xeGrid;
      const opts = Object.assign({
        original: false
        // beforePrintMethod
      }, this.printOpts, options, {
        type: 'html',
        download: false,
        remote: false,
        print: true
      });
      const {
        sheetName
      } = opts;
      let printTitle = '';
      if (sheetName) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
          printTitle = sheetName({
            options: opts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          printTitle = `${sheetName}`;
        }
      }
      if (!printTitle) {
        printTitle = document.title || '';
      }
      const beforePrintMethod = opts.beforePrintMethod;
      const tableHtml = opts.html || opts.content;
      return new Promise((resolve, reject) => {
        if (core_.VxeUI.print) {
          if (tableHtml) {
            resolve(core_.VxeUI.print({
              title: printTitle,
              html: tableHtml,
              customStyle: opts.style,
              beforeMethod: beforePrintMethod ? ({
                html
              }) => {
                return beforePrintMethod({
                  html,
                  content: html,
                  options: opts,
                  $table: $xeTable
                });
              } : undefined
            }));
          } else {
            resolve($xeTable.exportData(opts).then(({
              content
            }) => {
              return core_.VxeUI.print({
                title: printTitle,
                html: content,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({
                  html
                }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable
                  });
                } : undefined
              });
            }));
          }
        } else {
          const e = {
            status: false
          };
          reject(e);
        }
      });
    },
    _getPrintHtml(options) {
      const $xeTable = this;
      const printOpts = $xeTable.computePrintOpts;
      const opts = Object.assign({
        original: false
        // beforePrintMethod
      }, printOpts, options, {
        type: 'html',
        download: false,
        remote: false,
        print: true
      });
      return $xeTable.exportData(opts).then(({
        content
      }) => {
        return {
          html: content
        };
      });
    },
    _closeImport() {
      if (core_.VxeUI.modal) {
        return core_.VxeUI.modal.close('VXE_IMPORT_MODAL');
      }
      return Promise.resolve();
    },
    _openImport(options) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const {
        treeConfig,
        importConfig
      } = props;
      const {
        initStore,
        importStore,
        importParams
      } = reactData;
      const importOpts = $xeTable.computeImportOpts;
      const defOpts = Object.assign({
        mode: 'insertTop',
        message: true,
        types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),
        modes: ['insertTop', 'covering']
      }, importOpts, options);
      const types = defOpts.types || [];
      const modes = defOpts.modes || [];
      const isTree = !!treeConfig;
      if (isTree) {
        if (defOpts.message) {
          core_.VxeUI.modal.message({
            content: export_mixin_getI18n('vxe.error.treeNotImp'),
            status: 'error'
          });
        }
        return;
      }
      if (!importConfig) {
        errLog('vxe.error.reqProp', ['import-config']);
      }
      // 处理类型
      const typeList = types.map(value => {
        return {
          value,
          label: export_mixin_getI18n(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map(item => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: export_mixin_getI18n(`vxe.import.modes.${item}`)
        };
      });
      Object.assign(importStore, {
        file: null,
        type: '',
        filename: '',
        modeList,
        typeList,
        visible: true
      });
      Object.assign(importParams, defOpts);
      if (!modeList.some(item => item.value === importParams.mode)) {
        importParams.mode = modeList[0].value;
      }
      initStore.import = true;
    },
    _closeExport: handleCloseExport,
    _openExport(options) {
      const $xeTable = this;
      const props = $xeTable;
      const exportOpts = $xeTable.computeExportOpts;
      const defOpts = Object.assign({
        message: true,
        types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps)
      }, exportOpts, options);
      if (!props.exportConfig) {
        errLog('vxe.error.reqProp', ['export-config']);
      }
      return handleExportAndPrint($xeTable, defOpts);
    },
    _closePrint: handleCloseExport,
    _openPrint(options) {
      const $xeTable = this;
      const props = $xeTable;
      const printOpts = $xeTable.computePrintOpts;
      const defOpts = Object.assign({
        message: true
      }, printOpts, options);
      if (!props.printConfig) {
        errLog('vxe.error.reqProp', ['print-config']);
      }
      return handleExportAndPrint($xeTable, defOpts, true);
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/keyboard/mixin.ts




const keyboard_mixin_browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !keyboard_mixin_browseObj.firefox && hasClass(target, 'vxe-checkbox--label');
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingTop);
      offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingLeft);
    }
  }
  return {
    offsetTop,
    offsetLeft
  };
}
function getCheckboxRangeRows($xeTable, evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const {
    showOverflow
  } = props;
  const {
    fullAllDataRowIdData,
    isResizeCellHeight
  } = internalData;
  const rowOpts = $xeTable.computeRowOpts;
  const cellOpts = $xeTable.computeCellOpts;
  const defaultRowHeight = $xeTable.computeDefaultRowHeight;
  const {
    row
  } = params;
  let countHeight = 0;
  let rangeRows = [];
  let moveSize = 0;
  const isDown = moveRange > 0;
  const {
    scrollYLoad
  } = reactData;
  const {
    afterFullData
  } = internalData;
  if (isDown) {
    moveSize = offsetClientTop + moveRange;
  } else {
    moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
  }
  if (scrollYLoad) {
    const _rowIndex = $xeTable.getVTRowIndex(row);
    const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
    if (!isCustomCellHeight && showOverflow) {
      if (isDown) {
        rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / defaultRowHeight));
      } else {
        rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / defaultRowHeight), _rowIndex + 1);
      }
    } else {
      if (isDown) {
        for (let i = _rowIndex; i < afterFullData.length; i++) {
          const item = afterFullData[i];
          const rowid = $xeTable.getRowid(item);
          const rowRest = fullAllDataRowIdData[rowid] || {};
          countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
          rangeRows.push(item);
          if (countHeight > moveSize) {
            return rangeRows;
          }
        }
      } else {
        for (let len = _rowIndex; len >= 0; len--) {
          const item = afterFullData[len];
          const rowid = $xeTable.getRowid(item);
          const rowRest = fullAllDataRowIdData[rowid] || {};
          countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
          rangeRows.push(item);
          if (countHeight > moveSize) {
            return rangeRows;
          }
        }
      }
    }
  } else {
    const siblingProp = isDown ? 'next' : 'previous';
    while (targetTrElem && countHeight < moveSize) {
      const rowNodeRest = $xeTable.getRowNode(targetTrElem);
      if (rowNodeRest) {
        rangeRows.push(rowNodeRest.item);
        countHeight += targetTrElem.offsetHeight;
        targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
      }
    }
  }
  return rangeRows;
}
function handleMoveSelected($xeTable, evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow) {
  const internalData = $xeTable;
  const {
    afterFullData,
    visibleColumn
  } = internalData;
  const params = Object.assign({}, args);
  const _rowIndex = $xeTable.getVTRowIndex(params.row);
  const _columnIndex = $xeTable.getVTColumnIndex(params.column);
  evnt.preventDefault();
  if (isUpArrow && _rowIndex > 0) {
    // 移动到上一行
    params.rowIndex = _rowIndex - 1;
    params.row = afterFullData[params.rowIndex];
  } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
    // 移动到下一行
    params.rowIndex = _rowIndex + 1;
    params.row = afterFullData[params.rowIndex];
  } else if (isLeftArrow && _columnIndex) {
    // 移动到左侧单元格
    params.columnIndex = _columnIndex - 1;
    params.column = visibleColumn[params.columnIndex];
  } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
    // 移动到右侧单元格
    params.columnIndex = _columnIndex + 1;
    params.column = visibleColumn[params.columnIndex];
  }
  $xeTable.scrollToRow(params.row, params.column).then(() => {
    params.cell = $xeTable.getCellElement(params.row, params.column);
    $xeTable.handleSelected(params, evnt);
  });
  return params;
}
/* harmony default export */ var keyboard_mixin = ({
  methods: {
    // 处理 Tab 键移动
    moveTabSelected(args, isLeft, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const internalData = $xeTable;
      const {
        editConfig
      } = props;
      const {
        afterFullData,
        visibleColumn
      } = internalData;
      const editOpts = $xeTable.computeEditOpts;
      const rowOpts = $xeTable.computeRowOpts;
      const currentRowOpts = $xeTable.computeCurrentRowOpts;
      const columnOpts = $xeTable.computeColumnOpts;
      const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
      let targetRow;
      let targetRowIndex;
      let targetColumnIndex;
      const params = Object.assign({}, args);
      const _rowIndex = $xeTable.getVTRowIndex(params.row);
      const _columnIndex = $xeTable.getVTColumnIndex(params.column);
      evnt.preventDefault();
      if (isLeft) {
        // 向左
        if (_columnIndex <= 0) {
          // 如果已经是第一列，则移动到上一行
          if (_rowIndex > 0) {
            targetRowIndex = _rowIndex - 1;
            targetRow = afterFullData[targetRowIndex];
            targetColumnIndex = visibleColumn.length - 1;
          }
        } else {
          targetColumnIndex = _columnIndex - 1;
        }
      } else {
        if (_columnIndex >= visibleColumn.length - 1) {
          // 如果已经是第一列，则移动到上一行
          if (_rowIndex < afterFullData.length - 1) {
            targetRowIndex = _rowIndex + 1;
            targetRow = afterFullData[targetRowIndex];
            targetColumnIndex = 0;
          }
        } else {
          targetColumnIndex = _columnIndex + 1;
        }
      }
      const targetColumn = visibleColumn[targetColumnIndex];
      if (targetColumn) {
        if (targetRow) {
          params.rowIndex = targetRowIndex;
          params.row = targetRow;
        } else {
          params.rowIndex = _rowIndex;
        }
        params.columnIndex = targetColumnIndex;
        params.column = targetColumn;
        params.cell = $xeTable.getCellElement(params.row, params.column);
        if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        }
        if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
        if (editConfig) {
          if (editOpts.trigger === 'click' || editOpts.trigger === 'dblclick') {
            if (editOpts.mode === 'row') {
              $xeTable.handleEdit(params, evnt);
            } else {
              $xeTable.scrollToRow(params.row, params.column).then(() => {
                $xeTable.handleSelected(params, evnt);
              });
            }
          }
        } else {
          $xeTable.scrollToRow(params.row, params.column).then(() => {
            $xeTable.handleSelected(params, evnt);
          });
        }
      }
    },
    // 处理当前行方向键移动
    moveCurrentRow(isUpArrow, isDwArrow, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        treeConfig
      } = props;
      const {
        currentRow
      } = reactData;
      const {
        afterFullData
      } = internalData;
      const treeOpts = $xeTable.computeTreeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let targetRow;
      if (currentRow) {
        if (treeConfig) {
          const {
            index,
            items
          } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => item === currentRow, {
            children: childrenField
          });
          if (isUpArrow && index > 0) {
            targetRow = items[index - 1];
          } else if (isDwArrow && index < items.length - 1) {
            targetRow = items[index + 1];
          }
        } else {
          const _rowIndex = $xeTable.getVTRowIndex(currentRow);
          if (isUpArrow && _rowIndex > 0) {
            targetRow = afterFullData[_rowIndex - 1];
          } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
            targetRow = afterFullData[_rowIndex + 1];
          }
        }
      } else {
        targetRow = afterFullData[0];
      }
      if (targetRow) {
        evnt.preventDefault();
        const params = {
          $table: $xeTable,
          row: targetRow,
          rowIndex: $xeTable.getRowIndex(targetRow),
          $rowIndex: $xeTable.getVMRowIndex(targetRow)
        };
        $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
      }
    },
    // 处理当前列方向键移动
    moveCurrentColumn(isLeftArrow, isRightArrow, evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        currentColumn
      } = reactData;
      const {
        visibleColumn
      } = internalData;
      let targetCol = null;
      if (currentColumn) {
        const _columnIndex = $xeTable.getVTColumnIndex(currentColumn);
        if (isLeftArrow && _columnIndex > 0) {
          targetCol = visibleColumn[_columnIndex - 1];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          targetCol = visibleColumn[_columnIndex + 1];
        }
      } else {
        targetCol = visibleColumn[0];
      }
      if (targetCol) {
        evnt.preventDefault();
        const params = {
          $table: $xeTable,
          column: targetCol,
          columnIndex: $xeTable.getColumnIndex(targetCol),
          $columnIndex: $xeTable.getVMColumnIndex(targetCol)
        };
        $xeTable.scrollToColumn(targetCol).then(() => $xeTable.triggerCurrentColumnEvent(evnt, params));
      }
    },
    // 处理可编辑方向键移动
    moveArrowSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const {
        highlightCurrentRow,
        highlightCurrentColumn
      } = props;
      const rowOpts = $xeTable.computeRowOpts;
      const currentRowOpts = $xeTable.computeCurrentRowOpts;
      const columnOpts = $xeTable.computeColumnOpts;
      const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
      const params = handleMoveSelected($xeTable, evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      if (rowOpts.isCurrent || highlightCurrentRow) {
        if (currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        } else {
          // 当前行按键上下移动
          if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
            $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
          }
        }
      }
      if (columnOpts.isCurrent || highlightCurrentColumn) {
        if (currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        } else {
          // 当前行按键左右移动
          if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
            $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
          }
        }
      }
    },
    moveEnterSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
      const $xeTable = this;
      const props = $xeTable;
      const {
        highlightCurrentRow,
        highlightCurrentColumn
      } = props;
      const rowOpts = $xeTable.computeRowOpts;
      const currentRowOpts = $xeTable.computeCurrentRowOpts;
      const columnOpts = $xeTable.computeColumnOpts;
      const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
      const params = handleMoveSelected($xeTable, evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      if ((rowOpts.isCurrent || highlightCurrentRow) && currentRowOpts.isFollowSelected) {
        $xeTable.triggerCurrentRowEvent(evnt, params);
      }
      if ((columnOpts.isCurrent || highlightCurrentColumn) && currentColumnOpts.isFollowSelected) {
        $xeTable.triggerCurrentColumnEvent(evnt, params);
      }
    },
    // 处理可编辑方向键移动
    moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
      const $xeTable = this;
      handleMoveSelected($xeTable, evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
    },
    handleCellMousedownEvent(evnt, params) {
      const $xeTable = this;
      const {
        editConfig,
        editOpts,
        handleSelected,
        checkboxConfig,
        checkboxOpts,
        mouseConfig,
        mouseOpts
      } = this;
      if (mouseConfig && mouseOpts.area && $xeTable.triggerCellAreaMousedownEvent) {
        return $xeTable.triggerCellAreaMousedownEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          this.handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === 'cell') {
            handleSelected(params, evnt);
          }
        }
      }
    },
    handleCheckboxRangeEvent(evnt, params) {
      const $xeTable = this;
      const internalData = $xeTable;
      const {
        elemStore
      } = internalData;
      const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
      const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
      const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
      const {
        column,
        cell
      } = params;
      if (column.type === 'checkbox') {
        let bodyWrapperElem = bodyScrollElem;
        if (leftScrollElem && column.fixed === 'left') {
          bodyWrapperElem = leftScrollElem;
        } else if (rightScrollElem && column.fixed === 'right') {
          bodyWrapperElem = rightScrollElem;
        }
        if (!bodyWrapperElem) {
          return;
        }
        const el = $xeTable.$refs.refElem;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const checkboxRangeElem = bodyWrapperElem.querySelector('.vxe-table--checkbox-range');
        const trElem = cell.parentNode;
        const selectRecords = this.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent = (type, evnt) => {
          this.emitEvent(`checkbox-range-${type}`, {
            records: () => this.getCheckboxRecords(),
            reserves: () => this.getCheckboxReserveRecords()
          }, evnt);
        };
        const handleChecked = evnt => {
          const {
            clientX,
            clientY
          } = evnt;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            // 向上
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            // 向下
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            // 向左
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            // 向右
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = 'block';
          const rangeRows = getCheckboxRangeRows(this, evnt, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          // 至少滑动 10px 才能有效匹配
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            const isControlKey = hasControlKey(evnt);
            lastRangeRows = rangeRows;
            if (isControlKey) {
              rangeRows.forEach(row => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              this.setAllCheckboxRow(false);
              this.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent('change', evnt);
          }
        };
        // 停止鼠标滚动
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        // 开始鼠标滚动
        const startMouseScroll = evnt => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const {
                scrollLeft,
                scrollTop,
                clientHeight,
                scrollHeight
              } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  this.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  this.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, 'drag--range');
        document.onmousemove = evnt => {
          evnt.preventDefault();
          evnt.stopPropagation();
          const {
            clientY
          } = evnt;
          const {
            boundingTop
          } = getAbsolutePos(bodyWrapperElem);
          // 如果超过可视区，触发滚动
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt);
        };
        document.onmouseup = evnt => {
          stopMouseScroll();
          removeClass(el, 'drag--range');
          checkboxRangeElem.removeAttribute('style');
          document.onmousemove = null;
          document.onmouseup = null;
          triggerEvent('end', evnt);
        };
        triggerEvent('start', evnt);
      }
    }
  }
});
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

;// CONCATENATED MODULE: ./packages/table/module/validator/mixin.ts








const {
  getConfig: validator_mixin_getConfig,
  validators: mixin_validators
} = core_.VxeUI;
/**
 * 校验规则
 */
class Rule {
  constructor(rule) {
    _defineProperty(this, "$options", void 0);
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
// 如果存在 pattern，判断正则
function validREValue(pattern, val) {
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
// 如果存在 max，判断最大值
function validMaxValue(max, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && num > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return false;
  }
  return true;
}
// 如果存在 min，判断最小值
function validMinValue(min, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && num < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isArrType = type === 'array';
  const isNumType = type === 'number';
  const isStrType = type === 'string';
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const {
    required
  } = rule;
  const isEmptyVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
/* harmony default export */ var validator_mixin = ({
  methods: {
    /**
     * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验
     */
    _fullValidate(rows, cb) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
        warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);
      }
      return this.beginValidate(rows, null, cb, true);
    },
    /**
     * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
     */
    _validate(rows, cb) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
        warnLog('vxe.error.notValidators', ['validate(rows, callback)', 'validate(rows)']);
      }
      return this.beginValidate(rows, null, cb);
    },
    /**
     * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
     */
    _fullValidateField(rows, fieldOrColumn) {
      const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn(this, column));
      if (colList.length) {
        return this.beginValidate(rows, colList, null, true);
      }
      return this.$nextTick();
    },
    /**
     * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
     */
    _validateField(rows, fieldOrColumn) {
      const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn(this, column));
      if (colList.length) {
        return this.beginValidate(rows, colList, null);
      }
      return this.$nextTick();
    },
    /**
     * 聚焦到校验通过的单元格并弹出校验错误提示
     */
    handleValidError(params) {
      const {
        validOpts
      } = this;
      return new Promise(resolve => {
        if (validOpts.autoPos === false) {
          this.emitEvent('valid-error', params);
          resolve();
        } else {
          this.handleEdit(params, {
            type: 'valid-error',
            trigger: 'call'
          }).then(() => {
            setTimeout(() => {
              resolve(this.showValidTooltip(params));
            }, 10);
          });
        }
      });
    },
    handleErrMsgMode(validErrMaps) {
      const {
        validOpts
      } = this;
      if (validOpts.msgMode === 'single') {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    },
    /**
     * 对表格数据进行校验
     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改
     * 如果传 true 则校验当前表格数据
     * 如果传 row 指定行记录，则只验证传入的行
     * 如果传 rows 为多行记录，则只验证传入的行
     * 如果只传 callback 否则默认验证整个表格数据
     * 返回 Promise 对象，或者使用回调方式
     */
    beginValidate(rows, cols, cb, isFull) {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const validRest = {};
      const {
        editRules,
        treeConfig
      } = props;
      const {
        isRowGroupStatus
      } = reactData;
      const {
        afterFullData,
        pendingRowMaps,
        removeRowMaps
      } = internalData;
      const treeOpts = $xeTable.computeTreeOpts;
      const aggregateOpts = $xeTable.computeAggregateOpts;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rows)) {
          cb = rows;
        } else {
          validList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        validList = this.getInsertRecords().concat(this.getUpdateRecords());
      }
      const rowValidErrs = [];
      this.lastCallTime = Date.now();
      this.validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行
      this.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : this.getColumns();
        const handleVaild = row => {
          const rowid = getRowid($xeTable, row);
          // 是否删除
          if (removeRowMaps[rowid]) {
            return;
          }
          // 是否标记删除
          if (pendingRowMaps[rowid]) {
            return;
          }
          if ($xeTable.isAggregateRecord(row)) {
            return;
          }
          if (isFull || !this.validRuleErr) {
            const colVailds = [];
            columns.forEach(column => {
              const field = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(column) ? column : column.field;
              if ((isFull || !this.validRuleErr) && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(editRules, field)) {
                colVailds.push(this.validCellRules('all', row, column).catch(({
                  rule,
                  rules
                }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: this.getRowIndex(row),
                    row,
                    columnIndex: this.getColumnIndex(column),
                    column,
                    field,
                    $table: this
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid(this, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    this.validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (isRowGroupStatus) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: aggregateOpts.mapChildrenField
          });
        } else if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: childrenField
          });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          this.validErrorMaps = this.handleErrMsgMode(validErrMaps);
          return this.$nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch(firstErrParams => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              this.$nextTick(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (validator_mixin_getConfig().validToReject === 'obsolete') {
                    // 已废弃，校验失败将不会执行catch
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = this.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              this.handleValidError(firstErrParams).then(finish);
            };
            /**
             * 当校验不通过时
             * 将表格滚动到可视区
             * 由于提示信息至少需要占一行，定位向上偏移一行
             */
            if (this.validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              this.scrollToRow(row, column).then(posAndFinish);
            }
          });
        });
      } else {
        this.validErrorMaps = {};
      }
      return this.$nextTick().then(() => {
        if (cb) {
          cb();
        }
      });
    },
    hasCellRules(type, row, column) {
      const {
        editRules
      } = this;
      const {
        property
      } = column;
      if (property && editRules) {
        const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, property);
        return rules && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger);
      }
      return false;
    },
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
     * 如果是传回调方式这返回一个校验不通过列的错误消息
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
     *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
     */
    validCellRules(validType, row, column, val) {
      const {
        editRules
      } = this;
      const {
        property
      } = column;
      const errorRules = [];
      const syncValidList = [];
      if (property && editRules) {
        const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, property);
        if (rules) {
          const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, property) : val;
          rules.forEach(rule => {
            const {
              trigger,
              validator
            } = rule;
            if (validType === 'all' || !trigger || validType === trigger) {
              if (validator) {
                const validParams = {
                  cellValue,
                  rule,
                  rules,
                  row,
                  rowIndex: this.getRowIndex(row),
                  column,
                  columnIndex: this.getColumnIndex(column),
                  field: column.property,
                  $table: this
                };
                let customValid;
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                  const gvItem = mixin_validators.get(validator);
                  if (gvItem) {
                    const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                    if (tcvMethod) {
                      customValid = tcvMethod(validParams);
                    } else {
                      errLog('vxe.error.notValidators', [validator]);
                    }
                  } else {
                    errLog('vxe.error.notValidators', [validator]);
                  }
                } else {
                  customValid = validator(validParams);
                }
                if (customValid) {
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                    this.validRuleErr = true;
                    errorRules.push(new Rule({
                      type: 'custom',
                      trigger,
                      content: customValid.message,
                      rule: new Rule(rule)
                    }));
                  } else if (customValid.catch) {
                    // 如果为异步校验（注：异步校验是并发无序的）
                    syncValidList.push(customValid.catch(e => {
                      this.validRuleErr = true;
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: e && e.message ? e.message : rule.content || rule.message,
                        rule: new Rule(rule)
                      }));
                    }));
                  }
                }
              } else {
                if (!checkRuleStatus(rule, cellValue)) {
                  this.validRuleErr = true;
                  errorRules.push(new Rule(rule));
                }
              }
            }
          });
        }
      }
      return Promise.all(syncValidList).then(() => {
        if (errorRules.length) {
          const rest = {
            rules: errorRules,
            rule: errorRules[0]
          };
          return Promise.reject(rest);
        }
      });
    },
    _clearValidate(rows, fieldOrColumn) {
      const {
        validOpts,
        validErrorMaps
      } = this;
      const validTip = this.$refs.refValidTooltip;
      const rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : rows ? [rows] : [];
      const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn(this, column));
      let validErrMaps = {};
      if (validTip && validTip.visible) {
        validTip.close();
      }
      // 如果是单个提示模式
      if (validOpts.msgMode === 'single') {
        this.validErrorMaps = {};
        return this.$nextTick();
      }
      if (rowList.length && colList.length) {
        validErrMaps = Object.assign({}, validErrorMaps);
        rowList.forEach(row => {
          colList.forEach(column => {
            const validKey = `${getRowid(this, row)}:${column.id}`;
            if (validErrMaps[validKey]) {
              delete validErrMaps[validKey];
            }
          });
        });
      } else if (rowList.length) {
        const rowIdList = rowList.map(row => `${getRowid(this, row)}`);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
          if (rowIdList.indexOf(key.split(':')[0]) > -1) {
            validErrMaps[key] = item;
          }
        });
      } else if (colList.length) {
        const colidList = colList.map(column => `${column.id}`);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
          if (colidList.indexOf(key.split(':')[1]) > -1) {
            validErrMaps[key] = item;
          }
        });
      }
      this.validErrorMaps = validErrMaps;
      return this.$nextTick();
    },
    /**
     * 触发校验
     */
    triggerValidate(type) {
      const {
        editConfig,
        editStore,
        editRules,
        editOpts,
        validOpts
      } = this;
      const {
        actived
      } = editStore;
      // 检查清除校验消息
      if (editRules && validOpts.msgMode === 'single') {
        this.validErrorMaps = {};
      }
      // 校验单元格
      if (editConfig && editRules && actived.row) {
        const {
          row,
          column,
          cell
        } = actived.args;
        if (this.hasCellRules(type, row, column)) {
          return this.validCellRules(type, row, column).then(() => {
            if (editOpts.mode === 'row') {
              this.clearValidate(row, column);
            }
          }).catch(({
            rule
          }) => {
            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理
            if (!rule.trigger || type === rule.trigger) {
              const rest = {
                rule,
                row,
                column,
                cell
              };
              this.showValidTooltip(rest);
              return Promise.reject(rest);
            }
            return Promise.resolve();
          });
        }
      }
      return Promise.resolve();
    },
    /**
     * 弹出校验错误提示
     */
    showValidTooltip(params) {
      const {
        $refs,
        height,
        validStore,
        validErrorMaps,
        tableData,
        validOpts
      } = this;
      const {
        rule,
        row,
        column,
        cell
      } = params;
      const validTip = $refs.refValidTooltip;
      const content = rule.content;
      validStore.visible = true;
      if (validOpts.msgMode === 'single') {
        this.validErrorMaps = {
          [`${getRowid(this, row)}:${column.id}`]: {
            column,
            row,
            rule,
            content
          }
        };
      } else {
        this.validErrorMaps = Object.assign({}, validErrorMaps, {
          [`${getRowid(this, row)}:${column.id}`]: {
            column,
            row,
            rule,
            content
          }
        });
      }
      this.emitEvent('valid-error', params, null);
      if (validTip) {
        if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
          return validTip.open(cell, content);
        }
      }
      return this.$nextTick();
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/module/custom/mixin.ts

function calcMaxHeight($xeTable) {
  const reactData = $xeTable;
  const {
    customStore
  } = reactData;
  const el = $xeTable.$refs.refElem;
  // 判断面板不能大于表格高度
  let tableHeight = 0;
  if (el) {
    tableHeight = el.clientHeight - 28;
  }
  customStore.maxHeight = Math.max(88, tableHeight);
}
function emitCustomEvent($xeTable, type, evnt) {
  const $xeGrid = $xeTable.$xeGrid;
  const comp = $xeGrid || $xeTable;
  comp.dispatchEvent('custom', {
    type
  }, evnt);
}
/* harmony default export */ var custom_mixin = ({
  methods: {
    _openCustom() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        initStore,
        customStore
      } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      $xeTable.handleUpdateCustomColumn();
      $xeTable.checkCustomStatus();
      calcMaxHeight($xeTable);
      return $xeTable.$nextTick().then(() => calcMaxHeight($xeTable));
    },
    _closeCustom() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customStore
      } = reactData;
      const customOpts = $xeTable.computeCustomOpts;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return $xeTable.$nextTick();
    },
    _saveCustom() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customOpts,
        customColumnList
      } = this;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parentColumn) => {
        if (parentColumn) {
          // 更新子列信息
          column.fixed = parentColumn.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
      });
      reactData.isCustomStatus = true;
      reactData.isDragColMove = true;
      setTimeout(() => {
        reactData.isDragColMove = false;
      }, 1000);
      return $xeTable.saveCustomStore('confirm');
    },
    _cancelCustom() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customColumnList,
        customStore
      } = reactData;
      const {
        oldSortMaps,
        oldFixedMaps,
        oldVisibleMaps
      } = customStore;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || '';
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, {
        children: 'children'
      });
      return $xeTable.$nextTick();
    },
    _resetCustom(options) {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        collectColumn
      } = internalData;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        checkMethod
      } = customOpts;
      const opts = Object.assign({
        visible: true,
        resizable: options === true,
        fixed: options === true,
        sort: options === true
      }, options);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
        if (opts.resizable) {
          column.resizeWidth = 0;
        }
        if (opts.fixed) {
          column.fixed = column.defaultFixed;
        }
        if (opts.sort) {
          column.renderSortNumber = column.sortNumber;
        }
        if (!checkMethod || checkMethod({
          $table: $xeTable,
          column
        })) {
          column.visible = column.defaultVisible;
        }
        column.renderResizeWidth = column.renderWidth;
      });
      reactData.isCustomStatus = false;
      $xeTable.saveCustomStore('reset');
      return $xeTable.handleCustom();
    },
    _toggleCustomAllCheckbox() {
      const {
        customStore
      } = this;
      const isAll = !customStore.isAll;
      return this.setCustomAllCheckbox(isAll);
    },
    _setCustomAllCheckbox(checked) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customStore
      } = reactData;
      const {
        customColumnList
      } = reactData;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        checkMethod,
        visibleMethod
      } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
    },
    checkCustomStatus() {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = $xeTable.computeCustomOpts;
      const {
        checkMethod
      } = customOpts;
      customStore.isAll = collectColumn.every(column => (checkMethod ? !checkMethod({
        $table: $xeTable,
        column
      }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some(column => (!checkMethod || checkMethod({
        $table: $xeTable,
        column
      })) && (column.renderVisible || column.halfVisible));
    },
    emitCustomEvent(type, evnt) {
      const $xeTable = this;
      const $xeGrid = $xeTable.$xeGrid;
      const comp = $xeGrid || $xeTable;
      comp.dispatchEvent('custom', {
        type
      }, evnt);
    },
    triggerCustomEvent(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customStore
      } = reactData;
      if (customStore.visible) {
        this.closeCustom();
        emitCustomEvent($xeTable, 'close', evnt);
      } else {
        customStore.btnEl = evnt.target;
        this.openCustom();
        emitCustomEvent($xeTable, 'open', evnt);
      }
    },
    customOpenEvent(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customStore
      } = reactData;
      if (customStore.visible) {
        customStore.activeBtn = true;
        customStore.btnEl = evnt.target;
        $xeTable.openCustom();
        emitCustomEvent($xeTable, 'open', evnt);
      }
    },
    customCloseEvent(evnt) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        customStore
      } = reactData;
      if (customStore.visible) {
        customStore.activeBtn = false;
        $xeTable.closeCustom();
        emitCustomEvent($xeTable, 'close', evnt);
      }
    },
    handleUpdateCustomColumn() {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/table/src/table.ts

























const {
  getConfig: table_getConfig,
  getIcon: table_getIcon,
  getI18n: table_getI18n,
  renderer: table_renderer,
  globalResize: table_globalResize,
  globalEvents: table_globalEvents,
  globalMixins: table_globalMixins,
  renderEmptyElement: table_renderEmptyElement
} = core_.VxeUI;
function handleKeyField($xeTable) {
  const internalData = $xeTable;
  const keyField = $xeTable.computeRowField;
  internalData.currKeyField = keyField;
  internalData.isCurrDeepKey = hasDeepKey(keyField);
}
/**
 * 渲染浮固定列
 * 分别渲染左边固定列和右边固定列
 * 如果宽度足够情况下，则不需要渲染固定列
 */
function renderFixed(h, $xeTable, fixedType) {
  const props = $xeTable;
  const reactData = $xeTable;
  const {
    showHeader,
    showFooter
  } = props;
  const {
    tableData,
    tableColumn,
    tableGroupColumn,
    columnStore,
    footerTableData
  } = reactData;
  const isFixedLeft = fixedType === 'left';
  const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
  return h('div', {
    ref: isFixedLeft ? 'refLeftContainer' : 'refRightContainer',
    class: `vxe-table--fixed-${fixedType}-wrapper`
  }, [showHeader ? h(header, {
    props: {
      fixedType,
      tableData,
      tableColumn,
      tableGroupColumn,
      fixedColumn
    },
    ref: `${fixedType}Header`
  }) : table_renderEmptyElement($xeTable), h(body, {
    props: {
      fixedType,
      tableData,
      tableColumn,
      fixedColumn
    },
    ref: `${fixedType}Body`
  }), showFooter ? h(footer, {
    props: {
      footerTableData,
      tableColumn,
      fixedColumn,
      fixedType
    },
    ref: `${fixedType}Footer`
  }) : table_renderEmptyElement($xeTable)]);
}
function renderEmptyBody(h, _vm) {
  const {
    $scopedSlots,
    emptyOpts
  } = _vm;
  let emptyContent = '';
  const params = {
    $table: _vm
  };
  if ($scopedSlots.empty) {
    emptyContent = $scopedSlots.empty.call(_vm, params, h);
  } else {
    const compConf = emptyOpts.name ? table_renderer.get(emptyOpts.name) : null;
    const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
    if (rtEmptyView) {
      emptyContent = getSlotVNs(rtEmptyView.call(_vm, h, emptyOpts, params));
    } else {
      emptyContent = getFuncText(_vm.emptyText) || table_getI18n('vxe.table.emptyText');
    }
  }
  return emptyContent;
}
const renderDragTipContents = (h, $xeTable) => {
  const props = $xeTable;
  const reactData = $xeTable;
  const {
    dragConfig
  } = props;
  const {
    dragRow,
    dragCol,
    dragTipText
  } = reactData;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  const rowDragOpts = $xeTable.computeRowDragOpts;
  const rowDragSlots = rowDragOpts.slots || {};
  const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
  const columnDragSlots = columnDragOpts.slots || {};
  const cTipSlot = columnDragSlots.tip;
  if (dragRow && rTipSlot) {
    return $xeTable.callSlot(rTipSlot, {
      row: dragRow
    }, h);
  }
  if (dragCol && cTipSlot) {
    return $xeTable.callSlot(cTipSlot, {
      column: dragCol
    }, h);
  }
  return [h('span', dragTipText)];
};
const table_renderDragTip = (h, $xeTable) => {
  const reactData = $xeTable;
  const {
    dragRow,
    dragCol
  } = reactData;
  const rowOpts = $xeTable.computeRowOpts;
  const columnOpts = $xeTable.computeColumnOpts;
  const rowDragOpts = $xeTable.computeRowDragOpts;
  const columnDragOpts = $xeTable.computeColumnDragOpts;
  if (rowOpts.drag || columnOpts.drag) {
    return h('div', {
      class: 'vxe-table--drag-wrapper'
    }, [h('div', {
      ref: 'refDragRowLineElem',
      class: ['vxe-table--drag-row-line', {
        'is--guides': rowDragOpts.showGuidesStatus
      }]
    }), h('div', {
      ref: 'refDragColLineElem',
      class: ['vxe-table--drag-col-line', {
        'is--guides': columnDragOpts.showGuidesStatus
      }]
    }), dragRow && rowDragOpts.showDragTip || dragCol && columnDragOpts.showDragTip ? h('div', {
      ref: 'refDragTipElem',
      class: 'vxe-table--drag-sort-tip'
    }, [h('div', {
      class: 'vxe-table--drag-sort-tip-wrapper'
    }, [h('div', {
      class: 'vxe-table--drag-sort-tip-status'
    }, [h('span', {
      class: ['vxe-table--drag-sort-tip-normal-status', dragRow ? table_getIcon().TABLE_DRAG_STATUS_ROW : table_getIcon().TABLE_DRAG_STATUS_COLUMN]
    }), h('span', {
      class: ['vxe-table--drag-sort-tip-sub-status', table_getIcon().TABLE_DRAG_STATUS_SUB_ROW]
    }), h('span', {
      class: ['vxe-table--drag-sort-tip-disabled-status', table_getIcon().TABLE_DRAG_DISABLED]
    })]), h('div', {
      class: 'vxe-table--drag-sort-tip-content'
    }, renderDragTipContents(h, $xeTable))])]) : table_renderEmptyElement($xeTable)]);
  }
  return table_renderEmptyElement($xeTable);
};
function handleUpdateResize(_vm) {
  const {
    $el
  } = _vm;
  if ($el && $el.clientWidth && $el.clientHeight) {
    _vm.recalculate();
  }
}
function renderRowExpandedVNs(h, $xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const internalData = $xeTable;
  const $xeGrid = $xeTable.$xeGrid;
  const {
    treeConfig
  } = props;
  const {
    expandColumn,
    isRowGroupStatus
  } = reactData;
  const tableRowExpandedList = $xeTable.computeTableRowExpandedList;
  const expandOpts = $xeTable.computeExpandOpts;
  const {
    mode
  } = expandOpts;
  if (mode !== 'fixed') {
    return table_renderEmptyElement($xeTable);
  }
  const expandVNs = [h('div', {
    key: 'repY',
    ref: 'refRowExpandYSpaceElem'
  })];
  if (expandColumn) {
    const {
      handleGetRowId
    } = createHandleGetRowId($xeTable);
    tableRowExpandedList.forEach(row => {
      const expandOpts = $xeTable.computeExpandOpts;
      const {
        height: expandHeight,
        padding,
        indent
      } = expandOpts;
      const {
        fullAllDataRowIdData,
        fullColumnIdData
      } = internalData;
      const treeOpts = $xeTable.computeTreeOpts;
      const {
        transform,
        seqMode
      } = treeOpts;
      const cellStyle = {};
      const rowid = handleGetRowId(row);
      const rowRest = fullAllDataRowIdData[rowid];
      const colid = expandColumn.id;
      const colRest = fullColumnIdData[colid] || {};
      let rowLevel = 0;
      let seq = -1;
      let _rowIndex = -1;
      let rowIndex = -1;
      let $rowIndex = -1;
      if (rowRest) {
        rowLevel = rowRest.level;
        if (isRowGroupStatus || treeConfig && transform && seqMode === 'increasing') {
          seq = rowRest._index + 1;
        } else {
          seq = rowRest.seq;
        }
        rowIndex = rowRest.index;
        $rowIndex = rowRest.$index;
        _rowIndex = rowRest._index;
      }
      if (expandHeight) {
        cellStyle.height = `${expandHeight}px`;
      }
      if (isRowGroupStatus || treeConfig) {
        cellStyle.paddingLeft = `${rowLevel * (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(indent) ? indent : treeOpts.indent) + 30}px`;
      }
      let columnIndex = -1;
      let $columnIndex = -1;
      let _columnIndex = -1;
      if (colRest) {
        columnIndex = colRest.index;
        $columnIndex = colRest.$index;
        _columnIndex = colRest._index;
      }
      const expandParams = {
        $grid: $xeGrid,
        $table: $xeTable,
        seq,
        column: expandColumn,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: '',
        type: 'body',
        level: rowLevel,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        isHidden: false,
        isEdit: false,
        visibleData: [],
        data: [],
        items: []
      };
      expandVNs.push(h('div', {
        key: rowid,
        class: ['vxe-body--row-expanded-cell', {
          'is--padding': padding,
          'is--ellipsis': expandHeight
        }],
        attrs: {
          rowid
        },
        style: cellStyle
      }, expandColumn.renderData(h, expandParams)));
    });
  }
  return h('div', {
    ref: 'refRowExpandElem',
    class: 'vxe-table--row-expanded-wrapper'
  }, expandVNs);
}
function renderScrollX(h, $xeTable) {
  return h('div', {
    key: 'vsx',
    ref: 'refScrollXVirtualElem',
    class: 'vxe-table--scroll-x-virtual'
  }, [h('div', {
    ref: 'refScrollXLeftCornerElem',
    class: 'vxe-table--scroll-x-left-corner'
  }), h('div', {
    ref: 'refScrollXWrapperElem',
    class: 'vxe-table--scroll-x-wrapper'
  }, [h('div', {
    ref: 'refScrollXHandleElem',
    class: 'vxe-table--scroll-x-handle',
    on: {
      scroll: $xeTable.triggerVirtualScrollXEvent
    }
  }, [h('div', {
    ref: 'refScrollXSpaceElem',
    class: 'vxe-table--scroll-x-space'
  })])]), h('div', {
    ref: 'refScrollXRightCornerElem',
    class: 'vxe-table--scroll-x-right-corner'
  })]);
}
function renderScrollY(h, $xeTable) {
  return h('div', {
    ref: 'refScrollYVirtualElem',
    class: 'vxe-table--scroll-y-virtual'
  }, [h('div', {
    ref: 'refScrollYTopCornerElem',
    class: 'vxe-table--scroll-y-top-corner'
  }), h('div', {
    ref: 'refScrollYWrapperElem',
    class: 'vxe-table--scroll-y-wrapper'
  }, [h('div', {
    ref: 'refScrollYHandleElem',
    class: 'vxe-table--scroll-y-handle',
    on: {
      scroll: $xeTable.triggerVirtualScrollYEvent
    }
  }, [h('div', {
    ref: 'refScrollYSpaceElem',
    class: 'vxe-table--scroll-y-space'
  })])]), h('div', {
    ref: 'refScrollYBottomCornerElem',
    class: 'vxe-table--scroll-y-bottom-corner'
  })]);
}
function renderViewport(h, $xeTable) {
  const props = $xeTable;
  const reactData = $xeTable;
  const {
    showHeader,
    showFooter
  } = props;
  const {
    overflowX,
    tableData,
    tableColumn,
    tableGroupColumn,
    footerTableData,
    columnStore
  } = reactData;
  const {
    leftList,
    rightList
  } = columnStore;
  return h('div', {
    ref: 'refTableViewportElem',
    class: 'vxe-table--viewport-wrapper'
  }, [h('div', {
    class: 'vxe-table--main-wrapper'
  }, [
  /**
     * 表头
     */
  showHeader ? h(header, {
    ref: 'refTableHeader',
    props: {
      tableData,
      tableColumn,
      tableGroupColumn
    }
  }) : table_renderEmptyElement($xeTable),
  /**
     * 表体
     */
  h(body, {
    ref: 'refTableBody',
    props: {
      tableData,
      tableColumn
    }
  }),
  /**
     * 表尾
     */
  showFooter ? h(footer, {
    ref: 'refTableFooter',
    props: {
      footerTableData,
      tableColumn
    }
  }) : table_renderEmptyElement($xeTable)]), h('div', {
    class: 'vxe-table--fixed-wrapper'
  }, [leftList && leftList.length && overflowX ? renderFixed(h, $xeTable, 'left') : table_renderEmptyElement($xeTable), rightList && rightList.length && overflowX ? renderFixed(h, $xeTable, 'right') : table_renderEmptyElement($xeTable)]), renderRowExpandedVNs(h, $xeTable)]);
}
function renderBody(h, $xeTable) {
  const scrollbarYToLeft = $xeTable.computeScrollbarYToLeft;
  return h('div', {
    class: 'vxe-table--layout-wrapper'
  }, scrollbarYToLeft ? [renderScrollY(h, $xeTable), renderViewport(h, $xeTable)] : [renderViewport(h, $xeTable), renderScrollY(h, $xeTable)]);
}
/* harmony default export */ var table = ({
  name: 'VxeTable',
  mixins: [table_globalMixins.sizeMixin, mixin, menu_mixin, edit_mixin, export_mixin, keyboard_mixin, validator_mixin, custom_mixin],
  props: props,
  provide() {
    return {
      $xeTable: this,
      xecolgroup: null
    };
  },
  inject: {
    $xeTabs: {
      default: null
    },
    $xeGrid: {
      default: null
    }
  },
  data() {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    return {
      xID,
      tId: xID,
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 行分组列信息
      rowGroupColumn: null,
      // 展开列信息
      expandColumn: null,
      hasFixedColumn: false,
      // 树节点列信息
      treeNodeColumn: null,
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      customColumnList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        }
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        visible: false,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: '',
        modeList: [],
        typeList: [],
        filename: '',
        visible: false
      },
      importParams: {
        mode: '',
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: '',
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasTree: false,
        hasMerge: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: '',
        sheetName: '',
        mode: '',
        type: '',
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isTitle: false,
        isFooter: false
      },
      visiblwRowsFlag: 1,
      isRowGroupStatus: false,
      rowGroupExpandedFlag: 1,
      rowExpandedFlag: 1,
      treeExpandedFlag: 1,
      updateCheckboxFlag: 1,
      pendingRowFlag: 1,
      insertRowFlag: 1,
      removeRowFlag: 1,
      mergeBodyFlag: 1,
      mergeFootFlag: 1,
      rowHeightStore: {
        large: 52,
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      },
      scrollVMLoading: false,
      scrollYHeight: 0,
      scrollYTop: 0,
      isScrollYBig: false,
      scrollXLeft: 0,
      scrollXWidth: 0,
      isScrollXBig: false,
      rowExpandHeightFlag: 1,
      calcCellHeightFlag: 1,
      resizeHeightFlag: 1,
      resizeWidthFlag: 1,
      isCustomStatus: false,
      isDragRowMove: false,
      dragRow: null,
      isDragColMove: false,
      dragCol: null,
      dragTipText: '',
      isDragResize: false,
      isRowLoading: false,
      isColLoading: false,
      reScrollFlag: 0,
      reLayoutFlag: 0,
      footFlag: 0
    };
  },
  computed: {
    ...{},
    tableId() {
      return this.computeTableId;
    },
    computeTableId() {
      const {
        id
      } = this;
      if (id) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(id)) {
          return `${id({
            $table: this
          }) || ''}`;
        }
        return `${id}`;
      }
      return '';
    },
    computeRowField() {
      const $xeTable = this;
      const props = $xeTable;
      const rowOpts = $xeTable.computeRowOpts;
      return `${props.rowId || rowOpts.keyField || '_X_ROW_KEY'}`;
    },
    validOpts() {
      return this.computeValidOpts;
    },
    computeValidOpts() {
      return Object.assign({
        message: 'default'
      }, table_getConfig().table.validConfig, this.validConfig);
    },
    sXOpts() {
      return this.computeVirtualXOpts;
    },
    computeSXOpts() {
      return this.computeVirtualXOpts;
    },
    computeScrollXThreshold() {
      const $xeTable = this;
      const virtualXOpts = $xeTable.computeVirtualXOpts;
      const {
        threshold
      } = virtualXOpts;
      if (threshold) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);
      }
      return 0;
    },
    sYOpts() {
      return this.computeVirtualYOpts;
    },
    computeSYOpts() {
      return this.computeVirtualYOpts;
    },
    computeVirtualXOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.virtualXConfig || table_getConfig().table.scrollX, props.virtualXConfig || props.scrollX);
    },
    computeVirtualYOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.virtualYConfig || table_getConfig().table.scrollY, props.virtualYConfig || props.scrollY);
    },
    computeScrollbarOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.scrollbarConfig, props.scrollbarConfig);
    },
    computeScrollbarXToTop() {
      const $xeTable = this;
      const scrollbarOpts = $xeTable.computeScrollbarOpts;
      return !!(scrollbarOpts.x && scrollbarOpts.x.position === 'top');
    },
    computeScrollbarYToLeft() {
      const $xeTable = this;
      const scrollbarOpts = $xeTable.computeScrollbarOpts;
      return !!(scrollbarOpts.y && scrollbarOpts.y.position === 'left');
    },
    computeScrollYThreshold() {
      const $xeTable = this;
      const virtualYOpts = $xeTable.computeVirtualYOpts;
      const {
        threshold
      } = virtualYOpts;
      if (threshold) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);
      }
      return 0;
    },
    rowHeightMaps() {
      return this.computeRowHeightMaps;
    },
    computeRowHeightMaps() {
      const $xeTable = this;
      const reactData = $xeTable;
      return reactData.rowHeightStore;
    },
    computeDefaultRowHeight() {
      const $xeTable = this;
      const vSize = $xeTable.computeSize;
      const rowHeightMaps = $xeTable.computeRowHeightMaps;
      return rowHeightMaps[vSize || 'default'] || 18;
    },
    columnOpts() {
      return this.computeColumnOpts;
    },
    computeColumnOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.columnConfig, props.columnConfig);
    },
    computeCurrentColumnOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.currentColumnConfig, props.currentColumnConfig);
    },
    computeCellOpts() {
      const $xeTable = this;
      const props = $xeTable;
      const cellOpts = Object.assign({}, table_getConfig().table.cellConfig, props.cellConfig);
      if (cellOpts.height) {
        cellOpts.height = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellOpts.height);
      }
      return cellOpts;
    },
    computeHeaderCellOpts() {
      const $xeTable = this;
      const props = $xeTable;
      const headerCellOpts = Object.assign({}, table_getConfig().table.headerCellConfig, props.headerCellConfig);
      const cellOpts = $xeTable.computeCellOpts;
      headerCellOpts.height = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCellHeight(headerCellOpts.height || cellOpts.height));
      return headerCellOpts;
    },
    computeFooterCellOpts() {
      const $xeTable = this;
      const props = $xeTable;
      const footerCellOpts = Object.assign({}, table_getConfig().table.footerCellConfig, props.footerCellConfig);
      const cellOpts = $xeTable.computeCellOpts;
      footerCellOpts.height = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCellHeight(footerCellOpts.height || cellOpts.height));
      return footerCellOpts;
    },
    rowOpts() {
      return this.computeRowOpts;
    },
    computeRowOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.rowConfig, props.rowConfig);
    },
    computeAggregateOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.aggregateConfig || table_getConfig().table.rowGroupConfig, props.aggregateConfig || props.rowGroupConfig);
    },
    computeRowGroupOpts() {
      const $xeTable = this;
      return $xeTable.computeAggregateOpts;
    },
    computeCurrentRowOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.currentRowConfig, props.currentRowConfig);
    },
    computeRowDragOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.rowDragConfig, props.rowDragConfig);
    },
    computeColumnDragOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.columnDragConfig, props.columnDragConfig);
    },
    resizeOpts() {
      return this.computeResizeOpts;
    },
    computeResizeOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.resizeConfig, props.resizeConfig);
    },
    resizableOpts() {
      return this.computeResizableOpts;
    },
    computeResizableOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.resizableConfig, props.resizableConfig);
    },
    seqOpts() {
      return this.computeSeqOpts;
    },
    computeSeqOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({
        startIndex: 0
      }, table_getConfig().table.seqConfig, props.seqConfig);
    },
    radioOpts() {
      return this.computeRadioOpts;
    },
    computeRadioOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.radioConfig, props.radioConfig);
    },
    checkboxOpts() {
      return this.computeCheckboxOpts;
    },
    computeCheckboxOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().table.checkboxConfig, props.checkboxConfig);
    },
    tooltipOpts() {
      return this.computeTooltipOpts;
    },
    computeTooltipOpts() {
      const $xeTable = this;
      const props = $xeTable;
      return Object.assign({}, table_getConfig().tooltip, table_getConfig().table.tooltipConfig, props.tooltipConfig);
    },
    tipConfig() {
      return {
        ...this.tooltipOpts
      };
    },
    computeTableTipConfig() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        tooltipStore
      } = reactData;
      const tooltipOpts = $xeTable.computeTooltipOpts;
      return Object.assign({}, tooltipOpts, tooltipStore.currOpts);
    },
    computeValidTipConfig() {
      const $xeTable = this;
      const tooltipOpts = $xeTable.computeTooltipOpts;
      return Object.assign({}, tooltipOpts);
    },
    validTipOpts() {
      return Object.assign({
        isArrow: false
      }, this.tooltipOpts);
    },
    editOpts() {
      return this.computeEditOpts;
    },
    computeEditOpts() {
      return Object.assign({}, table_getConfig().table.editConfig, this.editConfig);
    },
    sortOpts() {
      return this.computeSortOpts;
    },
    computeSortOpts() {
      return Object.assign({
        orders: ['asc', 'desc', null]
      }, table_getConfig().table.sortConfig, this.sortConfig);
    },
    filterOpts() {
      return this.computeFilterOpts;
    },
    computeFilterOpts() {
      return Object.assign({}, table_getConfig().table.filterConfig, this.filterConfig);
    },
    mouseOpts() {
      return this.computeMouseOpts;
    },
    computeMouseOpts() {
      return Object.assign({}, table_getConfig().table.mouseConfig, this.mouseConfig);
    },
    areaOpts() {
      return this.computeAreaOpts;
    },
    computeAreaOpts() {
      return Object.assign({}, table_getConfig().table.areaConfig, this.areaConfig);
    },
    keyboardOpts() {
      return this.computeKeyboardOpts;
    },
    computeKeyboardOpts() {
      return Object.assign({}, table_getConfig().table.keyboardConfig, this.keyboardConfig);
    },
    clipOpts() {
      return this.computeClipOpts;
    },
    computeClipOpts() {
      return Object.assign({}, table_getConfig().table.clipConfig, this.clipConfig);
    },
    fnrOpts() {
      return this.computeFNROpts;
    },
    computeFNROpts() {
      return Object.assign({}, table_getConfig().table.fnrConfig, this.fnrConfig);
    },
    headerCtxMenu() {
      return this.computeHeaderMenu;
    },
    computeHeaderMenu() {
      const $xeTable = this;
      const menuOpts = $xeTable.computeMenuOpts;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    },
    bodyCtxMenu() {
      return this.computeBodyMenu;
    },
    computeBodyMenu() {
      const $xeTable = this;
      const menuOpts = $xeTable.computeMenuOpts;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    },
    footerCtxMenu() {
      return this.computeFooterMenu;
    },
    computeFooterMenu() {
      const $xeTable = this;
      const menuOpts = $xeTable.computeMenuOpts;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    },
    isCtxMenu() {
      return this.computeIsMenu;
    },
    computeIsMenu() {
      const $xeTable = this;
      const props = $xeTable;
      const menuOpts = $xeTable.computeMenuOpts;
      const headerMenu = $xeTable.computeHeaderMenu;
      const bodyMenu = $xeTable.computeBodyMenu;
      const footerMenu = $xeTable.computeFooterMenu;
      return !!((props.contextMenu || props.menuConfig) && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    },
    ctxMenuList() {
      return this.computeMenuList;
    },
    computeMenuList() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        ctxMenuStore
      } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach(list => {
        list.forEach(item => {
          rest.push(item);
        });
      });
      return rest;
    },
    ctxMenuOpts() {
      return this.computeMenuOpts;
    },
    computeMenuOpts() {
      return Object.assign({}, table_getConfig().table.menuConfig, this.contextMenu, this.menuConfig);
    },
    computeLeftFixedWidth() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        columnStore
      } = reactData;
      const {
        leftList
      } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < leftList.length; i++) {
        const column = leftList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    },
    computeRightFixedWidth() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        columnStore
      } = reactData;
      const {
        rightList
      } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < rightList.length; i++) {
        const column = rightList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    },
    exportOpts() {
      return this.computeExportOpts;
    },
    computeExportOpts() {
      return Object.assign({}, table_getConfig().table.exportConfig, this.exportConfig);
    },
    importOpts() {
      return this.computeImportOpts;
    },
    computeImportOpts() {
      return Object.assign({}, table_getConfig().table.importConfig, this.importConfig);
    },
    printOpts() {
      return this.computePrintOpts;
    },
    computePrintOpts() {
      return Object.assign({}, table_getConfig().table.printConfig, this.printConfig);
    },
    expandOpts() {
      return this.computeExpandOpts;
    },
    computeExpandOpts() {
      return Object.assign({}, table_getConfig().table.expandConfig, this.expandConfig);
    },
    treeOpts() {
      return this.computeTreeOpts;
    },
    computeTreeOpts() {
      return Object.assign({}, table_getConfig().table.treeConfig, this.treeConfig);
    },
    emptyOpts() {
      return this.computeEmptyOpts;
    },
    computeEmptyOpts() {
      return Object.assign({}, table_getConfig().table.emptyRender, this.emptyRender);
    },
    loadingOpts() {
      return this.computeLoadingOpts;
    },
    computeLoadingOpts() {
      return Object.assign({}, table_getConfig().table.loadingConfig, this.loadingConfig);
    },
    computeCellOffsetWidth() {
      return this.border ? Math.max(2, Math.ceil(this.scrollbarWidth / this.tableColumn.length)) : 1;
    },
    customOpts() {
      return this.computeCustomOpts;
    },
    computeCustomOpts() {
      return Object.assign({}, table_getConfig().table.customConfig, this.customConfig);
    },
    computeTableRowExpandedList() {
      const $xeTable = this;
      const props = $xeTable;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        treeConfig
      } = props;
      const {
        rowExpandedFlag,
        expandColumn,
        rowGroupExpandedFlag,
        treeExpandedFlag,
        isRowGroupStatus
      } = reactData;
      const {
        visibleDataRowIdData,
        rowExpandedMaps
      } = internalData;
      const treeOpts = $xeTable.computeTreeOpts;
      const {
        transform
      } = treeOpts;
      const expandList = [];
      if (expandColumn && rowExpandedFlag && rowGroupExpandedFlag && treeExpandedFlag) {
        if (isRowGroupStatus || treeConfig && transform) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(rowExpandedMaps, (row, rowid) => {
            if (visibleDataRowIdData[rowid]) {
              expandList.push(row);
            }
          });
        } else {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().values(rowExpandedMaps);
        }
      }
      return expandList;
    },
    computeAutoWidthColumnList() {
      const {
        tableColumn,
        visibleColumn
      } = this;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter(column => column.width === 'auto' || column.minWidth === 'auto') : [];
    },
    computeFixedColumnSize() {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      const {
        tableColumn
      } = reactData;
      const {
        collectColumn
      } = internalData;
      let fixedSize = 0;
      // 只判断第一层
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach(column => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    },
    fixedColumnSize() {
      const $xeTable = this;
      return $xeTable.computeFixedColumnSize;
    },
    computeIsMaxFixedColumn() {
      const $xeTable = this;
      const fixedColumnSize = $xeTable.computeFixedColumnSize;
      const columnOpts = $xeTable.columnOpts;
      const {
        maxFixedSize
      } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    },
    computeTableBorder() {
      const $xeTable = this;
      const props = $xeTable;
      const {
        border
      } = props;
      if (border === true) {
        return 'full';
      }
      if (border) {
        return border;
      }
      return 'default';
    },
    /**
     * 判断列全选的复选框是否禁用
     */
    isAllCheckboxDisabled() {
      const {
        tableFullData,
        tableData,
        treeConfig,
        checkboxOpts
      } = this;
      const {
        strict,
        checkMethod
      } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
              // 暂时不支持树形结构
            }
            // 如果所有行都被禁用
            return tableFullData.every(row => !checkMethod({
              row
            }));
          }
          return false;
        }
        return true;
      }
      return false;
    },
    computeVirtualScrollBars() {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        overflowX,
        scrollXLoad,
        overflowY,
        scrollYLoad
      } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    },
    computeRowGroupFields() {
      const $xeTable = this;
      const aggregateOpts = $xeTable.computeAggregateOpts;
      return aggregateOpts.groupFields;
    },
    tabsResizeFlag() {
      const $xeTable = this;
      const $xeTabs = $xeTable.$xeTabs;
      return $xeTabs ? $xeTabs.reactData.resizeFlag : null;
    },
    computeVxeLanguage() {
      return core_.VxeUI.getLanguage();
    }
  },
  watch: {
    data(value) {
      const $xeTable = this;
      const reactData = $xeTable;
      const {
        initStatus
      } = this;
      if (value && value.length >= 50000) {
        warnLog('vxe.error.errLargeData', ['loadData(data), reloadData(data)']);
      }
      this.loadTableData(value || [], false).then(() => {
        const {
          scrollXLoad,
          scrollYLoad,
          expandColumn
        } = reactData;
        const expandOpts = $xeTable.computeExpandOpts;
        this.inited = true;
        this.initStatus = true;
        if (!initStatus) {
          this.handleLoadDefaults();
        }
        // const checkboxColumn = this.tableFullColumn.find(column => column.type === 'checkbox')
        // if (checkboxColumn && this.tableFullData.length > 300 && !this.checkboxOpts.checkField) {
        //   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])
        // }
        if ((scrollXLoad || scrollYLoad) && expandColumn && expandOpts.mode !== 'fixed') {
          warnLog('vxe.error.scrollErrProp', ['column.type=expand']);
        }
        this.recalculate();
      });
    },
    staticColumns(value) {
      this.handleColumn(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(value));
    },
    tableColumn() {
      this.analyColumnWidth();
    },
    upDataFlag() {
      this.$nextTick().then(() => this.updateData());
    },
    reColumnFlag() {
      this.$nextTick().then(() => this.refreshColumn());
    },
    computeSize() {
      this.reScrollFlag++;
    },
    showHeader() {
      this.reScrollFlag++;
    },
    showFooter() {
      this.reScrollFlag++;
    },
    overflowX() {
      this.reScrollFlag++;
    },
    overflowY() {
      this.reScrollFlag++;
    },
    reScrollFlag() {
      const $xeTable = this;
      $xeTable.$nextTick(() => {
        $xeTable.recalculate(true).then(() => $xeTable.refreshScroll());
      });
    },
    height() {
      this.reLayoutFlag++;
    },
    maxHeight() {
      this.reLayoutFlag++;
    },
    computeScrollbarXToTop() {
      this.reLayoutFlag++;
    },
    computeScrollbarYToLeft() {
      this.reLayoutFlag++;
    },
    computeVxeLanguage() {
      this.reLayoutFlag++;
    },
    reLayoutFlag() {
      const $xeTable = this;
      $xeTable.$nextTick(() => $xeTable.recalculate(true));
    },
    footerData() {
      this.footFlag++;
    },
    footFlag() {
      const $xeTable = this;
      $xeTable.updateFooter();
    },
    syncResize(value) {
      if (value) {
        handleUpdateResize(this);
        this.$nextTick(() => {
          handleUpdateResize(this);
          setTimeout(() => handleUpdateResize(this));
        });
      }
    },
    tabsResizeFlag() {
      this.handleGlobalResizeEvent();
    },
    mergeCells(value) {
      this.clearMergeCells();
      this.$nextTick(() => this.setMergeCells(value));
    },
    mergeFooterItems(value) {
      this.clearMergeFooterItems();
      this.$nextTick(() => this.setMergeFooterItems(value));
    },
    computeRowGroupFields(val) {
      const $xeTable = this;
      $xeTable.handleUpdateRowGroup(val);
    },
    computeRowField() {
      const $xeTable = this;
      const reactData = $xeTable;
      const internalData = $xeTable;
      // 行主键被改变，重载表格
      const {
        inited,
        tableFullData
      } = internalData;
      if (inited) {
        handleKeyField($xeTable);
        reactData.tableData = [];
        $xeTable.$nextTick(() => {
          $xeTable.reloadData(tableFullData);
        });
      }
    }
  },
  created() {
    const $xeTable = this;
    const props = $xeTable;
    const internalData = $xeTable;
    Object.assign($xeTable, {
      tZindex: 0,
      currKeyField: '',
      isCurrDeepKey: false,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      // 当前 hover 行
      // hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      afterGroupFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      // 行分组全量数据、条件处理后
      tableFullGroupData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 全量数据集（包括当前和已删除）
      fullAllDataRowIdData: {},
      // 数据集（仅当前）
      fullDataRowIdData: {},
      // 数据集（仅可视）
      visibleDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 合并单元格的数据
      mergeBodyList: [],
      mergeBodyMaps: {},
      // 合并表尾的数据
      mergeFooterList: [],
      mergeFooterMaps: {},
      // 已合并单元格数据集合
      mergeBodyCellMaps: {},
      // 已合并表尾数据集合
      mergeFooterCellMaps: {},
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开的分组行
      rowGroupExpandedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 已标记的对象集
      pendingRowMaps: {},
      // 已新增的临时行
      insertRowMaps: {},
      // 已删除行
      removeRowMaps: {},
      cvCacheMaps: {},
      swYSize: 0,
      swYInterval: 0,
      swYTotal: 0
    });
    handleKeyField($xeTable);
    const {
      data,
      exportConfig,
      importConfig,
      treeConfig,
      showOverflow,
      highlightCurrentRow,
      highlightCurrentColumn
    } = props;
    const {
      scrollXStore,
      scrollYStore
    } = internalData;
    const columnOpts = $xeTable.computeColumnOpts;
    const editOpts = $xeTable.computeEditOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const radioOpts = $xeTable.computeRadioOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const expandOpts = $xeTable.computeExpandOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const customOpts = $xeTable.computeCustomOpts;
    const mouseOpts = $xeTable.computeMouseOpts;
    const exportOpts = $xeTable.computeExportOpts;
    const importOpts = $xeTable.computeImportOpts;
    const currentRowOpts = $xeTable.computeCurrentRowOpts;
    const currentColumnOpts = $xeTable.computeCurrentColumnOpts;
    const keyboardOpts = $xeTable.computeKeyboardOpts;
    const aggregateOpts = $xeTable.computeAggregateOpts;
    const {
      groupFields
    } = aggregateOpts;
    if (props.rowId) {
      warnLog('vxe.error.delProp', ['row-id', 'row-config.keyField']);
    }
    if (props.rowKey) {
      warnLog('vxe.error.delProp', ['row-key', 'row-config.useKey']);
    }
    if (props.columnKey) {
      warnLog('vxe.error.delProp', ['column-id', 'column-config.useKey']);
    }
    if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
      warnLog('vxe.error.reqProp', ['row-config.keyField']);
    }
    if (props.editConfig && editOpts.showStatus && !props.keepSource) {
      warnLog('vxe.error.reqProp', ['keep-source']);
    }
    if (treeConfig && (treeOpts.showLine || treeOpts.line) && !showOverflow) {
      warnLog('vxe.error.reqProp', ['show-overflow']);
    }
    if (treeConfig && !treeOpts.transform && props.stripe) {
      warnLog('vxe.error.noTree', ['stripe']);
    }
    if (props.showFooter && !(props.footerMethod || props.footerData)) {
      warnLog('vxe.error.reqProp', ['footer-data | footer-method']);
    }
    if (rowOpts.height) {
      warnLog('vxe.error.delProp', ['row-config.height', 'cell-config.height']);
    }
    if (this.tooltipOpts.enabled) {
      warnLog('vxe.error.delProp', ['tooltip-config.enabled', 'tooltip-config.showAll']);
    }
    if (this.highlightCurrentRow) {
      warnLog('vxe.error.delProp', ['highlight-current-row', 'row-config.isCurrent']);
    }
    if (this.highlightHoverRow) {
      warnLog('vxe.error.delProp', ['highlight-hover-row', 'row-config.isHover']);
    }
    if (this.highlightCurrentColumn) {
      warnLog('vxe.error.delProp', ['highlight-current-column', 'column-config.isCurrent']);
    }
    if (this.highlightHoverColumn) {
      warnLog('vxe.error.delProp', ['highlight-hover-column', 'column-config.isHover']);
    }
    if (props.resizable) {
      warnLog('vxe.error.delProp', ['resizable', 'column-config.resizable']);
    }
    // if (props.scrollY) {
    //   warnLog('vxe.error.delProp', ['scroll-y', 'virtual-y-config'])
    // }
    // if (props.scrollX) {
    //   warnLog('vxe.error.delProp', ['scroll-x', 'virtual-x-config'])
    // }
    // 检查导入导出类型，如果自定义导入导出方法，则不校验类型
    if (importConfig && importOpts.types && !importOpts.importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps), importOpts.types)) {
      warnLog('vxe.error.errProp', [`export-config.types=${importOpts.types.join(',')}`, importOpts.types.filter(type => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps), type)).join(',') || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps).join(',')]);
    }
    if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps), exportOpts.types)) {
      warnLog('vxe.error.errProp', [`export-config.types=${exportOpts.types.join(',')}`, exportOpts.types.filter(type => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps), type)).join(',') || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps).join(',')]);
    }
    if (!props.id) {
      if ((props.customConfig ? isEnableConf(customOpts) : customOpts.enabled) && customOpts.storage) {
        errLog('vxe.error.reqProp', ['id']);
      }
    }
    if (treeConfig && checkboxOpts.range) {
      errLog('vxe.error.noTree', ['checkbox-config.range']);
    }
    if (rowOpts.height && !this.showOverflow) {
      warnLog('vxe.error.notProp', ['table.show-overflow']);
    }
    if (!$xeTable.triggerCellAreaMousedownEvent) {
      if (props.areaConfig) {
        warnLog('vxe.error.notProp', ['area-config']);
      }
      if (props.clipConfig) {
        warnLog('vxe.error.notProp', ['clip-config']);
      }
      if (props.fnrConfig) {
        warnLog('vxe.error.notProp', ['fnr-config']);
      }
      if (mouseOpts.area) {
        errLog('vxe.error.notProp', ['mouse-config.area']);
        return;
      }
    }
    if (treeConfig && rowOpts.drag && !treeOpts.transform) {
      warnLog('vxe.error.notSupportProp', ['column-config.drag', 'tree-config.transform=false', 'tree-config.transform=true']);
    }
    if (props.dragConfig) {
      warnLog('vxe.error.delProp', ['drag-config', 'row-drag-config']);
    }
    if (props.rowGroupConfig) {
      warnLog('vxe.error.delProp', ['row-group-config', 'aggregate-config']);
    }
    if (aggregateOpts.countFields) {
      warnLog('vxe.error.delProp', ['row-group-config.countFields', 'column.agg-func']);
    }
    if (aggregateOpts.countMethod) {
      warnLog('vxe.error.delProp', ['row-group-config.countMethod', 'aggregate-config.aggregateMethod']);
    }
    if (props.treeConfig && treeOpts.children) {
      warnLog('vxe.error.delProp', ['tree-config.children', 'tree-config.childrenField']);
    }
    if (props.treeConfig && treeOpts.line) {
      warnLog('vxe.error.delProp', ['tree-config.line', 'tree-config.showLine']);
    }
    if (mouseOpts.area && mouseOpts.selected) {
      warnLog('vxe.error.errConflicts', ['mouse-config.area', 'mouse-config.selected']);
    }
    if (mouseOpts.area && props.treeConfig && !treeOpts.transform) {
      errLog('vxe.error.noTree', ['mouse-config.area']);
    }
    if (props.editConfig && editOpts.activeMethod) {
      warnLog('vxe.error.delProp', ['table.edit-config.activeMethod', 'table.edit-config.beforeEditMethod']);
    }
    if (props.treeConfig && checkboxOpts.isShiftKey) {
      errLog('vxe.error.errConflicts', ['tree-config', 'checkbox-config.isShiftKey']);
    }
    if (checkboxOpts.halfField) {
      warnLog('vxe.error.delProp', ['checkbox-config.halfField', 'checkbox-config.indeterminateField']);
    }
    // 在 v3.0 中废弃 context-menu
    if (this.contextMenu) {
      warnLog('vxe.error.delProp', ['context-menu', 'menu-config']);
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(this.contextMenu)) {
        warnLog('vxe.error.errProp', [`table.context-menu=${this.contextMenu}`, 'table.context-menu={}']);
      }
    }
    if (props.menuConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.menuConfig)) {
      warnLog('vxe.error.errProp', [`table.menu-config=${props.menuConfig}`, 'table.menu-config={}']);
    }
    if (props.exportConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.exportConfig)) {
      warnLog('vxe.error.errProp', [`table.export-config=${props.exportConfig}`, 'table.export-config={}']);
    }
    if (props.importConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.importConfig)) {
      warnLog('vxe.error.errProp', [`table.import-config=${props.importConfig}`, 'table.import-config={}']);
    }
    if (props.printConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.printConfig)) {
      warnLog('vxe.error.errProp', [`table.print-config=${props.printConfig}`, 'table.print-config={}']);
    }
    if (props.treeConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.treeConfig)) {
      warnLog('vxe.error.errProp', [`table.tree-config=${props.treeConfig}`, 'table.tree-config={}']);
    }
    if (props.customConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.customConfig)) {
      warnLog('vxe.error.errProp', [`table.custom-config=${props.customConfig}`, 'table.custom-config={}']);
    }
    if (props.editConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.editConfig)) {
      warnLog('vxe.error.errProp', [`table.edit-config=${props.editConfig}`, 'table.edit-config={}']);
    }
    if (props.emptyRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(props.emptyRender)) {
      warnLog('vxe.error.errProp', [`table.empty-render=${props.emptyRender}`, 'table.empty-render={}']);
    }
    if (rowOpts.currentMethod) {
      warnLog('vxe.error.delProp', ['row-config.currentMethod', 'current-row-config.beforeSelectMethod']);
    }
    if (columnOpts.currentMethod) {
      warnLog('vxe.error.delProp', ['row-config.currentMethod', 'current-column-config.beforeSelectMethod']);
    }
    if ((rowOpts.isCurrent || highlightCurrentRow) && props.keyboardConfig && keyboardOpts.isArrow && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentRowOpts.isFollowSelected)) {
      warnLog('vxe.error.notConflictProp', ['row-config.isCurrent', 'current-row-config.isFollowSelected']);
    }
    if ((columnOpts.isCurrent || highlightCurrentColumn) && props.keyboardConfig && keyboardOpts.isArrow && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentColumnOpts.isFollowSelected)) {
      warnLog('vxe.error.notConflictProp', ['column-config.isCurrent', 'current-column-config.isFollowSelected']);
    }
    // 如果不支持虚拟滚动
    // if (props.spanMethod) {
    //   if (virtualXOpts.enabled) {
    //     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-x-config.enabled=false'])
    //   }
    //   if (virtualYOpts.enabled) {
    //     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-y-config.enabled=false'])
    //   }
    // }
    // if (props.footerSpanMethod) {
    //   if (virtualXOpts.enabled) {
    //     warnLog('vxe.error.notConflictProp', ['footer-span-method', 'virtual-x-config.enabled=false'])
    //   }
    // }
    // 检查是否有安装需要的模块
    if (props.editConfig && !$xeTable.insert) {
      errLog('vxe.error.reqModule', ['Edit']);
    }
    if (props.editRules && !$xeTable.validate) {
      errLog('vxe.error.reqModule', ['Validator']);
    }
    if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
      errLog('vxe.error.reqModule', ['Keyboard']);
    }
    if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
      errLog('vxe.error.reqModule', ['Export']);
    }
    Object.assign(scrollYStore, {
      startIndex: 0,
      endIndex: 1,
      visibleSize: 0
    });
    Object.assign(scrollXStore, {
      startIndex: 0,
      endIndex: 1,
      visibleSize: 0
    });
    this.handleUpdateRowGroup(groupFields);
    this.loadTableData(data, true).then(() => {
      if (data && data.length) {
        this.inited = true;
        this.initStatus = true;
        this.handleLoadDefaults();
      }
      this.handleInitDefaults();
      this.updateStyle();
    });
    table_globalEvents.on($xeTable, 'paste', this.handleGlobalPasteEvent);
    table_globalEvents.on($xeTable, 'copy', this.handleGlobalCopyEvent);
    table_globalEvents.on($xeTable, 'cut', this.handleGlobalCutEvent);
    table_globalEvents.on($xeTable, 'mousedown', this.handleGlobalMousedownEvent);
    table_globalEvents.on($xeTable, 'blur', this.handleGlobalBlurEvent);
    table_globalEvents.on($xeTable, 'mousewheel', this.handleGlobalMousewheelEvent);
    table_globalEvents.on($xeTable, 'keydown', this.handleGlobalKeydownEvent);
    table_globalEvents.on($xeTable, 'resize', this.handleGlobalResizeEvent);
    table_globalEvents.on($xeTable, 'contextmenu', this.handleGlobalContextmenuEvent);
    $xeTable.preventEvent(null, 'created');
  },
  mounted() {
    const $xeTable = this;
    const props = $xeTable;
    const columnOpts = $xeTable.computeColumnOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const customOpts = $xeTable.computeCustomOpts;
    const virtualYOpts = $xeTable.computeVirtualYOpts;
    if (columnOpts.drag || rowOpts.drag || customOpts.allowSort) {
      initTpImg();
    }
    const {
      $listeners
    } = this;
    if (!this.menuConfig && ($listeners['menu-click'] || $listeners['cell-menu'] || $listeners['header-cell-menu'] || $listeners['footer-cell-menu'])) {
      warnLog('vxe.error.reqProp', ['menu-config']);
    }
    if (!this.tooltipConfig && ($listeners['cell-mouseenter'] || $listeners['cell-mouseleave'])) {
      warnLog('vxe.error.reqProp', ['tooltip-config']);
    }
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUILoadingComponent = core_.VxeUI.getComponent('VxeLoading');
    const VxeUITooltipComponent = core_.VxeUI.getComponent('VxeTooltip');
    $xeTable.$nextTick(() => {
      if (props.loading) {
        if (!VxeUILoadingComponent && !this.$scopedSlots.loading) {
          errLog('vxe.error.reqComp', ['vxe-loading']);
        }
      }
      if (props.showOverflow === true || props.showOverflow === 'tooltip' || props.showHeaderOverflow === true || props.showHeaderOverflow === 'tooltip' || props.showFooterOverflow === true || props.showFooterOverflow === 'tooltip' || props.tooltipConfig || props.editRules) {
        if (!VxeUITooltipComponent) {
          errLog('vxe.error.reqComp', ['vxe-tooltip']);
        }
      }
    });
    if (this.autoResize) {
      const resizeObserver = table_globalResize.create(() => {
        if (this.autoResize) {
          this.recalculate(true);
        }
      });
      resizeObserver.observe(this.$el);
      resizeObserver.observe(this.getParentElem());
      this.$resize = resizeObserver;
    }
    if (virtualYOpts.mode !== 'scroll') {
      const tableViewportEl = $xeTable.$refs.refTableViewportElem;
      if (tableViewportEl) {
        tableViewportEl.addEventListener('wheel', $xeTable.triggerBodyWheelEvent, {
          passive: false
        });
      }
    }
    this.preventEvent(null, 'mounted');
  },
  activated() {
    this.recalculate().then(() => this.refreshScroll());
    this.preventEvent(null, 'activated');
  },
  deactivated() {
    this.preventEvent(null, 'deactivated');
  },
  beforeDestroy() {
    const $xeTable = this;
    const internalData = $xeTable;
    const tableViewportEl = $xeTable.$refs.refTableViewportElem;
    if (tableViewportEl) {
      tableViewportEl.removeEventListener('wheel', $xeTable.triggerBodyWheelEvent);
    }
    internalData.cvCacheMaps = {};
    internalData.prevDragRow = null;
    internalData.prevDragCol = null;
    if (this.$resize) {
      this.$resize.disconnect();
    }
    this.closeFilter();
    this.closeMenu();
    this.preventEvent(null, 'beforeDestroy');
  },
  destroyed() {
    const $xeTable = this;
    table_globalEvents.off($xeTable, 'paste');
    table_globalEvents.off($xeTable, 'copy');
    table_globalEvents.off($xeTable, 'cut');
    table_globalEvents.off($xeTable, 'mousedown');
    table_globalEvents.off($xeTable, 'blur');
    table_globalEvents.off($xeTable, 'mousewheel');
    table_globalEvents.off($xeTable, 'keydown');
    table_globalEvents.off($xeTable, 'resize');
    table_globalEvents.off($xeTable, 'contextmenu');
    this.preventEvent(null, 'destroyed');
  },
  render(h) {
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUILoadingComponent = core_.VxeUI.getComponent('VxeLoading');
    const VxeUITooltipComponent = core_.VxeUI.getComponent('VxeTooltip');
    const $xeTable = this;
    const $xeGrid = $xeTable.$xeGrid;
    const props = $xeTable;
    const slots = $xeTable.$scopedSlots;
    const reactData = $xeTable;
    const {
      xID
    } = $xeTable;
    const {
      loading,
      stripe,
      showHeader,
      height,
      treeConfig,
      mouseConfig,
      showFooter,
      highlightCell,
      highlightHoverRow,
      highlightHoverColumn,
      editConfig,
      editRules
    } = props;
    const {
      isGroup,
      overflowX,
      overflowY,
      scrollXLoad,
      scrollYLoad,
      tableData,
      initStore,
      isRowGroupStatus,
      columnStore,
      filterStore,
      customStore
    } = reactData;
    const {
      leftList,
      rightList
    } = columnStore;
    const loadingSlot = slots.loading;
    const tableTipConfig = $xeTable.computeTableTipConfig;
    const validTipConfig = $xeTable.computeValidTipConfig;
    const validOpts = $xeTable.computeValidOpts;
    const checkboxOpts = $xeTable.computeCheckboxOpts;
    const treeOpts = $xeTable.computeTreeOpts;
    const rowOpts = $xeTable.computeRowOpts;
    const columnOpts = $xeTable.computeColumnOpts;
    const vSize = $xeTable.computeSize;
    const tableBorder = $xeTable.computeTableBorder;
    const mouseOpts = $xeTable.computeMouseOpts;
    const areaOpts = $xeTable.computeAreaOpts;
    const loadingOpts = $xeTable.computeLoadingOpts;
    const isMenu = $xeTable.computeIsMenu;
    const currLoading = reactData.isColLoading || reactData.isRowLoading || loading;
    const resizableOpts = $xeTable.computeResizableOpts;
    const isArea = mouseConfig && mouseOpts.area;
    const columnDragOpts = $xeTable.computeColumnDragOpts;
    const scrollbarXToTop = $xeTable.computeScrollbarXToTop;
    const scrollbarYToLeft = $xeTable.computeScrollbarYToLeft;
    return h('div', {
      ref: 'refElem',
      class: ['vxe-table', 'vxe-table--render-default', `tid_${xID}`, `border--${tableBorder}`, `sx-pos--${scrollbarXToTop ? 'top' : 'bottom'}`, `sy-pos--${scrollbarYToLeft ? 'left' : 'right'}`, {
        [`size--${vSize}`]: vSize,
        [`valid-msg--${validOpts.msgMode}`]: !!editRules,
        'vxe-editable': !!editConfig,
        'old-cell-valid': editRules && table_getConfig().cellVaildMode === 'obsolete',
        'cell--highlight': highlightCell,
        'cell--selected': mouseConfig && mouseOpts.selected,
        'cell--area': isArea,
        'header-cell--area': isArea && areaOpts.selectCellByHeader,
        'body-cell--area': isArea && areaOpts.selectCellByBody,
        'row--highlight': rowOpts.isHover || highlightHoverRow,
        'column--highlight': columnOpts.isHover || highlightHoverColumn,
        'checkbox--range': checkboxOpts.range,
        'col--drag-cell': columnOpts.drag && columnDragOpts.trigger === 'cell',
        'is--header': showHeader,
        'is--footer': showFooter,
        'is--group': isGroup,
        'is-row-group': isRowGroupStatus,
        'is--tree-line': treeConfig && (treeOpts.showLine || treeOpts.line),
        'is--fixed-left': leftList.length,
        'is--fixed-right': rightList.length,
        'is--animat': !!props.animat,
        'is--round': props.round,
        'is--stripe': !treeConfig && stripe,
        'is--loading': currLoading,
        'is--empty': !currLoading && !tableData.length,
        'is--scroll-y': overflowY,
        'is--scroll-x': overflowX,
        'is--virtual-x': scrollXLoad,
        'is--virtual-y': scrollYLoad
      }],
      attrs: {
        spellcheck: false
      },
      on: {
        keydown: this.keydownEvent
      }
    }, [
    /**
     * 隐藏列
     */
    h('div', {
      class: 'vxe-table-slots',
      ref: 'hideColumn'
    }, this.$slots.default), h('div', {
      ref: 'refVarElem',
      class: 'vxe-table-vars'
    }, [h('div', {
      class: 'vxe-table-var-default'
    }), h('div', {
      class: 'vxe-table-var-medium'
    }), h('div', {
      class: 'vxe-table-var-small'
    }), h('div', {
      class: 'vxe-table-var-mini'
    })]), h('div', {
      key: 'tw',
      class: 'vxe-table--render-wrapper'
    }, scrollbarXToTop ? [renderScrollX(h, $xeTable), renderBody(h, $xeTable)] : [renderBody(h, $xeTable), renderScrollX(h, $xeTable)]),
    /**
     * 空数据
     */
    h('div', {
      key: 'tn',
      ref: 'refEmptyPlaceholder',
      class: 'vxe-table--empty-placeholder'
    }, [h('div', {
      class: 'vxe-table--empty-content'
    }, renderEmptyBody(h, this))]),
    /**
     * 边框线
     */
    h('div', {
      key: 'tl',
      class: 'vxe-table--border-line'
    }),
    /**
     * 列宽线
     */
    h('div', {
      key: 'tcl',
      ref: 'refColResizeBar',
      class: 'vxe-table--resizable-col-bar'
    }, resizableOpts.showDragTip ? [h('div', {
      ref: 'refColResizeTip',
      class: 'vxe-table--resizable-number-tip'
    })] : []),
    /**
     * 行高线
     */
    h('div', {
      key: 'trl',
      ref: 'refRowResizeBar',
      class: 'vxe-table--resizable-row-bar'
    }, resizableOpts.showDragTip ? [h('div', {
      class: 'vxe-table--resizable-number-tip'
    })] : []),
    /**
     * 加载中
     */
    VxeUILoadingComponent ? h(VxeUILoadingComponent, {
      key: 'lg',
      class: 'vxe-table--loading',
      props: {
        value: currLoading,
        icon: loadingOpts.icon,
        text: loadingOpts.text
      },
      scopedSlots: loadingSlot ? {
        default: () => $xeTable.callSlot(loadingSlot, {
          $table: $xeTable,
          $grid: $xeGrid,
          loading: currLoading
        }, h)
      } : {}
    }) : loadingSlot ? h('div', {
      class: ['vxe-loading--custom-wrapper', {
        'is--visible': currLoading
      }]
    }, $xeTable.callSlot(loadingSlot, {
      $table: $xeTable,
      $grid: $xeGrid,
      loading: currLoading
    }, h)) : table_renderEmptyElement($xeTable),
    /**
     * 自定义列
     */
    initStore.custom ? h(panel, {
      key: 'cs',
      ref: 'customWrapper',
      props: {
        customStore
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 筛选
     */
    initStore.filter ? h(filter_panel, {
      key: 'tf',
      ref: 'refTableFilter',
      props: {
        filterStore
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 导入
     */
    initStore.import && this.importConfig ? h(import_panel, {
      key: 'it',
      props: {
        defaultOptions: this.importParams,
        storeData: this.importStore
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 导出
     */
    initStore.export && (this.exportConfig || this.printConfig) ? h(export_panel, {
      key: 'et',
      props: {
        defaultOptions: this.exportParams,
        storeData: this.exportStore
      }
    }) : table_renderEmptyElement($xeTable),
    /**
       * 快捷菜单
       */
    isMenu ? h(menu_panel, {
      key: 'tm',
      ref: 'refTableMenu',
      props: {
        ctxMenuStore: this.ctxMenuStore,
        ctxMenuOpts: this.ctxMenuOpts
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 拖拽提示
     */
    table_renderDragTip(h, this), h('div', {}, [
    /**
     * 提示相关
     */
    VxeUITooltipComponent ? h(VxeUITooltipComponent, {
      key: 'ctp',
      ref: 'refCommTooltip',
      props: {
        isArrow: false,
        enterable: false
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 工具提示
     */
    VxeUITooltipComponent ? h(VxeUITooltipComponent, {
      key: 'btp',
      ref: 'refTooltip',
      props: {
        theme: tableTipConfig.theme,
        enterable: tableTipConfig.enterable,
        enterDelay: tableTipConfig.enterDelay,
        leaveDelay: tableTipConfig.leaveDelay,
        useHTML: tableTipConfig.useHTML
      }
    }) : table_renderEmptyElement($xeTable),
    /**
     * 校验提示
     */
    VxeUITooltipComponent && this.editRules && validOpts.showMessage && (validOpts.message === 'default' ? !height : validOpts.message === 'tooltip') ? h(VxeUITooltipComponent, {
      key: 'vtp',
      ref: 'refValidTooltip',
      class: [{
        'old-cell-valid': editRules && table_getConfig().cellVaildMode === 'obsolete'
      }, 'vxe-table--valid-error'],
      props: {
        theme: validTipConfig.theme,
        enterable: validTipConfig.enterable,
        enterDelay: validTipConfig.enterDelay,
        leaveDelay: validTipConfig.leaveDelay
      }
    }) : table_renderEmptyElement($xeTable)])]);
  },
  methods: methods
});
;// CONCATENATED MODULE: ./packages/toolbar/src/toolbar.ts






const {
  getConfig: toolbar_getConfig,
  getIcon: toolbar_getIcon,
  getI18n: toolbar_getI18n,
  renderer: toolbar_renderer,
  commands: toolbar_commands,
  createEvent: toolbar_createEvent,
  globalMixins: toolbar_globalMixins,
  renderEmptyElement: toolbar_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var src_toolbar = (/* define-vxe-component start */defineVxeComponent({
  name: 'VxeToolbar',
  mixins: [toolbar_globalMixins.sizeMixin],
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => toolbar_getConfig().toolbar.perfect
    },
    size: {
      type: String,
      default: () => toolbar_getConfig().toolbar.size || toolbar_getConfig().size
    },
    className: [String, Function]
  },
  inject: {
    $xeGrid: {
      default: null
    }
  },
  data() {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = {
      isRefresh: false,
      connectFlag: 0,
      columns: []
    };
    const internalData = {
      connectTable: null
    };
    return {
      xID,
      reactData,
      internalData
    };
  },
  computed: {
    ...{},
    computeRefreshOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.refresh, true), props.refresh);
    },
    computeImportOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.import, true), props.import);
    },
    computeExportOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.export, true), props.export);
    },
    computePrintOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.print, true), props.print);
    },
    computeZoomOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.zoom, true), props.zoom);
    },
    computeCustomOpts() {
      const $xeToolbar = this;
      const props = $xeToolbar;
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.custom, true), props.custom);
    },
    computeTableCustomOpts() {
      const $xeToolbar = this;
      const reactData = $xeToolbar.reactData;
      const internalData = $xeToolbar.internalData;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if (reactData.connectFlag || $table) {
        if ($table) {
          return $table.computeCustomOpts;
        }
      }
      return {
        trigger: ''
      };
    },
    computeTrigger() {
      const $xeToolbar = this;
      const tableCustomOpts = $xeToolbar.computeTableCustomOpts;
      return tableCustomOpts.trigger;
    }
  },
  methods: {
    //
    // Method
    //
    dispatchEvent(type, params, evnt) {
      const $xeToolbar = this;
      $xeToolbar.$emit(type, toolbar_createEvent(evnt, {
        $toolbar: $xeToolbar
      }, params));
    },
    fintTable() {
      const {
        $children
      } = this.$parent;
      const selfIndex = $children.indexOf(this);
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find($children, (comp, index) => comp && comp.loadData && index > selfIndex && comp.$vnode.componentOptions.tag === 'vxe-table');
    },
    syncUpdate(params) {
      const $xeToolbar = this;
      const reactData = $xeToolbar.reactData;
      const internalData = $xeToolbar.internalData;
      internalData.connectTable = params.$table;
      reactData.columns = params.collectColumn;
      reactData.connectFlag++;
    },
    checkTable() {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        return true;
      }
      errLog('vxe.error.barUnableLink');
    },
    handleClickSettingEvent({
      $event
    }) {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        }
      }
    },
    handleMouseenterSettingEvent({
      $event
    }) {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        $table.customOpenEvent($event);
      }
    },
    handleMouseleaveSettingEvent({
      $event
    }) {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        const {
          customStore
        } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    },
    refreshEvent({
      $event
    }) {
      const $xeToolbar = this;
      const reactData = $xeToolbar.reactData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        isRefresh
      } = reactData;
      const refreshOpts = $xeToolbar.computeRefreshOpts;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch(e => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xeGrid) {
          reactData.isRefresh = true;
          $xeGrid.triggerToolbarCommitEvent({
            code: refreshOpts.code || 'reload'
          }, $event).catch(e => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    },
    zoomEvent({
      $event
    }) {
      const $xeToolbar = this;
      const $xeGrid = $xeToolbar.$xeGrid;
      if ($xeGrid) {
        $xeGrid.triggerZoomEvent($event);
      }
    },
    btnEvent(evnt, item) {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = toolbar_commands.get(code);
          const params = {
            code,
            button: item,
            $table: $table,
            $grid: $xeGrid,
            $event: evnt
          };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              errLog('vxe.error.notCommands', [code]);
            }
          }
          $xeToolbar.dispatchEvent('button-click', params, evnt);
        }
      }
    },
    tolEvent(evnt, item) {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = toolbar_commands.get(code);
          const params = {
            code,
            button: null,
            tool: item,
            $table: $table,
            $grid: $xeGrid,
            $event: evnt
          };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              errLog('vxe.error.notCommands', [code]);
            }
          }
          $xeToolbar.dispatchEvent('tool-click', params, evnt);
        }
      }
    },
    importEvent() {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      if ($xeToolbar.checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openImport();
        }
      }
    },
    exportEvent() {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      if ($xeToolbar.checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openExport();
        }
      }
    },
    printEvent() {
      const $xeToolbar = this;
      const internalData = $xeToolbar.internalData;
      if ($xeToolbar.checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openPrint();
        }
      }
    },
    //
    // Render
    //
    renderDropdowns(h, item, isBtn) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const {
        dropdowns
      } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return toolbar_renderEmptyElement($xeToolbar);
          }
          return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
            key: index,
            props: {
              disabled: child.disabled,
              loading: child.loading,
              type: child.type,
              mode: child.mode,
              icon: child.icon,
              circle: child.circle,
              round: child.round,
              status: child.status,
              content: child.name,
              title: child.title,
              routerLink: child.routerLink,
              permissionCode: child.permissionCode,
              prefixTooltip: child.prefixTooltip,
              suffixTooltip: child.suffixTooltip
            },
            on: {
              click: ({
                $event
              }) => isBtn ? $xeToolbar.btnEvent($event, child) : $xeToolbar.tolEvent($event, child)
            }
          }) : toolbar_renderEmptyElement($xeToolbar);
        });
      }
      return downVNs;
    },
    /**
     * 渲染按钮
     */
    renderLeftBtns(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const props = $xeToolbar;
      const slots = $xeToolbar.$scopedSlots;
      const internalData = $xeToolbar.internalData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        buttons
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const buttonPrefixSlot = slots.buttonPrefix || slots['button-prefix'];
      const buttonSuffixSlot = slots.buttonSuffix || slots['button-suffix'];
      const btnVNs = [];
      if (buttonPrefixSlot) {
        btnVNs.push(...getSlotVNs(buttonPrefixSlot.call($xeToolbar, {
          buttons: buttons || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      if (buttons) {
        buttons.forEach(item => {
          const {
            dropdowns,
            buttonRender
          } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? toolbar_renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = {
                $grid: $xeGrid,
                $table: $table,
                button: item
              };
              btnVNs.push(h('span', {
                class: ['vxe-button--item', toolbarButtonClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : '']
              }, getSlotVNs(compConf.renderToolbarButton(h, buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  props: {
                    disabled: item.disabled,
                    loading: item.loading,
                    type: item.type,
                    mode: item.mode,
                    icon: item.icon,
                    circle: item.circle,
                    round: item.round,
                    status: item.status,
                    content: item.name,
                    title: item.title,
                    routerLink: item.routerLink,
                    permissionCode: item.permissionCode,
                    prefixTooltip: item.prefixTooltip,
                    suffixTooltip: item.suffixTooltip,
                    destroyOnClose: item.destroyOnClose,
                    placement: item.placement,
                    transfer: item.transfer
                  },
                  on: {
                    click: ({
                      $event
                    }) => this.btnEvent($event, item)
                  },
                  scopedSlots: dropdowns && dropdowns.length ? {
                    dropdowns: () => this.renderDropdowns(h, item, true)
                  } : {}
                }));
              }
            }
          }
        });
      }
      if (buttonSuffixSlot) {
        btnVNs.push(...getSlotVNs(buttonSuffixSlot.call($xeToolbar, {
          buttons: buttons || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      return btnVNs;
    },
    /**
     * 渲染右侧工具
     */
    renderRightTools(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const props = $xeToolbar;
      const slots = $xeToolbar.$scopedSlots;
      const internalData = $xeToolbar.internalData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        tools
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const toolPrefixSlot = slots.toolPrefix || slots['tool-prefix'];
      const toolSuffixSlot = slots.toolSuffix || slots['tool-suffix'];
      const btnVNs = [];
      if (toolPrefixSlot) {
        btnVNs.push(...getSlotVNs(toolPrefixSlot.call($xeToolbar, {
          tools: tools || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      if (tools) {
        tools.forEach((item, tIndex) => {
          const {
            dropdowns,
            toolRender
          } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? toolbar_renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = {
                $grid: $xeGrid,
                $table: $table,
                tool: item
              };
              btnVNs.push(h('span', {
                key: rdName,
                class: ['vxe-tool--item', toolbarToolClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : '']
              }, getSlotVNs(compConf.renderToolbarTool(h, toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  key: tIndex,
                  props: {
                    disabled: item.disabled,
                    loading: item.loading,
                    type: item.type,
                    mode: item.mode,
                    icon: item.icon,
                    circle: item.circle,
                    round: item.round,
                    status: item.status,
                    content: item.name,
                    title: item.title,
                    routerLink: item.routerLink,
                    permissionCode: item.permissionCode,
                    prefixTooltip: item.prefixTooltip,
                    suffixTooltip: item.suffixTooltip,
                    destroyOnClose: item.destroyOnClose,
                    placement: item.placement,
                    transfer: item.transfer
                  },
                  on: {
                    click: ({
                      $event
                    }) => $xeToolbar.tolEvent($event, item)
                  },
                  scopedSlots: dropdowns && dropdowns.length ? {
                    dropdowns: () => $xeToolbar.renderDropdowns(h, item, false)
                  } : {}
                }));
              }
            }
          }
        });
      }
      if (toolSuffixSlot) {
        btnVNs.push(...getSlotVNs(toolSuffixSlot.call($xeToolbar, {
          tools: tools || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      return btnVNs;
    },
    renderToolImport(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const importOpts = $xeToolbar.computeImportOpts;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'import',
        props: {
          circle: true,
          icon: importOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_IMPORT,
          title: toolbar_getI18n('vxe.toolbar.import')
        },
        on: {
          click: $xeToolbar.importEvent
        }
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderToolExport(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const exportOpts = $xeToolbar.computeExportOpts;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'export',
        props: {
          circle: true,
          icon: exportOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_EXPORT,
          title: toolbar_getI18n('vxe.toolbar.export')
        },
        on: {
          click: $xeToolbar.exportEvent
        }
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderToolPrint(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const printOpts = $xeToolbar.computePrintOpts;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'print',
        props: {
          circle: true,
          icon: printOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_PRINT,
          title: toolbar_getI18n('vxe.toolbar.print')
        },
        on: {
          click: $xeToolbar.printEvent
        }
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderToolRefresh(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const reactData = $xeToolbar.reactData;
      const refreshOpts = $xeToolbar.computeRefreshOpts;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'refresh',
        props: {
          circle: true,
          icon: reactData.isRefresh ? refreshOpts.iconLoading || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH,
          title: toolbar_getI18n('vxe.toolbar.refresh')
        },
        on: {
          click: $xeToolbar.refreshEvent
        }
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderToolZoom(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const $xeGrid = $xeToolbar.$xeGrid;
      const zoomOpts = $xeToolbar.computeZoomOpts;
      return $xeGrid && VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'zoom',
        props: {
          circle: true,
          icon: $xeGrid.isMaximized() ? zoomOpts.iconOut || toolbar_getIcon().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || toolbar_getIcon().TOOLBAR_TOOLS_FULLSCREEN,
          title: toolbar_getI18n(`vxe.toolbar.zoom${$xeGrid.isMaximized() ? 'Out' : 'In'}`)
        },
        on: {
          click: $xeToolbar.zoomEvent
        }
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderToolCustom(h) {
      // 使用已安装的组件，如果未安装则不渲染
      const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
      const $xeToolbar = this;
      const customOpts = $xeToolbar.computeCustomOpts;
      const btnTrigger = $xeToolbar.computeTrigger;
      const customBtnOns = {};
      if (btnTrigger === 'manual') {
        // 手动触发
      } else if (btnTrigger === 'hover') {
        // hover 触发
        customBtnOns.mouseenter = $xeToolbar.handleMouseenterSettingEvent;
        customBtnOns.mouseleave = $xeToolbar.handleMouseleaveSettingEvent;
      } else {
        // 点击触发
        customBtnOns.click = $xeToolbar.handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: 'custom',
        props: {
          circle: true,
          icon: customOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_CUSTOM,
          title: toolbar_getI18n('vxe.toolbar.custom'),
          className: 'vxe-toolbar-custom-target'
        },
        on: customBtnOns
      }) : toolbar_renderEmptyElement($xeToolbar);
    },
    renderVN(h) {
      const $xeToolbar = this;
      const props = $xeToolbar;
      const slots = $xeToolbar.$scopedSlots;
      const internalData = $xeToolbar.internalData;
      const $xeGrid = $xeToolbar.$xeGrid;
      const {
        perfect,
        loading,
        refresh,
        zoom,
        custom,
        className
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const toolsSlot = slots.tools;
      const buttonsSlot = slots.buttons;
      const vSize = $xeToolbar.computeSize;
      return h('div', {
        ref: 'refElem',
        class: ['vxe-toolbar', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $toolbar: $xeToolbar
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--perfect': perfect,
          'is--loading': loading
        }]
      }, [h('div', {
        class: 'vxe-buttons--wrapper'
      }, buttonsSlot ? buttonsSlot({
        $grid: $xeGrid,
        $table: $table
      }) : $xeToolbar.renderLeftBtns(h)), h('div', {
        class: 'vxe-tools--wrapper'
      }, toolsSlot ? toolsSlot({
        $grid: $xeGrid,
        $table: $table
      }) : $xeToolbar.renderRightTools(h)), h('div', {
        class: 'vxe-tools--operate'
      }, [props.import ? $xeToolbar.renderToolImport(h) : toolbar_renderEmptyElement($xeToolbar), props.export ? $xeToolbar.renderToolExport(h) : toolbar_renderEmptyElement($xeToolbar), props.print ? $xeToolbar.renderToolPrint(h) : toolbar_renderEmptyElement($xeToolbar), refresh ? $xeToolbar.renderToolRefresh(h) : toolbar_renderEmptyElement($xeToolbar), zoom && $xeGrid ? $xeToolbar.renderToolZoom(h) : toolbar_renderEmptyElement($xeToolbar), custom ? $xeToolbar.renderToolCustom(h) : toolbar_renderEmptyElement($xeToolbar)])]);
    }
  },
  created() {
    const $xeToolbar = this;
    const props = $xeToolbar;
    const $xeGrid = $xeToolbar.$xeGrid;
    $xeToolbar.$nextTick(() => {
      const {
        refresh
      } = props;
      const refreshOpts = $xeToolbar.computeRefreshOpts;
      const $xeTable = this.fintTable();
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xeGrid && !queryMethod) {
        warnLog('vxe.error.notFunc', ['queryMethod']);
      }
      if ($xeTable) {
        $xeTable.connect(this);
      }
      const customOpts = $xeToolbar.computeCustomOpts;
      if (customOpts.isFooter) {
        warnLog('vxe.error.delProp', ['toolbar.custom.isFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.showFooter) {
        warnLog('vxe.error.delProp', ['toolbar.custom.showFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.immediate) {
        warnLog('vxe.error.delProp', ['toolbar.custom.immediate', 'table.custom-config.immediate']);
      }
      if (customOpts.trigger) {
        warnLog('vxe.error.delProp', ['toolbar.custom.trigger', 'table.custom-config.trigger']);
      }
    });
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    if (props.refresh || props.import || props.export || props.print || props.zoom) {
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
    }
  },
  render(h) {
    return this.renderVN(h);
  }
})); /* define-vxe-component end */
;// CONCATENATED MODULE: ./packages/grid/src/grid.ts










const {
  getConfig: grid_getConfig,
  getI18n: grid_getI18n,
  commands: grid_commands,
  globalEvents: grid_globalEvents,
  globalMixins: grid_globalMixins,
  renderEmptyElement: grid_renderEmptyElement
} = core_.VxeUI;
const grid_methods = {};
const propKeys = Object.keys(props);
const defaultLayouts = [['Form'], ['Toolbar', 'Top', 'Table', 'Bottom', 'Pager']];
function initPages($xeGrid, propKey) {
  const props = $xeGrid;
  const reactData = $xeGrid;
  const {
    tablePage
  } = reactData;
  const {
    pagerConfig
  } = props;
  const pagerOpts = $xeGrid.computePagerOpts;
  if (pagerConfig && isEnableConf(pagerOpts)) {
    if (propKey) {
      if (pagerOpts[propKey]) {
        tablePage[propKey] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(pagerOpts[propKey]);
      }
    } else {
      const {
        currentPage,
        pageSize,
        total
      } = pagerOpts;
      if (currentPage) {
        tablePage.currentPage = currentPage;
      }
      if (pageSize) {
        tablePage.pageSize = pageSize;
      }
      if (total) {
        tablePage.pageSize = total;
      }
    }
  }
}
function renderDefaultForm(h, $xeGrid) {
  const VxeUIFormComponent = core_.VxeUI.getComponent('VxeForm');
  const props = $xeGrid;
  const slots = $xeGrid.$scopedSlots;
  const {
    proxyConfig,
    formConfig
  } = props;
  const {
    proxyOpts,
    formData,
    formOpts
  } = $xeGrid;
  if (isEnableConf(formConfig) && formOpts.items && formOpts.items.length) {
    const formSlots = {};
    if (!formOpts.inited) {
      formOpts.inited = true;
      const beforeItem = proxyOpts.beforeItem;
      if (proxyOpts && beforeItem) {
        formOpts.items.forEach(item => {
          beforeItem.call($xeGrid, {
            $grid: $xeGrid,
            item
          });
        });
      }
    }
    // 处理插槽
    formOpts.items.forEach(item => {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
          if (slots[func]) {
            formSlots[func] = slots[func];
          }
        }
      });
    });
    return [VxeUIFormComponent ? h(VxeUIFormComponent, {
      props: Object.assign({}, formOpts, {
        data: proxyConfig && proxyOpts.form ? formData : formOpts.data
      }),
      on: {
        submit: $xeGrid.submitEvent,
        reset: $xeGrid.resetEvent,
        collapse: $xeGrid.collapseEvent,
        'submit-invalid': $xeGrid.submitInvalidEvent
      },
      scopedSlots: formSlots
    }) : grid_renderEmptyElement($xeGrid)];
  }
  return [];
}
function getFuncSlot($xeGrid, optSlots, slotKey) {
  const slots = $xeGrid.$scopedSlots;
  const funcSlot = optSlots[slotKey];
  if (funcSlot) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(funcSlot)) {
      if (slots[funcSlot]) {
        return slots[funcSlot];
      } else {
        errLog('vxe.error.notSlot', [funcSlot]);
      }
    } else {
      return funcSlot;
    }
  }
  return null;
}
const getConfigSlot = ($xeGrid, slotConfigs) => {
  const slots = $xeGrid.$scopedSlots;
  const slotConf = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectMap(slotConfigs, (slotFunc, slotKey) => {
    if (slotFunc) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
        if (slots[slotFunc]) {
          slotConf[slotKey] = slots[slotFunc];
        } else {
          errLog('vxe.error.notSlot', [slotFunc]);
        }
      } else {
        slotConf[slotKey] = slotFunc;
      }
    }
  });
  return slotConf;
};
function getToolbarSlots(_vm) {
  const {
    $scopedSlots,
    toolbarOpts
  } = _vm;
  const toolbarOptSlots = toolbarOpts.slots;
  let buttonsSlot;
  let toolsSlot;
  const slots = {};
  if ($scopedSlots.buttons && (!toolbarOptSlots || toolbarOptSlots.buttons !== 'buttons')) {
    warnLog('vxe.error.reqProp', ['toolbar-config.slots.buttons']);
  }
  if ($scopedSlots.tools && (!toolbarOptSlots || toolbarOptSlots.tools !== 'tools')) {
    warnLog('vxe.error.reqProp', ['toolbar-config.slots.tools']);
  }
  if (toolbarOptSlots) {
    buttonsSlot = getFuncSlot(_vm, toolbarOptSlots, 'buttons');
    toolsSlot = getFuncSlot(_vm, toolbarOptSlots, 'tools');
    if (buttonsSlot) {
      slots.buttons = buttonsSlot;
    }
    if (toolsSlot) {
      slots.tools = toolsSlot;
    }
  }
  return slots;
}
function getTableOns(_vm) {
  const {
    $listeners,
    proxyConfig,
    proxyOpts
  } = _vm;
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each($listeners, (cb, type) => {
    ons[type] = (...args) => {
      _vm.$emit(type, ...args);
    };
  });
  if (proxyConfig) {
    if (proxyOpts.sort) {
      ons['sort-change'] = _vm.sortChangeEvent;
    }
    if (proxyOpts.filter) {
      ons['filter-change'] = _vm.filterChangeEvent;
    }
  }
  return ons;
}
function pageChangeEvent($xeGrid, params) {
  const props = $xeGrid;
  const reactData = $xeGrid;
  const {
    proxyConfig
  } = props;
  const {
    tablePage
  } = reactData;
  const {
    $event,
    currentPage,
    pageSize
  } = params;
  const proxyOpts = $xeGrid.computeProxyOpts;
  tablePage.currentPage = currentPage;
  tablePage.pageSize = pageSize;
  $xeGrid.dispatchEvent('page-change', params, $event);
  if (proxyConfig && isEnableConf(proxyOpts)) {
    $xeGrid.commitProxy('query').then(rest => {
      $xeGrid.dispatchEvent('proxy-query', rest, $event);
    });
  }
}
/**
 * 渲染表单
 */
function renderForm(h, _vm) {
  const {
    _e,
    $scopedSlots,
    formConfig
  } = _vm;
  const formSlot = $scopedSlots.form;
  const hasForm = !!(formSlot || isEnableConf(formConfig));
  if (hasForm) {
    return h('div', {
      key: 'form',
      ref: 'refFormWrapper',
      class: 'vxe-grid--form-wrapper'
    }, formSlot ? formSlot.call(_vm, {
      $grid: _vm
    }, h) : renderDefaultForm(h, _vm));
  }
  return _e();
}
/**
 * 渲染工具栏
 */
function renderToolbar(h, _vm) {
  const {
    _e,
    $scopedSlots,
    toolbarConfig,
    toolbar
  } = _vm;
  const toolbarSlot = $scopedSlots.toolbar;
  const hasToolbar = !!(toolbarSlot || isEnableConf(toolbarConfig) || toolbar);
  if (hasToolbar) {
    return h('div', {
      key: 'toolbar',
      ref: 'refToolbarWrapper',
      class: 'vxe-grid--toolbar-wrapper'
    }, toolbarSlot ? toolbarSlot.call(_vm, {
      $grid: _vm
    }, h) : [h(src_toolbar, {
      props: Object.assign({}, _vm.toolbarOpts, {
        slots: undefined
      }),
      ref: 'xToolbar',
      scopedSlots: getToolbarSlots(_vm)
    })]);
  }
  return _e();
}
/**
 * 渲染表格顶部区域
 */
function renderTop(h, _vm) {
  const {
    _e,
    $scopedSlots
  } = _vm;
  const topSlot = $scopedSlots.top;
  return topSlot ? h('div', {
    key: 'top',
    ref: 'refTopWrapper',
    class: 'vxe-grid--top-wrapper'
  }, topSlot.call(_vm, {
    $grid: _vm
  }, h)) : _e();
}
function renderTableLeft(h, _vm) {
  const {
    _e,
    $scopedSlots
  } = _vm;
  const leftSlot = $scopedSlots.left;
  if (leftSlot) {
    return h('div', {
      class: 'vxe-grid--left-wrapper'
    }, leftSlot({
      $grid: _vm
    }));
  }
  return _e();
}
function renderTableRight(h, _vm) {
  const {
    _e,
    $scopedSlots
  } = _vm;
  const rightSlot = $scopedSlots.right;
  if (rightSlot) {
    return h('div', {
      class: 'vxe-grid--right-wrapper'
    }, rightSlot({
      $grid: _vm
    }));
  }
  return _e();
}
/**
 * 渲染表格
 */
function renderTable(h, _vm) {
  const {
    $scopedSlots,
    tableProps
  } = _vm;
  return h('div', {
    class: 'vxe-grid--table-wrapper'
  }, [h('vxe-table', {
    key: 'table',
    props: tableProps,
    on: getTableOns(_vm),
    scopedSlots: $scopedSlots,
    ref: 'xTable'
  })]);
}
/**
 * 渲染表格底部区域
 */
function renderBottom(h, _vm) {
  const {
    _e,
    $scopedSlots
  } = _vm;
  const bottomSlot = $scopedSlots.bottom;
  return bottomSlot ? h('div', {
    key: 'bottom',
    ref: 'refBottomWrapper',
    class: 'vxe-grid--bottom-wrapper'
  }, bottomSlot.call(_vm, {
    $grid: _vm
  }, h)) : _e();
}
/**
 * 渲染分页
 */
function renderPager(h, $xeGrid) {
  const VxeUIPagerComponent = core_.VxeUI.getComponent('VxePager');
  const props = $xeGrid;
  const slots = $xeGrid.$scopedSlots;
  const reactData = $xeGrid;
  const {
    proxyConfig,
    pagerConfig
  } = props;
  const proxyOpts = $xeGrid.computeProxyOpts;
  const pagerOpts = $xeGrid.computePagerOpts;
  const pagerSlot = slots.pager;
  if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
    return h('div', {
      ref: 'refPagerWrapper',
      key: 'pager',
      class: 'vxe-grid--pager-wrapper'
    }, pagerSlot ? pagerSlot.call($xeGrid, {
      $grid: $xeGrid
    }) : [VxeUIPagerComponent ? h(VxeUIPagerComponent, {
      ref: 'refPager',
      props: {
        ...pagerOpts,
        ...(proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {})
      },
      on: {
        'page-change'(params) {
          pageChangeEvent($xeGrid, params);
        }
      },
      scopedSlots: getConfigSlot($xeGrid, pagerOpts.slots)
    }) : grid_renderEmptyElement($xeGrid)]);
  }
  return grid_renderEmptyElement($xeGrid);
}
function renderChildLayout(h, $xeGrid, layoutKeys) {
  const childVNs = [];
  layoutKeys.forEach(key => {
    switch (key) {
      case 'Form':
        childVNs.push(renderForm(h, $xeGrid));
        break;
      case 'Toolbar':
        childVNs.push(renderToolbar(h, $xeGrid));
        break;
      case 'Top':
        childVNs.push(renderTop(h, $xeGrid));
        break;
      case 'Table':
        childVNs.push(h('div', {
          key: 'table',
          class: 'vxe-grid--table-container'
        }, [renderTableLeft(h, $xeGrid), renderTable(h, $xeGrid), renderTableRight(h, $xeGrid)]));
        break;
      case 'Bottom':
        childVNs.push(renderBottom(h, $xeGrid));
        break;
      case 'Pager':
        childVNs.push(renderPager(h, $xeGrid));
        break;
      default:
        errLog('vxe.error.notProp', [`layouts -> ${key}`]);
        break;
    }
  });
  return childVNs;
}
function renderLayout(h, $xeGrid) {
  const slots = $xeGrid.$scopedSlots;
  const currLayoutConf = $xeGrid.computeCurrLayoutConf;
  const {
    headKeys,
    bodyKeys,
    footKeys
  } = currLayoutConf;
  const asideLeftSlot = slots.asideLeft || slots['aside-left'];
  const asideRightSlot = slots.asideRight || slots['aside-right'];
  return [h('div', {
    class: 'vxe-grid--layout-header-wrapper'
  }, renderChildLayout(h, $xeGrid, headKeys)), h('div', {
    class: 'vxe-grid--layout-body-wrapper'
  }, [asideLeftSlot ? h('div', {
    class: 'vxe-grid--layout-aside-left-wrapper'
  }, asideLeftSlot({})) : grid_renderEmptyElement($xeGrid), h('div', {
    class: 'vxe-grid--layout-body-content-wrapper'
  }, renderChildLayout(h, $xeGrid, bodyKeys)), asideRightSlot ? h('div', {
    class: 'vxe-grid--layout-aside-right-wrapper'
  }, asideRightSlot({})) : grid_renderEmptyElement($xeGrid)]), h('div', {
    class: 'vxe-grid--layout-footer-wrapper'
  }, renderChildLayout(h, $xeGrid, footKeys))];
}
Object.keys(table.methods).forEach(name => {
  grid_methods[name] = function (...args) {
    return this.$refs.xTable && this.$refs.xTable[name](...args);
  };
});
/* harmony default export */ var grid = ({
  name: 'VxeGrid',
  mixins: [grid_globalMixins.sizeMixin],
  props: {
    ...props,
    layouts: Array,
    columns: Array,
    pagerConfig: [Boolean, Object],
    proxyConfig: Object,
    toolbar: [Boolean, Object],
    toolbarConfig: [Boolean, Object],
    formConfig: [Boolean, Object],
    zoomConfig: Object,
    size: {
      type: String,
      default: () => grid_getConfig().grid.size || grid_getConfig().size
    }
  },
  provide() {
    return {
      $xeGrid: this
    };
  },
  data() {
    return {
      tableLoading: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: grid_getConfig().pager?.pageSize || 10,
        currentPage: 1
      }
    };
  },
  computed: {
    isRespMsg() {
      const {
        proxyOpts
      } = this;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg;
    },
    isActiveMsg() {
      return this.proxyOpts.showActiveMsg;
    },
    proxyOpts() {
      return this.computeProxyOpts;
    },
    computeProxyOpts() {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(grid_getConfig().grid.proxyConfig, true), this.proxyConfig);
    },
    pagerOpts() {
      return this.computePagerOpts;
    },
    computePagerOpts() {
      return Object.assign({}, grid_getConfig().grid.pagerConfig, this.pagerConfig);
    },
    formOpts() {
      return this.computeFormOpts;
    },
    computeFormOpts() {
      return Object.assign({}, grid_getConfig().grid.formConfig, this.formConfig);
    },
    toolbarOpts() {
      return this.computeToolbarOpts;
    },
    computeToolbarOpts() {
      return Object.assign({}, grid_getConfig().grid.toolbarConfig, this.toolbarConfig || this.toolbar);
    },
    zoomOpts() {
      return this.computeZoomOpts;
    },
    computeZoomOpts() {
      return Object.assign({}, grid_getConfig().grid.zoomConfig, this.zoomConfig);
    },
    computeStyles() {
      const $xeGrid = this;
      const props = $xeGrid;
      const reactData = $xeGrid;
      const {
        height,
        maxHeight
      } = props;
      const {
        isZMax,
        tZindex
      } = reactData;
      const stys = {};
      if (isZMax) {
        stys.zIndex = tZindex;
      } else {
        if (height) {
          stys.height = height === 'auto' || height === '100%' ? '100%' : toCssUnit(height);
        }
        if (maxHeight) {
          stys.maxHeight = maxHeight === 'auto' || maxHeight === '100%' ? '100%' : toCssUnit(maxHeight);
        }
      }
      return stys;
    },
    tableExtendProps() {
      const rest = {};
      propKeys.forEach(key => {
        rest[key] = this[key];
      });
      return rest;
    },
    computeTableProps() {
      const {
        isZMax,
        seqConfig,
        pagerConfig,
        loading,
        editConfig,
        proxyConfig,
        proxyOpts,
        tableExtendProps,
        tableLoading,
        tablePage
      } = this;
      const tProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tProps.maxHeight = '100%';
        } else {
          tProps.height = '100%';
        }
      }
      if (proxyConfig) {
        tProps.loading = loading || tableLoading;
        if (proxyOpts.seq && isEnableConf(pagerConfig)) {
          tProps.seqConfig = Object.assign({}, seqConfig, {
            startIndex: (tablePage.currentPage - 1) * tablePage.pageSize
          });
        }
      }
      if (editConfig) {
        tProps.editConfig = Object.assign({}, editConfig);
      }
      return tProps;
    },
    tableProps() {
      return this.computeTableProps;
    },
    computeCurrLayoutConf() {
      const $xeGrid = this;
      const props = $xeGrid;
      const {
        layouts
      } = props;
      let confs = [];
      if (layouts && layouts.length) {
        confs = layouts;
      } else {
        confs = grid_getConfig().grid.layouts || defaultLayouts;
      }
      let headKeys = [];
      let bodyKeys = [];
      let footKeys = [];
      if (confs.length) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(confs[0])) {
          headKeys = confs[0];
          bodyKeys = confs[1] || [];
          footKeys = confs[2] || [];
        } else {
          bodyKeys = confs;
        }
      }
      return {
        headKeys,
        bodyKeys,
        footKeys
      };
    },
    computeCustomCurrentPageFlag() {
      const $xeGrid = this;
      const pagerOpts = $xeGrid.computePagerOpts;
      return pagerOpts.currentPage;
    },
    computeCustomPageSizeFlag() {
      const $xeGrid = this;
      const pagerOpts = $xeGrid.computePagerOpts;
      return pagerOpts.pageSize;
    },
    computeCustomTotalFlag() {
      const $xeGrid = this;
      const pagerOpts = $xeGrid.computePagerOpts;
      return pagerOpts.total;
    }
  },
  watch: {
    columns(value) {
      this.$nextTick(() => this.loadColumn(value));
    },
    toolbar(value) {
      if (value) {
        this.initToolbar();
      }
    },
    toolbarConfig(value) {
      if (value) {
        this.initToolbar();
      }
    },
    proxyConfig() {
      this.initProxy();
    },
    computeCustomCurrentPageFlag() {
      const $xeGrid = this;
      initPages($xeGrid, 'currentPage');
    },
    computeCustomPageSizeFlag() {
      const $xeGrid = this;
      initPages($xeGrid, 'pageSize');
    },
    computeCustomTotalFlag() {
      const $xeGrid = this;
      initPages($xeGrid, 'total');
    }
  },
  created() {
    const $xeGrid = this;
    const props = $xeGrid;
    // const { data, formOpts, proxyOpts, proxyConfig } = this
    // if (proxyConfig && (data || (proxyOpts.form && formOpts.data))) {
    //   errLog('vxe.error.errConflicts', ['grid.data', 'grid.proxy-config'])
    // }
    if (this.toolbar) {
      warnLog('vxe.error.delProp', ['grid.toolbar', 'grid.toolbar-config']);
    }
    if (this.toolbarConfig && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(this.toolbarConfig)) {
      warnLog('vxe.error.errProp', [`grid.toolbar-config=${this.toolbarConfig}`, 'grid.toolbar-config={}']);
    }
    // if (proxyOpts.props) {
    //   warnLog('vxe.error.delProp', ['proxy-config.props', 'proxy-config.response'])
    // }
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUIFormComponent = core_.VxeUI.getComponent('VxeForm');
    const VxeUIPagerComponent = core_.VxeUI.getComponent('VxePager');
    $xeGrid.$nextTick(() => {
      if (props.formConfig) {
        if (!VxeUIFormComponent) {
          errLog('vxe.error.reqComp', ['vxe-form']);
        }
      }
      if (props.pagerConfig) {
        if (!VxeUIPagerComponent) {
          errLog('vxe.error.reqComp', ['vxe-pager']);
        }
      }
    });
    initPages($xeGrid);
    grid_globalEvents.on(this, 'keydown', this.handleGlobalKeydownEvent);
  },
  mounted() {
    if (this.columns && this.columns.length) {
      this.loadColumn(this.columns);
    }
    this.initToolbar();
    this.initProxy();
  },
  destroyed() {
    grid_globalEvents.off(this, 'keydown');
  },
  render(h) {
    const $xeGrid = this;
    const props = $xeGrid;
    const reactData = $xeGrid;
    const vSize = $xeGrid.computeSize;
    const styles = $xeGrid.computeStyles;
    return h('div', {
      ref: 'refElem',
      class: ['vxe-grid', {
        [`size--${vSize}`]: vSize,
        'is--animat': !!this.animat,
        'is--round': this.round,
        'is--maximize': reactData.isZMax,
        'is--loading': props.loading || reactData.tableLoading
      }],
      style: styles
    }, renderLayout(h, $xeGrid));
  },
  methods: {
    ...grid_methods,
    callSlot(slotFunc, params, h, vNodes) {
      const $xeGrid = this;
      const slots = $xeGrid.$scopedSlots;
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc.call(this, params, h, vNodes));
        }
      }
      return [];
    },
    getEl() {
      const $xeGrid = this;
      return $xeGrid.$refs.refElem;
    },
    /**
     * 获取需要排除的高度
     */
    getExcludeHeight() {
      const $xeGrid = this;
      const reactData = $xeGrid;
      const {
        isZMax
      } = reactData;
      const el = $xeGrid.$refs.refElem;
      if (el) {
        const formWrapper = $xeGrid.$refs.refFormWrapper;
        const toolbarWrapper = $xeGrid.$refs.refToolbarWrapper;
        const topWrapper = $xeGrid.$refs.refTopWrapper;
        const bottomWrapper = $xeGrid.$refs.refBottomWrapper;
        const pagerWrapper = $xeGrid.$refs.refPagerWrapper;
        const parentEl = el.parentElement;
        const parentPaddingSize = isZMax ? 0 : parentEl ? getPaddingTopBottomSize(parentEl) : 0;
        return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      }
      return 0;
    },
    getParentHeight() {
      const $xeGrid = this;
      const reactData = $xeGrid;
      const el = $xeGrid.$refs.refElem;
      if (el) {
        const parentEl = el.parentElement;
        return (reactData.isZMax ? getDomNode().visibleHeight : parentEl ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(parentEl).height) : 0) - $xeGrid.getExcludeHeight();
      }
      return 0;
    },
    initToolbar() {
      this.$nextTick(() => {
        const {
          xTable,
          xToolbar
        } = this.$refs;
        if (xTable && xToolbar) {
          xTable.connect(xToolbar);
        }
      });
    },
    initProxy() {
      const {
        proxyInited,
        proxyConfig,
        proxyOpts,
        formConfig,
        formOpts
      } = this;
      if (proxyConfig) {
        if (isEnableConf(formConfig) && proxyOpts.form && formOpts.items) {
          const fData = {};
          formOpts.items.forEach(item => {
            const {
              field,
              itemRender
            } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const {
                  defaultValue
                } = itemRender;
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
                  itemValue = defaultValue({
                    item
                  });
                } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              fData[field] = itemValue;
            }
          });
          this.formData = fData;
        }
        if (!proxyInited && proxyOpts.autoLoad !== false) {
          this.proxyInited = true;
          this.$nextTick().then(() => this.commitProxy('_init')).then(rest => {
            this.$emit('proxy-query', {
              ...rest,
              isInited: true,
              $grid: this,
              $event: new Event('init')
            });
          });
        }
      }
    },
    handleGlobalKeydownEvent(evnt) {
      const isEsc = evnt.keyCode === 27;
      if (isEsc && this.isZMax && this.zoomOpts.escRestore !== false) {
        this.triggerZoomEvent(evnt);
      }
    },
    /**
     * 提交指令，支持 code 或 button
     * @param {String/Object} code 字符串或对象
     */
    commitProxy(proxyTarget, ...args) {
      const $xeGrid = this;
      const reactData = $xeGrid;
      const {
        $refs,
        toolbar,
        toolbarConfig,
        toolbarOpts,
        proxyOpts,
        tablePage,
        pagerConfig,
        editRules,
        isRespMsg,
        isActiveMsg,
        validConfig,
        pagerOpts
      } = this;
      const {
        beforeQuery,
        afterQuery,
        beforeDelete,
        afterDelete,
        beforeSave,
        afterSave,
        ajax = {}
      } = proxyOpts;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const $xeTable = $refs.xTable;
      const formData = this.getFormData();
      let button;
      let code;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(proxyTarget)) {
        const matchObj = toolbarConfig || toolbar ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(toolbarOpts.buttons, item => item.code === proxyTarget, {
          children: 'dropdowns'
        }) : null;
        code = proxyTarget;
        button = matchObj ? matchObj.item : null;
      } else {
        button = proxyTarget;
        code = button.code;
      }
      const btnParams = button ? button.params : null;
      switch (code) {
        case 'insert':
          return $xeTable.insert({});
        case 'insert_edit':
          return $xeTable.insert({}).then(({
            row
          }) => $xeTable.setEditRow(row));
        // 已废弃
        case 'insert_actived':
          return $xeTable.insert({}).then(({
            row
          }) => $xeTable.setEditRow(row));
        // 已废弃
        case 'mark_cancel':
          this.triggerPendingEvent(code);
          break;
        case 'remove':
          return this.handleDeleteRow(code, 'vxe.grid.removeSelectRecord', () => this.removeCheckboxRow());
        case 'import':
          $xeTable.importData(btnParams);
          break;
        case 'open_import':
          $xeTable.openImport(btnParams);
          break;
        case 'export':
          $xeTable.exportData(btnParams);
          break;
        case 'open_export':
          $xeTable.openExport(btnParams);
          break;
        case 'reset_custom':
          $xeTable.resetCustom(true);
          break;
        case '_init':
        case 'reload':
        case 'query':
          {
            const ajaxMethods = ajax.query;
            const querySuccessMethods = ajax.querySuccess;
            const queryErrorMethods = ajax.queryError;
            if (ajaxMethods) {
              const isInited = code === '_init';
              const isReload = code === 'reload';
              if (!isInited && reactData.tableLoading) {
                return $xeGrid.$nextTick();
              }
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerConfig)) {
                  pageParams = {
                    ...tablePage
                  };
                }
              }
              if (isInited) {
                let defaultSort = null;
                if ($xeTable) {
                  const {
                    sortOpts
                  } = $xeTable;
                  defaultSort = sortOpts.defaultSort;
                }
                // 如果使用默认排序
                if (defaultSort) {
                  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map(item => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                if ($xeTable) {
                  filterList = $xeTable.getCheckedFilters();
                }
              } else {
                if ($xeTable) {
                  if (isReload) {
                    $xeTable.clearAll();
                  } else {
                    sortList = $xeTable.getSortColumns();
                    filterList = $xeTable.getCheckedFilters();
                  }
                }
              }
              const commitParams = {
                code,
                button,
                isInited,
                isReload,
                $grid: this,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              this.sortData = sortList;
              this.filterData = filterList;
              this.tableLoading = true;
              const applyArgs = [commitParams].concat(args);
              return Promise.resolve((beforeQuery || ajaxMethods)(...applyArgs)).then(rest => {
                let tableData = [];
                this.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(totalProp) ? totalProp({
                      data: rest,
                      $grid: this
                    }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, totalProp || 'page.total')) || 0;
                    tablePage.total = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(total);
                    const resultProp = resConfigs.result;
                    tableData = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resultProp) ? resultProp({
                      data: rest,
                      $grid: this
                    }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resultProp || 'result')) || [];
                    // 检验当前页码，不能超出当前最大页数
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    tableData = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                      data: rest,
                      $grid: this
                    }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                  }
                }
                if ($xeTable) {
                  $xeTable.loadData(tableData);
                } else {
                  $xeTable.$nextTick(() => {
                    if ($xeTable) {
                      $xeTable.loadData(tableData);
                    }
                  });
                }
                if (afterQuery) {
                  afterQuery(...applyArgs);
                }
                if (querySuccessMethods) {
                  querySuccessMethods({
                    ...commitParams,
                    response: rest
                  });
                }
                return {
                  status: true
                };
              }).catch(rest => {
                this.tableLoading = false;
                if (queryErrorMethods) {
                  queryErrorMethods({
                    ...commitParams,
                    response: rest
                  });
                }
                return {
                  status: false
                };
              });
            } else {
              errLog('vxe.error.notFunc', ['proxy-config.ajax.query']);
            }
            break;
          }
        case 'delete':
          {
            const ajaxMethods = ajax.delete;
            const deleteSuccessMethods = ajax.deleteSuccess;
            const deleteErrorMethods = ajax.deleteError;
            if (ajaxMethods) {
              const selectRecords = $xeTable.getCheckboxRecords();
              const removeRecords = selectRecords.filter(row => !$xeTable.isInsertByRow(row));
              const body = {
                removeRecords
              };
              const commitParams = {
                $grid: this,
                code,
                button,
                body,
                form: formData,
                options: ajaxMethods
              };
              const applyArgs = [commitParams].concat(args);
              if (selectRecords.length) {
                return this.handleDeleteRow(code, 'vxe.grid.deleteSelectRecord', () => {
                  if (!removeRecords.length) {
                    return $xeTable.remove(selectRecords);
                  }
                  this.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(...applyArgs)).then(rest => {
                    this.tableLoading = false;
                    $xeTable.setPendingRow(removeRecords, false);
                    if (isRespMsg) {
                      // 检测弹窗模块
                      if (!core_.VxeUI.modal) {
                        errLog('vxe.error.reqModule', ['Modal']);
                      }
                      core_.VxeUI.modal.message({
                        content: this.getRespMsg(rest, 'vxe.grid.delSuccess'),
                        status: 'success'
                      });
                    }
                    if (afterDelete) {
                      afterDelete(...applyArgs);
                    } else {
                      this.commitProxy('query');
                    }
                    if (deleteSuccessMethods) {
                      deleteSuccessMethods({
                        ...commitParams,
                        response: rest
                      });
                    }
                    return {
                      status: true
                    };
                  }).catch(rest => {
                    this.tableLoading = false;
                    if (isRespMsg) {
                      // 检测弹窗模块
                      if (!core_.VxeUI.modal) {
                        errLog('vxe.error.reqModule', ['Modal']);
                      }
                      core_.VxeUI.modal.message({
                        id: code,
                        content: this.getRespMsg(rest, 'vxe.grid.operError'),
                        status: 'error'
                      });
                    }
                    if (deleteErrorMethods) {
                      deleteErrorMethods({
                        ...commitParams,
                        response: rest
                      });
                    }
                    return {
                      status: false
                    };
                  });
                });
              } else {
                if (isActiveMsg) {
                  // 检测弹窗模块
                  if (!core_.VxeUI.modal) {
                    errLog('vxe.error.reqModule', ['Modal']);
                  }
                  core_.VxeUI.modal.message({
                    id: code,
                    content: grid_getI18n('vxe.grid.selectOneRecord'),
                    status: 'warning'
                  });
                }
              }
            } else {
              errLog('vxe.error.notFunc', ['proxy-config.ajax.delete']);
            }
            break;
          }
        case 'save':
          {
            const ajaxMethods = ajax.save;
            const saveSuccessMethods = ajax.saveSuccess;
            const saveErrorMethods = ajax.saveError;
            if (ajaxMethods) {
              const body = this.getRecordset();
              const {
                insertRecords,
                removeRecords,
                updateRecords,
                pendingRecords
              } = body;
              const commitParams = {
                $grid: this,
                code,
                button,
                body,
                form: formData,
                options: ajaxMethods
              };
              const applyArgs = [commitParams].concat(args);
              // 排除掉新增且标记为删除的数据
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter(row => insertRecords.indexOf(row) === -1);
              }
              // 排除已标记为删除的数据
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter(row => pendingRecords.indexOf(row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                // 只校验新增和修改的数据
                restPromise = this[validConfig && validConfig.msgMode === 'full' ? 'fullValidate' : 'validate'](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then(errMap => {
                if (errMap) {
                  // 如果校验不通过
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  this.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(...applyArgs)).then(rest => {
                    this.tableLoading = false;
                    $xeTable.clearPendingRow();
                    if (isRespMsg) {
                      // 检测弹窗模块
                      if (!core_.VxeUI.modal) {
                        errLog('vxe.error.reqModule', ['Modal']);
                      }
                      core_.VxeUI.modal.message({
                        content: this.getRespMsg(rest, 'vxe.grid.saveSuccess'),
                        status: 'success'
                      });
                    }
                    if (afterSave) {
                      afterSave(...applyArgs);
                    } else {
                      this.commitProxy('query');
                    }
                    if (saveSuccessMethods) {
                      saveSuccessMethods({
                        ...commitParams,
                        response: rest
                      });
                    }
                    return {
                      status: true
                    };
                  }).catch(rest => {
                    this.tableLoading = false;
                    if (isRespMsg) {
                      // 检测弹窗模块
                      if (!core_.VxeUI.modal) {
                        errLog('vxe.error.reqModule', ['Modal']);
                      }
                      core_.VxeUI.modal.message({
                        id: code,
                        content: this.getRespMsg(rest, 'vxe.grid.operError'),
                        status: 'error'
                      });
                    }
                    if (saveErrorMethods) {
                      saveErrorMethods({
                        ...commitParams,
                        response: rest
                      });
                    }
                    return {
                      status: false
                    };
                  });
                } else {
                  if (isActiveMsg) {
                    // 检测弹窗模块
                    if (!core_.VxeUI.modal) {
                      errLog('vxe.error.reqModule', ['Modal']);
                    }
                    core_.VxeUI.modal.message({
                      id: code,
                      content: grid_getI18n('vxe.grid.dataUnchanged'),
                      status: 'info'
                    });
                  }
                }
              });
            } else {
              errLog('vxe.error.notFunc', ['proxy-config.ajax.save']);
            }
            break;
          }
        default:
          {
            const gCommandOpts = grid_commands.get(code);
            if (gCommandOpts) {
              if (gCommandOpts.commandMethod) {
                gCommandOpts.commandMethod({
                  code,
                  button,
                  $grid: this,
                  $table: $xeTable
                }, ...args);
              } else {
                errLog('vxe.error.notCommands', [code]);
              }
            }
          }
      }
      return this.$nextTick();
    },
    getRespMsg(rest, defaultMsg) {
      const {
        proxyOpts
      } = this;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      let msg;
      if (rest && resConfigs.message) {
        msg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resConfigs.message);
      }
      return msg || grid_getI18n(defaultMsg);
    },
    handleDeleteRow(code, alertKey, callback) {
      const selectRecords = this.getCheckboxRecords();
      if (this.isActiveMsg) {
        if (selectRecords.length) {
          return core_.VxeUI.modal.confirm({
            id: `cfm_${code}`,
            content: grid_getI18n(alertKey),
            escClosable: true
          }).then(type => {
            if (type === 'confirm') {
              return callback();
            }
          });
        } else {
          // 检测弹窗模块
          if (!core_.VxeUI.modal) {
            errLog('vxe.error.reqModule', ['Modal']);
          }
          core_.VxeUI.modal.message({
            id: `msg_${code}`,
            content: grid_getI18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    },
    getFormData() {
      const {
        proxyConfig,
        proxyOpts,
        formOpts,
        formData
      } = this;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    },
    getFormItems(itemIndex) {
      const {
        formConfig,
        formOpts
      } = this;
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(isEnableConf(formConfig) && formOpts.items ? formOpts.items : [], item => {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(itemIndex) ? itemList : itemList[itemIndex];
    },
    triggerToolbarCommitEvent(params, evnt) {
      const {
        code
      } = params;
      return this.commitProxy(params, evnt).then(rest => {
        if (code && rest && rest.status && ['query', 'reload', 'delete', 'save'].includes(code)) {
          this.$emit(code === 'delete' || code === 'save' ? `proxy-${code}` : 'proxy-query', {
            ...rest,
            isReload: code === 'reload',
            $grid: this,
            $event: evnt
          });
        }
      });
    },
    triggerToolbarBtnEvent(button, evnt) {
      this.triggerToolbarCommitEvent(button, evnt);
      this.$emit('toolbar-button-click', {
        code: button.code,
        button,
        $grid: this,
        $event: evnt
      });
    },
    triggerToolbarTolEvent(tool, evnt) {
      this.triggerToolbarCommitEvent(tool, evnt);
      this.$emit('toolbar-tool-click', {
        code: tool.code,
        tool,
        $grid: this,
        $event: evnt
      });
    },
    triggerPendingEvent(code) {
      const {
        isActiveMsg
      } = this;
      const selectRecords = this.getCheckboxRecords();
      if (selectRecords.length) {
        this.togglePendingRow(selectRecords);
        this.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          // 检测弹窗模块
          if (!core_.VxeUI.modal) {
            errLog('vxe.error.reqModule', ['Modal']);
          }
          core_.VxeUI.modal.message({
            id: code,
            content: grid_getI18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      }
    },
    sortChangeEvent(params) {
      const {
        $table,
        column,
        sortList
      } = params;
      const isRemote = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.remoteSort) ? column.remoteSort : $table.sortOpts.remote;
      // 如果是服务端排序
      if (isRemote) {
        this.sortData = sortList;
        if (this.proxyConfig) {
          this.tablePage.currentPage = 1;
          this.commitProxy('query').then(rest => {
            this.$emit('proxy-query', {
              ...rest,
              $grid: this,
              $event: params.$event
            });
          });
        }
      }
      this.$emit('sort-change', Object.assign({
        $grid: this
      }, params));
    },
    filterChangeEvent(params) {
      const {
        $table,
        filterList
      } = params;
      // 如果是服务端过滤
      if ($table.filterOpts.remote) {
        this.filterData = filterList;
        if (this.proxyConfig) {
          this.tablePage.currentPage = 1;
          this.commitProxy('query').then(rest => {
            this.$emit('proxy-query', {
              ...rest,
              $grid: this,
              $event: params.$event
            });
          });
        }
      }
      this.$emit('filter-change', Object.assign({
        $grid: this
      }, params));
    },
    submitEvent(params) {
      const $xeGrid = this;
      const reactData = $xeGrid;
      const {
        proxyConfig
      } = this;
      if (reactData.tableLoading) {
        return;
      }
      if (proxyConfig) {
        this.commitProxy('reload').then(rest => {
          this.$emit('proxy-query', {
            ...rest,
            isReload: true,
            $grid: this,
            $event: params.$event
          });
        });
      }
      this.$emit('form-submit', Object.assign({
        $grid: this
      }, params));
    },
    resetEvent(params) {
      const {
        proxyConfig
      } = this;
      const $xeTable = this.$refs.xTable;
      if (proxyConfig) {
        $xeTable.clearScroll();
        this.commitProxy('reload').then(rest => {
          this.$emit('proxy-query', {
            ...rest,
            isReload: true,
            $grid: this,
            $event: params.$event
          });
        });
      }
      this.$emit('form-reset', Object.assign({
        $grid: this
      }, params));
    },
    submitInvalidEvent(params) {
      this.$emit('form-submit-invalid', Object.assign({
        $grid: this
      }, params));
    },
    collapseEvent(params) {
      this.$nextTick(() => this.recalculate(true));
      this.$emit('form-toggle-collapse', Object.assign({
        $grid: this
      }, params));
      this.$emit('form-collapse', Object.assign({
        $grid: this
      }, params));
    },
    triggerZoomEvent(evnt) {
      this.zoom();
      this.$emit('zoom', {
        $grid: this,
        type: this.isZMax ? 'max' : 'revert',
        $event: evnt
      });
    },
    zoom() {
      return this[this.isZMax ? 'revert' : 'maximize']();
    },
    isMaximized() {
      return this.isZMax;
    },
    maximize() {
      return this.handleZoom(true);
    },
    revert() {
      return this.handleZoom();
    },
    handleZoom(isMax) {
      const {
        isZMax
      } = this;
      if (isMax ? !isZMax : isZMax) {
        this.isZMax = !isZMax;
        if (this.tZindex < getLastZIndex()) {
          this.tZindex = nextZIndex();
        }
      }
      return this.$nextTick().then(() => this.recalculate(true)).then(() => {
        setTimeout(() => this.recalculate(true), 15);
        return this.isZMax;
      });
    },
    getProxyInfo() {
      const $xeGrid = this;
      const $xeTable = $xeGrid.$refs.xTable;
      const {
        sortData,
        proxyConfig
      } = this;
      if (proxyConfig) {
        return {
          data: $xeTable ? $xeTable.getFullData() : [],
          filter: this.filterData,
          form: this.getFormData(),
          sort: sortData.length ? sortData[0] : {},
          sorts: sortData,
          pager: this.tablePage,
          pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
        };
      }
      return null;
    },
    loadColumn(columns) {
      const $xeGrid = this;
      const $xeTable = $xeGrid.$refs.xTable;
      const {
        $scopedSlots
      } = this;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
        if (column.slots) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(column.slots, func => {
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
              if (!$scopedSlots[func]) {
                errLog('vxe.error.notSlot', [func]);
              }
            }
          });
        }
      });
      return $xeTable.loadColumn(columns);
    },
    reloadColumn(columns) {
      const $xeGrid = this;
      $xeGrid.clearAll();
      return $xeGrid.loadColumn(columns);
    }
  }
});
;// CONCATENATED MODULE: ./packages/grid/index.ts


const VxeGrid = Object.assign({}, grid, {
  install(app) {
    app.component(grid.name, grid);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(grid.name, grid);
}
core_.VxeUI.component(grid);
const Grid = VxeGrid;
/* harmony default export */ var packages_grid = ((/* unused pure expression or super */ null && (VxeGrid)));
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);
;// CONCATENATED MODULE: ./packages/table/render/index.ts






const {
  getConfig: render_getConfig,
  renderer: render_renderer,
  getI18n: render_getI18n,
  getComponent
} = core_.VxeUI;
const componentDefaultModelProp = 'value';
const defaultCompProps = {};
function handleDefaultValue(value, defaultVal, initVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(value) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(defaultVal) ? initVal : defaultVal : value;
}
function parseDate(value, props) {
  return value && props.valueFormat ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const {
    dateConfig = {}
  } = props;
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, render_getI18n(`vxe.input.date.labelFormat.${props.type || 'date'}`));
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return getOldComponentName(name);
}
function getDefaultComponent({
  name
}) {
  return getComponent(name) || name;
}
function handleConfirmFilter(params, checked, option) {
  const {
    $panel
  } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const {
    name,
    immediate,
    props
  } = renderOpts;
  if (!immediate) {
    if (name === 'VxeInput' || name === '$input') {
      const {
        type
      } = props || {};
      return !(!type || type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    }
    if (name === 'input' || name === 'textarea' || name === '$textarea') {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({
    immediate: getInputImmediateModel(renderOpts)
  }, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === 'cell' || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(h, renderOpts, params, cellLabel, opts) {
  const {
    placeholder
  } = renderOpts;
  return [h('span', {
    class: ['vxe-cell--label', opts ? opts.class : '']
  }, placeholder && isEmptyValue(cellLabel) ? [h('span', {
    class: 'vxe-cell--placeholder'
  }, formatText(getFuncText(placeholder), 1))] : formatText(cellLabel, 1))];
}
/**
 * 原生事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getNativeElementOns(renderOpts, params, eFns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc
  } = eFns || {};
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (evnt) {
      changeFunc(evnt);
      if (events && events[changeEvent]) {
        events[changeEvent](params, evnt);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (evnt) {
      blurFunc(evnt);
      if (events && events[blurEvent]) {
        events[blurEvent](params, evnt);
      }
    };
  }
  return ons;
}
const blurEvent = 'blur';
/**
 * 组件事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc
  } = eFns || {};
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
        errLog('vxe.error.errFunc', [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (...args) {
      blurFunc(...args);
      if (events && events[blurEvent]) {
        events[blurEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const {
    model
  } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, {
    model(cellValue) {
      // 处理 model 值双向绑定
      model.update = true;
      model.value = cellValue;
      if (isImmediate) {
        setCellValue(row, column, cellValue);
      }
    },
    change(eventParams) {
      // 处理 change 事件相关逻辑
      if (!isImmediate && name && ['VxeInput', 'VxeNumberInput', 'VxeTextarea', '$input', '$textarea'].includes(name)) {
        const cellValue = eventParams.value;
        model.update = true;
        model.value = cellValue;
        $table.updateStatus(params, cellValue);
      } else {
        $table.updateStatus(params);
      }
    },
    blur() {
      if (isImmediate) {
        $table.handleCellRuleUpdateStatus('blur', params);
      } else {
        $table.handleCellRuleUpdateStatus('blur', params, model.value);
      }
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, {
    model(value) {
      // 处理 model 值双向绑定
      option.data = value;
    },
    change() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    }
  });
}
function getNativeEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    model
  } = column;
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      // 处理 model 值双向绑定
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        if (isImmediateCell(renderOpts, params)) {
          setCellValue(row, column, cellValue);
        } else {
          model.update = true;
          model.value = cellValue;
        }
      }
    },
    change(evnt) {
      // 处理 change 事件相关逻辑
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    },
    blur(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    }
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      // 处理 model 值双向绑定
      const targetEl = evnt.target;
      if (targetEl) {
        option.data = targetEl.value;
      }
    },
    change() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    }
  });
}
/**
 * 单元格可编辑渲染-原生的标签
 * input、textarea、select
 */
function nativeEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [h(name, {
    class: `vxe-default-${name}`,
    attrs: getNativeAttrs(renderOpts),
    domProps: {
      value: cellValue
    },
    on: getNativeEditOns(renderOpts, params)
  })];
}
function buttonCellRender(h, renderOpts, params) {
  return [h(getDefaultComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, null),
    on: getComponentOns(renderOpts, params)
  })];
}
function defaultEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [h(getDefaultComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue),
    on: getEditOns(renderOpts, params)
  })];
}
function checkboxEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [h(getDefaultComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue),
    on: getEditOns(renderOpts, params)
  })];
}
function radioAndCheckboxGroupEditRender(h, renderOpts, params) {
  const {
    options
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [h(getDefaultComponent(renderOpts), {
    props: {
      options,
      ...getCellEditProps(renderOpts, params, cellValue)
    },
    on: getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [h(getOldComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue),
    on: getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonEditRender(h, renderOpts, params) {
  return [h('vxe-button', {
    props: getCellEditProps(renderOpts, params, null),
    on: getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsEditRender(h, renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonEditRender(h, childRenderOpts, params)[0]);
}
function renderNativeOptgroups(h, renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return h('optgroup', {
        key: gIndex,
        attrs: {
          label: group[groupLabel]
        }
      }, renderOptionsMethods(h, group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
/**
 * 渲染原生的 option 标签
 */
function renderNativeOptions(h, options, renderOpts, params) {
  const {
    optionProps = {}
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  if (options) {
    return options.map((option, oIndex) => {
      return h('option', {
        key: oIndex,
        attrs: {
          value: option[valueProp],
          disabled: option[disabledProp]
        },
        domProps: {
          /* eslint-disable eqeqeq */
          selected: option[valueProp] == cellValue
        }
      }, option[labelProp]);
    });
  }
  return [];
}
function nativeFilterRender(h, renderOpts, params) {
  const {
    column
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return h(name, {
      key: oIndex,
      class: `vxe-default-${name}`,
      attrs,
      domProps: {
        value: option.data
      },
      on: getNativeFilterOns(renderOpts, params, option)
    });
  });
}
function defaultFilterRender(h, renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getDefaultComponent(renderOpts), {
      key: oIndex,
      props: getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      on: getFilterOns(renderOpts, params, option)
    });
  });
}
/**
 * 已废弃
 * @deprecated
 */
function oldFilterRender(h, renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getOldComponent(renderOpts), {
      key: oIndex,
      props: getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      on: getFilterOns(renderOpts, params, option)
    });
  });
}
function handleFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return cellValue == data;
}
function handleInputFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(h, renderOpts, params) {
  return [h('select', {
    class: 'vxe-default-select',
    attrs: getNativeAttrs(renderOpts),
    on: getNativeEditOns(renderOpts, params)
  }, renderOpts.optionGroups ? renderNativeOptgroups(h, renderOpts, params, renderNativeOptions) : renderNativeOptions(h, renderOpts.options, renderOpts, params))];
}
function defaultSelectEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [h(getDefaultComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    on: getEditOns(renderOpts, params)
  })];
}
function defaultTableOrTreeSelectEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [h(getDefaultComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps
    }),
    on: getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldSelectEditRender(h, renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [h(getOldComponent(renderOpts), {
    props: getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    on: getEditOns(renderOpts, params)
  })];
}
function getSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionGroups,
    optionProps = {},
    optionGroupProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  if (!(cellValue === null || cellValue === undefined)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue) ? cellValue : [cellValue], optionGroups ? value => {
      const groupOptions = optionGroupProps.options || 'options';
      for (let index = 0; index < optionGroups.length; index++) {
        /* eslint-disable eqeqeq */
        selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(optionGroups[index][groupOptions], item => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : value => {
      /* eslint-disable eqeqeq */
      selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(options, item => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(', ');
  }
  return '';
}
function handleExportSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const childrenProp = optionProps.children || 'children';
  if (!(cellValue === null || cellValue === undefined)) {
    const keyMaps = {};
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, item => {
      keyMaps[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, valueProp)] = item;
    }, {
      children: childrenProp
    });
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue) ? cellValue : [cellValue], value => {
      const item = keyMaps[value];
      return item ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, labelProp) : item;
    }).join(', ');
  }
  return '';
}
function handleExportTreeSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
function handleNumberCell(h, renderOpts, params) {
  const {
    props = {},
    showNegativeStatus
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const {
    type
  } = props;
  let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let isNegative = false;
  if (!isEmptyValue(cellValue)) {
    const numberInputConfig = render_getConfig().numberInput || {};
    if (type === 'float') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
      if (!autoFill) {
        cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      }
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
    } else if (type === 'amount') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
      const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(cellValue, {
        digits
      });
      if (!autoFill) {
        const [iStr, dStr] = cellValue.split('.');
        if (dStr) {
          const dRest = dStr.replace(/0+$/, '');
          cellValue = dRest ? [iStr, '.', dRest].join('') : iStr;
        }
      }
      if (showCurrency) {
        cellValue = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${cellValue}`;
      }
    } else {
      if (showNegativeStatus) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue) < 0) {
          isNegative = true;
        }
      }
    }
  }
  return getCellLabelVNs(h, renderOpts, params, cellValue, isNegative ? {
    class: 'is--negative'
  } : {});
}
/**
 * 表格 - 渲染器
 */
render_renderer.mixin({
  input: {
    tableAutoFocus: 'input',
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(h, renderOpts, params) {
      const {
        column
      } = params;
      return column.filters.map((option, oIndex) => {
        return h('select', {
          key: oIndex,
          class: 'vxe-default-select',
          attrs: getNativeAttrs(renderOpts),
          on: getNativeFilterOns(renderOpts, params, option)
        }, renderOpts.optionGroups ? renderNativeOptgroups(h, renderOpts, params, renderNativeOptions) : renderNativeOptions(h, renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(h, renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const inputConfig = render_getConfig().input || {};
      const digits = props.digits || inputConfig.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'quarter':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(h, renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  FormatNumberInput: {
    renderTableDefault: handleNumberCell,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeNumberInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell: handleNumberCell,
    renderTableFooter(h, renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column,
        _columnIndex
      } = params;
      const {
        type
      } = props;
      // 兼容老模式
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row) ? row[_columnIndex] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(itemValue)) {
        const numberInputConfig = render_getConfig().numberInput || {};
        if (type === 'float') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(itemValue, digits), digits);
          if (!autoFill) {
            amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(amountLabel);
          }
          return amountLabel;
        } else if (type === 'amount') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
          const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemValue), {
            digits
          });
          if (!autoFill) {
            const [iStr, dStr] = amountLabel.split('.');
            if (dStr) {
              const dRest = dStr.replace(/0+$/, '');
              amountLabel = dRest ? [iStr, '.', dRest].join('') : iStr;
            }
          }
          if (showCurrency) {
            amountLabel = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${amountLabel}`;
          }
          return amountLabel;
        }
      }
      return getFuncText(itemValue, 1);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeDatePicker: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(h, renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        if (props.type !== 'time') {
          cellValue = getLabelFormatDate(cellValue, props);
        }
      }
      return getCellLabelVNs(h, renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeDateRangePicker: {
    tableAutoFocus: 'input',
    renderTableEdit(h, renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        $table,
        row,
        column
      } = params;
      const {
        model
      } = column;
      const cellValue = getCellValue(row, column);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, startField);
        seProps.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, endField);
        seOs['update:startValue'] = value => {
          if (startField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, startField, value);
          }
        };
        seOs['update:endValue'] = value => {
          if (endField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, endField, value);
          }
        };
      }
      return [h(getDefaultComponent(renderOpts), {
        props: getCellEditProps(renderOpts, params, cellValue, seProps),
        on: getComponentOns(renderOpts, params, {
          model(cellValue) {
            model.update = true;
            model.value = cellValue;
            setCellValue(row, column, cellValue);
          },
          change() {
            $table.updateStatus(params);
          },
          blur() {
            $table.handleCellRuleUpdateStatus('blur', params);
          }
        }, seOs)
      })];
    },
    renderTableCell(h, renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        row,
        column
      } = params;
      let startValue = '';
      let endValue = '';
      if (startField && endField) {
        startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, startField);
        endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, endField);
      } else {
        const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
        if (cellValue) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue)) {
            startValue = cellValue[0];
            endValue = cellValue[1];
          } else {
            const strs = `${cellValue}`.split(',');
            startValue = strs[0];
            endValue = strs[1];
          }
        }
      }
      let cellLabel = '';
      if (startValue && endValue) {
        cellLabel = `${startValue} ~ ${endValue}`;
      }
      return getCellLabelVNs(h, renderOpts, params, cellLabel);
    }
  },
  VxeTextarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: defaultEditRender
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(h, renderOpts, params) {
      const {
        options
      } = renderOpts;
      return [h(getDefaultComponent(renderOpts), {
        props: {
          options,
          ...getCellEditProps(renderOpts, params, null)
        },
        on: getComponentOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(h, renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getDefaultComponent(renderOpts), {
          key: oIndex,
          props: getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          on: getFilterOns(renderOpts, params, option)
        });
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  /**
   * 已废弃，被 FormatSelect 替换
   * @deprecated
   */
  formatOption: {
    renderTableDefault(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getSelectCellValue(renderOpts, params));
    }
  },
  FormatSelect: {
    renderTableDefault(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  /**
   * 已废弃，被 FormatTreeSelect 替换
   * @deprecated
   */
  formatTree: {
    renderTableDefault(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    }
  },
  FormatTreeSelect: {
    renderTableDefault(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeColorPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [h(getDefaultComponent(renderOpts), {
        props: getCellEditProps(renderOpts, params, cellValue, {
          colors: options
        }),
        on: getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return h('span', {
        class: 'vxe-color-picker--readonly'
      }, [h('div', {
        class: 'vxe-color-picker--readonly-color',
        style: {
          backgroundColor: cellValue
        }
      })]);
    }
  },
  VxeIconPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [h(getDefaultComponent(renderOpts), {
        props: getCellEditProps(renderOpts, params, cellValue, {
          icons: options
        }),
        on: getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return h('i', {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeCheckbox: {
    renderTableDefault: checkboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeSwitch: {
    tableAutoFocus: 'button',
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [h(getDefaultComponent(renderOpts), {
        props: {
          ...props,
          src: cellValue
        },
        on: getEditOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderTableDefault(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [h(getDefaultComponent(renderOpts), {
        props: {
          ...props,
          urlList: cellValue
        },
        on: getEditOns(renderOpts, params)
      })];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(h, renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [h(getDefaultComponent(renderOpts), {
        props: {
          ...props,
          content: cellValue
        },
        on: getEditOns(renderOpts, params)
      })];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldEditRender,
    renderTableCell(h, renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const digits = props.digits || render_getConfig().input?.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(h, renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: '.vxe-textarea--inner'
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(h, renderOpts, params) {
      return getCellLabelVNs(h, renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(h, renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getOldComponent(renderOpts), {
          key: oIndex,
          props: getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          on: getFilterOns(renderOpts, params, option)
        });
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: '.vxe-radio--input'
  },
  $checkbox: {
    tableAutoFocus: '.vxe-checkbox--input'
  },
  $switch: {
    tableAutoFocus: '.vxe-switch--button',
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 以上已废弃
});
;// CONCATENATED MODULE: ./packages/table/index.ts





let isReg = false;
const VxeTable = Object.assign({}, table, {
  install(app) {
    if (typeof window !== 'undefined') {
      if (window.VxeTableExtendCellArea && window.VxeTableExtendCellArea.use) {
        window.VxeTableExtendCellArea.use(core_.VxeUI);
      } else if (window.VXETableMixin) {
        table.mixins.push(window.VXETableMixin);
        delete window.VXETableMixin;
      }
      if (window.VxeTableExtendPivotTable && window.VxeTableExtendPivotTable.use) {
        window.VxeTableExtendPivotTable.use(core_.VxeUI);
      }
    }
    // 兼容老版本
    if (typeof window !== 'undefined' && window.VxeTableExtendCellArea && window.VxeTableExtendCellArea.init) {
      window.VxeTableExtendCellArea.init(core_.VxeUI);
      delete window.VxeTableExtendCellArea;
      delete window.VXETablePro;
    } else if (typeof window !== 'undefined' && window.VXETablePro && window.VXETablePro.init) {
      window.VXETablePro.init(core_.VxeUI);
      delete window.VXETablePro;
    }
    if (!(external_commonjs_vue_commonjs2_vue_root_Vue_default()).prototype.$vxe) {
      (external_commonjs_vue_commonjs2_vue_root_Vue_default()).prototype.$vxe = {
        t: core_.VxeUI.t,
        _t: core_.VxeUI._t
      };
    } else {
      (external_commonjs_vue_commonjs2_vue_root_Vue_default()).prototype.$vxe.t = core_.VxeUI.t;
      (external_commonjs_vue_commonjs2_vue_root_Vue_default()).prototype.$vxe._t = core_.VxeUI._t;
    }
    if (!isReg) {
      isReg = true;
      if (core_.VxeUI.dynamicApp) {
        core_.VxeUI.dynamicApp.component(table.name, table);
      }
    }
    app.component(table.name, table);
  }
});
core_.VxeUI.component(table);
const Table = VxeTable;
/* harmony default export */ var packages_table = ((/* unused pure expression or super */ null && (VxeTable)));
;// CONCATENATED MODULE: ./packages/toolbar/index.ts


const VxeToolbar = Object.assign({}, src_toolbar, {
  install(app) {
    app.component(src_toolbar.name, src_toolbar);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(src_toolbar.name, src_toolbar);
}
core_.VxeUI.component(src_toolbar);
const Toolbar = VxeToolbar;
/* harmony default export */ var toolbar = ((/* unused pure expression or super */ null && (VxeToolbar)));
;// CONCATENATED MODULE: ./packages/locale/lang/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '请输入',
      pleaseSelect: '请选择',
      comma: '，',
      fullStop: '。'
    },
    loading: {
      text: '加载中...'
    },
    error: {
      downErr: '下载失败',
      errLargeData: '当绑定的数据量过大时，应该请使用 {0}，否则可能会出现卡顿',
      groupFixed: '如果使用分组表头，冻结列必须按组设置',
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      notSupportProp: '当启用参数 "{0}" 时不支持 "{1}"，应该为 "{2}"，否则将会出现错误',
      notConflictProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会存在功能冲突',
      unableInsert: '无法插入到指定位置，请检查参数是否正确',
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: '工具栏无法关联表格',
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: '该浏览器不支持导入/导出功能',
      impFields: '导入失败，请检查字段名和数据格式是否正确',
      treeNotImp: '树表格不支持导入',
      treeCrossDrag: '只能拖拽第一层级',
      treeDragChild: '父级不能拖拽到自己的子级中',
      reqPlugin: '扩展插件未安装 "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: '超过支持的最大数据量 {0} 行，这可能会导致出现错误'
    },
    table: {
      emptyText: '暂无数据',
      allTitle: '全选/取消',
      seqTitle: '序号',
      actionTitle: '操作',
      confirmFilter: '筛选',
      resetFilter: '重置',
      allFilter: '全部',
      sortAsc: '升序：最低到最高',
      sortDesc: '降序：最高到最低',
      filter: '对所选的列启用筛选',
      impSuccess: '成功导入 {0} 条记录',
      expLoading: '正在导出中',
      expSuccess: '导出成功',
      expError: '导出失败',
      expFilename: '导出_{0}',
      expOriginFilename: '导出_源_{0}',
      customTitle: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customClose: '关闭',
      customCancel: '取消',
      customRestore: '恢复默认',
      maxFixedCol: '最大冻结列的数量不能超过 {0} 个',
      dragTip: '移动：{0}',
      resizeColTip: '宽：{0} 像素',
      resizeRowTip: '高：{0} 像素',
      rowGroupContentTotal: '{0}（{1}）'
    },
    grid: {
      selectOneRecord: '请至少选择一条记录！',
      deleteSelectRecord: '您确定要删除所选记录吗？',
      removeSelectRecord: '您确定要移除所选记录吗？',
      dataUnchanged: '数据未改动！',
      delSuccess: '成功删除所选记录！',
      saveSuccess: '保存成功！',
      operError: '发生错误，操作失败！'
    },
    select: {
      search: '搜索',
      loadingText: '加载中',
      emptyText: '暂无数据'
    },
    pager: {
      goto: '前往',
      gotoTitle: '页数',
      pagesize: '{0}条/页',
      total: '共 {0} 条记录',
      pageClassifier: '页',
      homePage: '首页',
      homePageTitle: '首页',
      prevPage: '上一页',
      prevPageTitle: '上一页',
      nextPage: '下一页',
      nextPageTitle: '下一页',
      prevJump: '向上跳页',
      prevJumpTitle: '向上跳页',
      nextJump: '向下跳页',
      nextJumpTitle: '向下跳页',
      endPage: '末页',
      endPageTitle: '末页'
    },
    alert: {
      title: '系统提示'
    },
    button: {
      confirm: '确认',
      cancel: '取消',
      clear: '清除'
    },
    filter: {
      search: '搜索'
    },
    custom: {
      cstmTitle: '列设置',
      cstmRestore: '恢复默认',
      cstmCancel: '取消',
      cstmConfirm: '确定',
      cstmConfirmRestore: '请确认是否恢复成默认列配置？',
      cstmDragTarget: '移动：{0}',
      setting: {
        colSort: '排序',
        sortHelpTip: '点击并拖动图标可以调整列的排序',
        colTitle: '列标题',
        colResizable: '列宽（像素）',
        colVisible: '是否显示',
        colFixed: '冻结列',
        colFixedMax: '冻结列（最多 {0} 列）',
        fixedLeft: '左侧',
        fixedUnset: '不设置',
        fixedRight: '右侧'
      }
    },
    import: {
      modes: {
        covering: '覆盖方式（直接覆盖表格数据）',
        insert: '底部追加（在表格的底部追加新数据）',
        insertTop: '顶部追加（在表格的顶部追加新数据）',
        insertBottom: '底部追加（在表格的底部追加新数据）'
      },
      impTitle: '导入数据',
      impFile: '文件名',
      impSelect: '选择文件',
      impType: '文件类型',
      impOpts: '参数设置',
      impMode: '导入模式',
      impConfirm: '导入',
      impCancel: '取消'
    },
    export: {
      types: {
        csv: 'CSV (逗号分隔)(*.csv)',
        html: '网页(*.html)',
        xml: 'XML 数据(*.xml)',
        txt: '文本文件(制表符分隔)(*.txt)',
        xls: 'Excel 97-2003 工作簿(*.xls)',
        xlsx: 'Excel 工作簿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        empty: '空数据',
        current: '当前数据（当前页的数据）',
        selected: '选中数据（当前页选中的数据）',
        all: '全量数据（包括所有分页的数据）'
      },
      printTitle: '打印数据',
      expTitle: '导出数据',
      expName: '文件名',
      expNamePlaceholder: '请输入文件名',
      expSheetName: '标题',
      expSheetNamePlaceholder: '请输入标题',
      expType: '保存类型',
      expMode: '选择数据',
      expCurrentColumn: '全部字段',
      expColumn: '选择字段',
      expOpts: '参数设置',
      expOptHeader: '表头',
      expHeaderTitle: '是否需要表头',
      expOptFooter: '表尾',
      expFooterTitle: '是否需要表尾',
      expOptColgroup: '分组表头',
      expOptTitle: '列标题',
      expTitleTitle: '是否为列标题，否则显示为列的字段名',
      expColgroupTitle: '如果存在，则支持带有分组结构的表头',
      expOptMerge: '合并',
      expMergeTitle: '如果存在，则支持带有合并结构的单元格',
      expOptAllExpand: '展开树',
      expAllExpandTitle: '如果存在，则支持将带有层级结构的数据全部展开',
      expOptUseStyle: '样式',
      expUseStyleTitle: '如果存在，则支持带样式的单元格',
      expOptOriginal: '源数据',
      expOriginalTitle: '如果为源数据，则支持导入到表格中',
      expPrint: '打印',
      expConfirm: '导出',
      expCancel: '取消'
    },
    modal: {
      errTitle: '错误提示',
      zoomMin: '最小化',
      zoomIn: '最大化',
      zoomOut: '还原',
      close: '关闭',
      miniMaxSize: '最小化窗口的数量不能超过 {0} 个',
      footPropErr: 'show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用'
    },
    drawer: {
      close: '关闭'
    },
    form: {
      folding: '收起',
      unfolding: '展开'
    },
    toolbar: {
      import: '导入',
      export: '导出',
      print: '打印',
      refresh: '刷新',
      zoomIn: '全屏',
      zoomOut: '还原',
      custom: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      fixedLeft: '冻结在左侧',
      fixedRight: '冻结在右侧',
      cancelFixed: '取消冻结列'
    },
    datePicker: {
      yearTitle: '{0} 年'
    },
    dateRangePicker: {
      pleaseRange: '请选择开始日期与结束日期'
    },
    input: {
      date: {
        m1: '01 月',
        m2: '02 月',
        m3: '03 月',
        m4: '04 月',
        m5: '05 月',
        m6: '06 月',
        m7: '07 月',
        m8: '08 月',
        m9: '09 月',
        m10: '10 月',
        m11: '11 月',
        m12: '12 月',
        quarterLabel: '{0} 年',
        monthLabel: '{0} 年',
        dayLabel: '{0} 年 {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy 年第 WW 周',
          month: 'yyyy-MM',
          quarter: 'yyyy 年第 q 季度',
          year: 'yyyy'
        },
        weeks: {
          w: '',
          w0: '周日',
          w1: '周一',
          w2: '周二',
          w3: '周三',
          w4: '周四',
          w5: '周五',
          w6: '周六'
        },
        months: {
          m0: '一月',
          m1: '二月',
          m2: '三月',
          m3: '四月',
          m4: '五月',
          m5: '六月',
          m6: '七月',
          m7: '八月',
          m8: '九月',
          m9: '十月',
          m10: '十一月',
          m11: '十二月'
        },
        quarters: {
          q1: '第一季度',
          q2: '第二季度',
          q3: '第三季度',
          q4: '第四季度'
        }
      }
    },
    numberInput: {
      currencySymbol: '¥'
    },
    imagePreview: {
      popupTitle: '预览',
      operBtn: {
        zoomOut: '缩小',
        zoomIn: '放大',
        pctFull: '等比例缩放',
        pct11: '显示原始尺寸',
        rotateLeft: '向左旋转',
        rotateRight: '向右旋转',
        print: '点击打印图片',
        download: '点击下载图片'
      }
    },
    upload: {
      fileBtnText: '点击或拖拽上传',
      imgBtnText: '点击或拖拽上传',
      dragPlaceholder: '请把文件拖放到这个区域即可上传',
      imgSizeHint: '单张{0}',
      imgCountHint: '最多{0}张',
      fileTypeHint: '支持 {0} 文件类型',
      fileSizeHint: '单个文件大小不超过{0}',
      fileCountHint: '最多可上传{0}个文件',
      uploadTypeErr: '文件类型不匹配！',
      overCountErr: '最多只能选择{0}个文件！',
      overCountExtraErr: '已超出最大数量{0}个，超出的{1}个文件将被忽略！',
      overSizeErr: '文件大小最大不能超过{0}！',
      reUpload: '重新上传',
      uploadProgress: '上传中 {0}%',
      uploadErr: '上传失败',
      uploadSuccess: '上传成功',
      moreBtnText: '更多（{0}）',
      viewItemTitle: '点击查看',
      morePopup: {
        readTitle: '查看列表',
        imageTitle: '上传图片',
        fileTitle: '上传文件'
      }
    },
    empty: {
      defText: '暂无数据'
    },
    colorPicker: {
      clear: '清除',
      confirm: '确认',
      copySuccess: '已复制到剪贴板：{0}'
    },
    formDesign: {
      formName: '表单名称',
      defFormTitle: '未命名的表单',
      widgetPropTab: '控件属性',
      widgetFormTab: '表单属性',
      error: {
        wdFormUni: '该类型的控件在表单中只允许添加一个',
        wdSubUni: '该类型的控件在子表中只允许添加一个'
      },
      styleSetting: {
        btn: '样式设置',
        title: '表单的样式设置',
        layoutTitle: '控件布局',
        verticalLayout: '上下布局',
        horizontalLayout: '横向布局',
        styleTitle: '标题样式',
        boldTitle: '标题加粗',
        fontBold: '加粗',
        fontNormal: '常规',
        colonTitle: '显示冒号',
        colonVisible: '显示',
        colonHidden: '隐藏',
        alignTitle: '对齐方式',
        widthTitle: '标题宽度',
        alignLeft: '居左',
        alignRight: '居右',
        unitPx: '像素',
        unitPct: '百分比'
      },
      widget: {
        group: {
          base: '基础控件',
          layout: '布局控件',
          system: '系统控件',
          module: '模块控件',
          chart: '图表控件',
          advanced: '高级控件'
        },
        copyTitle: '副本_{0}',
        component: {
          input: '输入框',
          textarea: '文本域',
          select: '下拉选择',
          row: '一行多列',
          title: '标题',
          text: '文本',
          subtable: '子表',
          VxeSwitch: '是/否',
          VxeInput: '输入框',
          VxeNumberInput: '数字',
          VxeDatePicker: '日期',
          VxeTextarea: '文本域',
          VxeSelect: '下拉选择',
          VxeTreeSelect: '树形选择',
          VxeRadioGroup: '单选框',
          VxeCheckboxGroup: '复选框',
          VxeUploadFile: '文件',
          VxeUploadImage: '图片',
          VxeRate: '评分',
          VxeSlider: '滑块'
        }
      },
      widgetProp: {
        name: '控件名称',
        placeholder: '提示语',
        required: '必填校验',
        multiple: '允许多选',
        displaySetting: {
          name: '显示设置',
          pc: '电脑端',
          mobile: '手机端',
          visible: '显示',
          hidden: '隐藏'
        },
        dataSource: {
          name: '数据源',
          defValue: '选项{0}',
          addOption: '添加选项',
          batchEditOption: '批量编辑',
          batchEditTip: '每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。',
          batchEditSubTip: '每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。',
          buildOption: '生成选项'
        },
        rowProp: {
          colSize: '列数',
          col2: '两列',
          col3: '三列',
          col4: '四列',
          col6: '六列',
          layout: '布局'
        },
        textProp: {
          name: '内容',
          alignTitle: '对齐方式',
          alignLeft: '居左',
          alignCenter: '居中',
          alignRight: '居右',
          colorTitle: '字体颜色',
          sizeTitle: '字体大小',
          boldTitle: '字体加粗',
          fontNormal: '常规',
          fontBold: '加粗'
        },
        subtableProp: {
          seqTitle: '序号',
          showSeq: '显示序号',
          showCheckbox: '允许多选',
          errSubDrag: '子表不支持该控件，请使用其他控件',
          colPlace: '将控件拖拽进来'
        },
        uploadProp: {
          limitFileCount: '文件数量限制',
          limitFileSize: '文件大小限制',
          multiFile: '允许上传多个文件',
          limitImgCount: '图片数量限制',
          limitImgSize: '图片大小限制',
          multiImg: '允许上传多张图片'
        }
      }
    },
    listDesign: {
      fieldSettingTab: '字段设置',
      listSettingTab: '参数设置',
      searchTitle: '查询条件',
      listTitle: '列表字段',
      searchField: '查询字段',
      listField: '列表字段',
      activeBtn: {
        ActionButtonUpdate: '编辑',
        ActionButtonDelete: '删除'
      },
      search: {
        addBtn: '编辑',
        emptyText: '未配置查询条件',
        editPopupTitle: '编辑查询字段'
      },
      searchPopup: {
        colTitle: '标题',
        saveBtn: '保存'
      }
    },
    text: {
      copySuccess: '已复制到剪贴板',
      copyError: '当前环境不支持该操作'
    },
    countdown: {
      formats: {
        yyyy: '年',
        MM: '月',
        dd: '天',
        HH: '时',
        mm: '分',
        ss: '秒'
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '无法对合并单元格进行该操作',
          multiErr: '无法对多重选择区域进行该操作',
          selectErr: '无法操作指定区域的单元格',
          extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
          pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作',
          cpInvalidErr: '该操作无法进行，您选择的区域中存在被禁止的列（{0}）'
        },
        fnr: {
          title: '查找和替换',
          findLabel: '查找',
          replaceLabel: '替换',
          findTitle: '查找内容：',
          replaceTitle: '替换为：',
          tabs: {
            find: '查找',
            replace: '替换'
          },
          filter: {
            re: '正则表达式',
            whole: '全词匹配',
            sensitive: '区分大小写'
          },
          btns: {
            findNext: '查找下一个',
            findAll: '查找全部',
            replace: '替换',
            replaceAll: '替换全部',
            cancel: '取消'
          },
          header: {
            seq: '#',
            cell: '单元格',
            value: '值'
          },
          body: {
            row: '行：{0}',
            col: '列：{0}'
          },
          empty: '(空值)',
          reError: '无效的正则表达式',
          recordCount: '已找到 {0} 个单元格',
          notCell: '找不到匹配的单元格',
          replaceSuccess: '成功替换 {0} 个单元格'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧'
        },
        cases: {
          equal: '等于',
          gt: '大于',
          lt: '小于',
          begin: '开头是',
          endin: '结尾是',
          include: '包含',
          isSensitive: '区分大小写'
        }
      },
      filterCombination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        cases: {
          equal: '等于',
          unequal: '不等于',
          gt: '大于',
          ge: '大于或等于',
          lt: '小于',
          le: '小于或等于',
          begin: '开头是',
          notbegin: '开头不是',
          endin: '结尾是',
          notendin: '结尾不是',
          include: '包含',
          exclude: '不包含',
          between: '介于',
          custom: '自定义筛选',
          insensitive: '不区分大小写',
          isSensitive: '区分大小写'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    },
    pro: {
      area: {
        mergeErr: '无法对合并单元格进行该操作',
        multiErr: '无法对多重选择区域进行该操作',
        extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
        pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作'
      },
      fnr: {
        title: '查找和替换',
        findLabel: '查找',
        replaceLabel: '替换',
        findTitle: '查找内容：',
        replaceTitle: '替换为：',
        tabs: {
          find: '查找',
          replace: '替换'
        },
        filter: {
          re: '正则表达式',
          whole: '全词匹配',
          sensitive: '区分大小写'
        },
        btns: {
          findNext: '查找下一个',
          findAll: '查找全部',
          replace: '替换',
          replaceAll: '替换全部',
          cancel: '取消'
        },
        header: {
          seq: '#',
          cell: '单元格',
          value: '值'
        },
        empty: '(空值)',
        reError: '无效的正则表达式',
        recordCount: '已找到 {0} 个单元格',
        notCell: '找不到匹配的单元格',
        replaceSuccess: '成功替换 {0} 个单元格'
      }
    },
    renderer: {
      search: '搜索',
      cases: {
        equal: '等于',
        unequal: '不等于',
        gt: '大于',
        ge: '大于或等于',
        lt: '小于',
        le: '小于或等于',
        begin: '开头是',
        notbegin: '开头不是',
        endin: '结尾是',
        notendin: '结尾不是',
        include: '包含',
        exclude: '不包含',
        between: '介于',
        custom: '自定义筛选',
        insensitive: '不区分大小写',
        isSensitive: '区分大小写'
      },
      combination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结到左侧',
          fixedRight: '冻结到右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/components.ts







const components = [VxeColumn, VxeColgroup, VxeGrid, VxeTable, VxeToolbar];
// 默认安装
function install(app, options) {
  core_.VxeUI.setConfig(options);
  components.forEach(component => component.install(app));
}
// 保留兼容老版本
if (!core_.VxeUI.hasLanguage('zh-CN')) {
  const defaultLanguage = 'zh-CN';
  core_.VxeUI.setI18n(defaultLanguage, zh_CN);
  core_.VxeUI.setLanguage(defaultLanguage);
}
core_.VxeUI.setTheme('light');

// Components





;// CONCATENATED MODULE: ./index.ts


if (typeof window !== 'undefined' && window.Vue) {
  if (window.VXETable) {
    if (!window.VXETable) {
      window.VXETable = components_namespaceObject;
    }
  }
  window.Vue.use(components_namespaceObject);
}

/* harmony default export */ var index = (components_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


/******/ 	return __webpack_exports__;
/******/ })()
;
});